<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Hoare2</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Hoare2</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab570"></a><h1 class="section">Hoare2: Hoare Logic, Part II</h1>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="Hoare.html#"><span class="id" type="library">Hoare</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab571"></a><h1 class="section">Decorated Programs</h1>

<div class="paragraph"> </div>

 The beauty of Hoare Logic is that it is <i>compositional</i> --
    the structure of proofs exactly follows the structure of programs.
    This suggests that we can record the essential ideas of a proof
    informally (leaving out some low-level calculational details) by
    decorating programs with appropriate assertions around each
    statement.  Such a <i>decorated program</i> carries with it
    an (informal) proof of its own correctness. 
<div class="paragraph"> </div>

 For example, here is a complete decorated program: 
<div class="paragraph"> </div>

      <a href=" True "> True </a> -&gt;&gt;
      <a href=" m = m "> m = m </a>
    X ::= m;;
      <a href=" X = m "> X = m </a> -&gt;&gt;
      <a href=" X = m /\ p = p "> X = m /\ p = p </a>
    Z ::= p;
      <a href=" X = m /\ Z = p "> X = m /\ Z = p </a> -&gt;&gt;
      <a href=" Z - X = p - m "> Z - X = p - m </a>
    WHILE X &lt;&gt; 0 DO
        <a href=" Z - X = p - m /\ X <> 0 "> Z - X = p - m /\ X <> 0 </a> -&gt;&gt;
        <a href=" (Z - 1) - (X - 1) = p - m "> (Z - 1) - (X - 1) = p - m </a>
      Z ::= Z - 1;;
        <a href=" Z - (X - 1) = p - m "> Z - (X - 1) = p - m </a>
      X ::= X - 1
        <a href=" Z - X = p - m "> Z - X = p - m </a>
    END;
      <a href=" Z - X = p - m /\ ~ (X <> 0) "> Z - X = p - m /\ ~ (X <> 0) </a> -&gt;&gt;
      <a href=" Z = p - m "> Z = p - m </a> 

<div class="paragraph"> </div>

 Concretely, a decorated program consists of the program text
    interleaved with assertions.  To check that a decorated program
    represents a valid proof, we check that each individual command is
    <i>locally consistent</i> with its accompanying assertions in the
    following sense: 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">SKIP</span></span> is locally consistent if its precondition and
      postcondition are the same:
          <a href=" P "> P </a>
          SKIP
          <a href=" P "> P </a>

</li>
</ul>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> The sequential composition of <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> and <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> is locally
      consistent (with respect to assertions <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> and <span class="inlinecode"><a class="idref" href="Norm.html#R"><span class="id" type="definition">R</span></a></span>) if <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> is
      locally consistent (with respect to <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> and <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span>) and <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> is
      locally consistent (with respect to <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> and <span class="inlinecode"><a class="idref" href="Norm.html#R"><span class="id" type="definition">R</span></a></span>):
          <a href=" P "> P </a>
          c1;;
          <a href=" Q "> Q </a>
          c2
          <a href=" R "> R </a>

</li>
</ul>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> An assignment is locally consistent if its precondition is
      the appropriate substitution of its postcondition:
          <a href=" P [X |-> a] "> P [X |-> a] </a>
          X ::= a
          <a href=" P "> P </a>

</li>
</ul>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> A conditional is locally consistent (with respect to assertions
      <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> and <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span>) if the assertions at the top of its "then" and
      "else" branches are exactly <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> and <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode">¬<a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> and if its "then"
      branch is locally consistent (with respect to <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> and <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span>)
      and its "else" branch is locally consistent (with respect to
      <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode">¬<a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> and <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span>):
          <a href=" P "> P </a>
          IFB b THEN
            <a href=" P /\ b "> P /\ b </a>
            c1
            <a href=" Q "> Q </a>
          ELSE
            <a href=" P /\ ~b "> P /\ ~b </a>
            c2
            <a href=" Q "> Q </a>
          FI
          <a href=" Q "> Q </a>

</li>
</ul>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> A while loop with precondition <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> is locally consistent if its
      postcondition is <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode">¬<a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> and if the pre- and postconditions of
      its body are exactly <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> and <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span>:
          <a href=" P "> P </a>
          WHILE b DO
            <a href=" P /\ b "> P /\ b </a>
            c1
            <a href=" P "> P </a>
          END
          <a href=" P /\ ~b "> P /\ ~b </a>

</li>
</ul>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<ul class="doclist">
<li> A pair of assertions separated by <span class="inlinecode">-&gt;&gt;</span> is locally consistent if
      the first implies the second (in all states):
          <a href=" P "> P </a> -&gt;&gt;
          <a href=" P' "> P' </a>

<div class="paragraph"> </div>

      This corresponds to the application of <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_consequence"><span class="id" type="lemma">hoare_consequence</span></a></span> and
      is the only place in a decorated program where checking if
      decorations are correct is not fully mechanical and syntactic,
      but involves logical and/or arithmetic reasoning.

</li>
</ul>

<div class="paragraph"> </div>

 We have seen above how <i>verifying</i> the correctness of a
    given proof involves checking that every single command is locally
    consistent with the accompanying assertions.  If we are instead
    interested in <i>finding</i> a proof for a given specification we need
    to discover the right assertions. This can be done in an almost
    automatic way, with the exception of finding loop invariants,
    which is the subject of in the next section.  In the reminder of
    this section we explain in detail how to construct decorations for
    several simple programs that don't involve non-trivial loop
    invariants. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab572"></a><h2 class="section">Example: Swapping Using Addition and Subtraction</h2>

<div class="paragraph"> </div>

 Here is a program that swaps the values of two variables using
    addition and subtraction (instead of by assigning to a temporary
    variable).
  X ::= X + Y;;
  Y ::= X - Y;;
  X ::= X - Y
    We can prove using decorations that this program is correct --
    i.e., it always swaps the values of variables <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span>. 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

 (1)     <a href=" X = m /\ Y = n "> X = m /\ Y = n </a> -&gt;&gt;
 (2)     <a href=" (X + Y) - ((X + Y) - Y) = n /\ (X + Y) - Y = m "> (X + Y) - ((X + Y) - Y) = n /\ (X + Y) - Y = m </a>
        X ::= X + Y;;
 (3)     <a href=" X - (X - Y) = n /\ X - Y = m "> X - (X - Y) = n /\ X - Y = m </a>
        Y ::= X - Y;;
 (4)     <a href=" X - Y = n /\ Y = m "> X - Y = n /\ Y = m </a>
        X ::= X - Y
 (5)     <a href=" X = n /\ Y = m "> X = n /\ Y = m </a>
    The decorations were constructed as follows:

<div class="paragraph"> </div>

<ul class="doclist">
<li> We begin with the undecorated program (the unnumbered lines).

</li>
<li> We then add the specification -- i.e., the outer
        precondition (1) and postcondition (5). In the precondition we
        use auxiliary variables (parameters) <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> and <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> to remember
        the initial values of variables <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> and respectively <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span>, so
        that we can refer to them in the postcondition (5).

</li>
<li> We work backwards mechanically starting from (5) all the way
        to (2). At each step, we obtain the precondition of the
        assignment from its postcondition by substituting the assigned
        variable with the right-hand-side of the assignment. For
        instance, we obtain (4) by substituting <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> with <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span>
        in (5), and (3) by substituting <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> with <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> in (4).

</li>
<li> Finally, we verify that (1) logically implies (2) -- i.e.,
        that the step from (1) to (2) is a valid use of the law of
        consequence. For this we substitute <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> by <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> by <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span>
        and calculate as follows:
            (m + n) - ((m + n) - n) = n /\ (m + n) - n = m
            (m + n) - m = n /\ m = m
            n = n /\ m = m

</li>
</ul>

<div class="paragraph"> </div>

    (Note that, since we are working with natural numbers, not
    fixed-size machine integers, we don't need to worry about the
    possibility of arithmetic overflow anywhere in this argument.)

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab573"></a><h2 class="section">Example: Simple Conditionals</h2>

<div class="paragraph"> </div>

 Here is a simple decorated program using conditionals:
 (1)     <a href="True">True</a>
       IFB X &lt;= Y THEN
 (2)       <a href="True /\ X <= Y">True /\ X <= Y</a> -&gt;&gt;
 (3)       <a href="(Y - X) + X = Y \/ (Y - X) + Y = X">(Y - X) + X = Y \/ (Y - X) + Y = X</a>
         Z ::= Y - X
 (4)       <a href="Z + X = Y \/ Z + Y = X">Z + X = Y \/ Z + Y = X</a>
       ELSE
 (5)       <a href="True /\ ~(X <= Y) ">True /\ ~(X <= Y) </a> -&gt;&gt;
 (6)       <a href="(X - Y) + X = Y \/ (X - Y) + Y = X">(X - Y) + X = Y \/ (X - Y) + Y = X</a>
         Z ::= X - Y
 (7)       <a href="Z + X = Y \/ Z + Y = X">Z + X = Y \/ Z + Y = X</a>
       FI
 (8)     <a href="Z + X = Y \/ Z + Y = X">Z + X = Y \/ Z + Y = X</a>

<div class="paragraph"> </div>

These decorations were constructed as follows:

<div class="paragraph"> </div>

<ul class="doclist">
<li> We start with the outer precondition (1) and postcondition (8).

</li>
<li> We follow the format dictated by the <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_if"><span class="id" type="lemma">hoare_if</span></a></span> rule and copy the
    postcondition (8) to (4) and (7). We conjoin the precondition (1)
    with the guard of the conditional to obtain (2). We conjoin (1)
    with the negated guard of the conditional to obtain (5).

</li>
<li> In order to use the assignment rule and obtain (3), we substitute
    <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> by <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> in (4). To obtain (6) we substitute <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> by <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span>
    in (7).

</li>
<li> Finally, we verify that (2) implies (3) and (5) implies (6). Both
    of these implications crucially depend on the ordering of <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> and
    <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> obtained from the guard. For instance, knowing that <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span>
    ensures that subtracting <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> from <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> and then adding back <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span>
    produces <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span>, as required by the first disjunct of (3). Similarly,
    knowing that <span class="inlinecode">~(<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>)</span> ensures that subtracting <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> from <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> and
    then adding back <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> produces <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span>, as needed by the second
    disjunct of (6). Note that <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> does <i>not</i> hold for
    arbitrary natural numbers <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> and <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> (for example, <span class="inlinecode">3</span> <span class="inlinecode">-</span> <span class="inlinecode">5</span> <span class="inlinecode">+</span> <span class="inlinecode">5</span> <span class="inlinecode">=</span>
    <span class="inlinecode">5</span>). 
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab574"></a><h4 class="section">Exercise: 2 stars (if_minus_plus_reloaded)</h4>
 Fill in valid decorations for the following program:
   <a href=" True "> True </a>
  IFB X &lt;= Y THEN
      <a href="                         ">                         </a> -&gt;&gt;
      <a href="                         ">                         </a>
    Z ::= Y - X
      <a href="                         ">                         </a>
  ELSE
      <a href="                         ">                         </a> -&gt;&gt;
      <a href="                         ">                         </a>
    Y ::= X + Z
      <a href="                         ">                         </a>
  FI
    <a href=" Y = X + Z "> Y = X + Z </a>

<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab575"></a><h2 class="section">Example: Reduce to Zero (Trivial Loop)</h2>

<div class="paragraph"> </div>

 Here is a <span class="inlinecode"><span class="id" type="var">WHILE</span></span> loop that is so simple it needs no
    invariant (i.e., the invariant <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a></span> will do the job).
 (1)      <a href=" True "> True </a>
        WHILE X &lt;&gt; 0 DO
 (2)        <a href=" True /\ X <> 0 "> True /\ X <> 0 </a> -&gt;&gt;
 (3)        <a href=" True "> True </a>
          X ::= X - 1
 (4)        <a href=" True "> True </a>
        END
 (5)      <a href=" True /\ X = 0 "> True /\ X = 0 </a> -&gt;&gt;
 (6)      <a href=" X = 0 "> X = 0 </a>
The decorations can be constructed as follows:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Start with the outer precondition (1) and postcondition (6).

</li>
<li> Following the format dictated by the <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_while"><span class="id" type="lemma">hoare_while</span></a></span> rule, we copy
    (1) to (4). We conjoin (1) with the guard to obtain (2) and with
    the negation of the guard to obtain (5). Note that, because the
    outer postcondition (6) does not syntactically match (5), we need a
    trivial use of the consequence rule from (5) to (6).

</li>
<li> Assertion (3) is the same as (4), because <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> does not appear in
    <span class="inlinecode">4</span>, so the substitution in the assignment rule is trivial.

</li>
<li> Finally, the implication between (2) and (3) is also trivial.

</li>
</ul>

<div class="paragraph"> </div>

 From this informal proof, it is easy to read off a formal proof
    using the Coq versions of the Hoare rules.  Note that we do <i>not</i>
    unfold the definition of <span class="inlinecode"><a class="idref" href="Hoare.html#Himp.hoare_triple"><span class="id" type="definition">hoare_triple</span></a></span> anywhere in this proof --
    the idea is to use the Hoare rules as a "self-contained" logic for
    reasoning about programs. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="reduce_to_zero'"><span class="id" type="definition">reduce_to_zero'</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0)) <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="reduce_to_zero_correct'"><span class="id" type="lemma">reduce_to_zero_correct'</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#reduce_to_zero'"><span class="id" type="definition">reduce_to_zero'</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 0<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare2.html#reduce_to_zero'"><span class="id" type="definition">reduce_to_zero'</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_post"><span class="id" type="lemma">hoare_consequence_post</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_while"><span class="id" type="lemma">hoare_while</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "Loop body preserves invariant".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> [<span class="id" type="var">HT</span> <span class="id" type="var">Hbp</span>]. <span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#assn_sub"><span class="id" type="definition">assn_sub</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#I"><span class="id" type="constructor">I</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "Invariant and negated guard imply postcondition".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> [<span class="id" type="var">Inv</span> <span class="id" type="var">GuardFalse</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">GuardFalse</span>. <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">GuardFalse</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">SearchAbout</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Bool.Bool.html#not_true_iff_false"><span class="id" type="lemma">not_true_iff_false</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">GuardFalse</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">SearchAbout</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#negb"><span class="id" type="definition">negb</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Bool.Bool.html#negb_false_iff"><span class="id" type="lemma">negb_false_iff</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">GuardFalse</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">SearchAbout</span> [<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.EqNat.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.EqNat.html#beq_nat_true"><span class="id" type="lemma">beq_nat_true</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">GuardFalse</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">GuardFalse</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab576"></a><h2 class="section">Example: Division</h2>

<div class="paragraph"> </div>

 The following Imp program calculates the integer division and
    remainder of two numbers <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> and <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> that are arbitrary constants
    in the program.
  X ::= m;;
  Y ::= 0;;
  WHILE n &lt;= X DO
    X ::= X - n;;
    Y ::= Y + 1
  END;
    In other words, if we replace <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> and <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> by concrete numbers and
    execute the program, it will terminate with the variable <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> set
    to the remainder when <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> is divided by <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> set to the
    quotient. 
<div class="paragraph"> </div>

 In order to give a specification to this program we need to
    remember that dividing <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> by <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> produces a reminder <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> and a
    quotient <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> so that <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">×</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span>.

<div class="paragraph"> </div>

    It turns out that we get lucky with this program and don't have to
    think very hard about the loop invariant: the invariant is the
    just first conjunct <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">×</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>, so we use that to decorate
    the program.

<div class="paragraph"> </div>

 (1)    <a href=" True "> True </a> -&gt;&gt;
 (2)    <a href=" n * 0 + m = m "> n * 0 + m = m </a>
      X ::= m;;
 (3)    <a href=" n * 0 + X = m "> n * 0 + X = m </a>
      Y ::= 0;;
 (4)    <a href=" n * Y + X = m "> n * Y + X = m </a>
      WHILE n &lt;= X DO
 (5)      <a href=" n * Y + X = m /\ n <= X "> n * Y + X = m /\ n <= X </a> -&gt;&gt;
 (6)      <a href=" n * (Y + 1) + (X - n) = m "> n * (Y + 1) + (X - n) = m </a>
        X ::= X - n;;
 (7)      <a href=" n * (Y + 1) + X = m "> n * (Y + 1) + X = m </a>
        Y ::= Y + 1
 (8)      <a href=" n * Y + X = m "> n * Y + X = m </a>
      END
 (9)    <a href=" n * Y + X = m /\ X < n "> n * Y + X = m /\ X < n </a>

<div class="paragraph"> </div>

    Assertions (4), (5), (8), and (9) are derived mechanically from
    the invariant and the loop's guard. Assertions (8), (7), and (6)
    are derived using the assignment rule going backwards from (8) to
    (6). Assertions (4), (3), and (2) are again backwards applications
    of the assignment rule.

<div class="paragraph"> </div>

    Now that we've decorated the program it only remains to check that
    the two uses of the consequence rule are correct -- i.e., that (1)
    implies (2) and that (5) implies (6).  This is indeed the case, so
    we have a valid decorated program.

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab577"></a><h1 class="section">Finding Loop Invariants</h1>

<div class="paragraph"> </div>

 Once the outermost precondition and postcondition are chosen, the
    only creative part in verifying programs with Hoare Logic is
    finding the right loop invariants.  The reason this is difficult
    is the same as the reason that doing inductive mathematical proofs
    requires creativity: strengthening the loop invariant (or the
    induction hypothesis) means that you have a stronger assumption to
    work with when trying to establish the postcondition of the loop
    body (complete the induction step of the proof), but it also means
    that the loop body postcondition itself is harder to prove!

<div class="paragraph"> </div>

    This section is dedicated to teaching you how to approach the
    challenge of finding loop invariants using a series of examples
    and exercises. 
<div class="paragraph"> </div>

<a name="lab578"></a><h2 class="section">Example: Slow Subtraction</h2>

<div class="paragraph"> </div>

 The following program subtracts the value of <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> from the value of
    <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> by repeatedly decrementing both <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span>. We want to verify its
    correctness with respect to the following specification:
             <a href=" X = m /\ Y = n "> X = m /\ Y = n </a>
           WHILE X &lt;&gt; 0 DO
             Y ::= Y - 1;;
             X ::= X - 1
           END
             <a href=" Y = n - m "> Y = n - m </a>

<div class="paragraph"> </div>

    To verify this program we need to find an invariant <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#I"><span class="id" type="constructor">I</span></a></span> for the
    loop. As a first step we can leave <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#I"><span class="id" type="constructor">I</span></a></span> as an unknown and build a
    <i>skeleton</i> for the proof by applying backward the rules for local
    consistency. This process leads to the following skeleton:
    (1)      <a href=" X = m /\ Y = n "> X = m /\ Y = n </a>  -&gt;&gt;     (a)
    (2)      <a href=" I "> I </a>
           WHILE X &lt;&gt; 0 DO
    (3)        <a href=" I /\ X <> 0 "> I /\ X <> 0 </a>  -&gt;&gt;      (c)
    (4)        <a href=" I[X |-> X-1][Y |-> Y-1] "> I[X |-> X-1][Y |-> Y-1] </a>
             Y ::= Y - 1;;
    (5)        <a href=" I[X |-> X-1] "> I[X |-> X-1] </a>
             X ::= X - 1
    (6)        <a href=" I "> I </a>
           END
    (7)      <a href=" I /\ ~(X <> 0) "> I /\ ~(X <> 0) </a>  -&gt;&gt;         (b)
    (8)      <a href=" Y = n - m "> Y = n - m </a>

<div class="paragraph"> </div>

    By examining this skeleton, we can see that any valid <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#I"><span class="id" type="constructor">I</span></a></span> will
    have to respect three conditions:

<div class="paragraph"> </div>

<ul class="doclist">
<li> (a) it must be weak enough to be implied by the loop's
      precondition, i.e. (1) must imply (2);

</li>
<li> (b) it must be strong enough to imply the loop's postcondition,
      i.e. (7) must imply (8);

</li>
<li> (c) it must be preserved by one iteration of the loop, i.e. (3)
      must imply (4). 
</li>
</ul>

<div class="paragraph"> </div>

 These conditions are actually independent of the particular
    program and specification we are considering. Indeed, every loop
    invariant has to satisfy them. One way to find an invariant that
    simultaneously satisfies these three conditions is by using an
    iterative process: start with a "candidate" invariant (e.g. a
    guess or a heuristic choice) and check the three conditions above;
    if any of the checks fails, try to use the information that we get
    from the failure to produce another (hopefully better) candidate
    invariant, and repeat the process.

<div class="paragraph"> </div>

    For instance, in the reduce-to-zero example above, we saw that,
    for a very simple loop, choosing <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a></span> as an invariant did the
    job. So let's try it again here!  I.e., let's instantiate <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#I"><span class="id" type="constructor">I</span></a></span> with
    <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a></span> in the skeleton above see what we get...
    (1)      <a href=" X = m /\ Y = n "> X = m /\ Y = n </a> -&gt;&gt;       (a - OK)
    (2)      <a href=" True "> True </a>
           WHILE X &lt;&gt; 0 DO
    (3)        <a href=" True /\ X <> 0 "> True /\ X <> 0 </a>  -&gt;&gt;    (c - OK)
    (4)        <a href=" True "> True </a>
             Y ::= Y - 1;;
    (5)        <a href=" True "> True </a>
             X ::= X - 1
    (6)        <a href=" True "> True </a>
           END
    (7)      <a href=" True /\ X = 0 "> True /\ X = 0 </a>  -&gt;&gt;       (b - WRONG!)
    (8)      <a href=" Y = n - m "> Y = n - m </a>

<div class="paragraph"> </div>

    While conditions (a) and (c) are trivially satisfied,
    condition (b) is wrong, i.e. it is not the case that (7) <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a></span> <span class="inlinecode">∧</span>
    <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> implies (8) <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>.  In fact, the two assertions are
    completely unrelated and it is easy to find a counterexample (say,
    <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> and <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">1</span>).

<div class="paragraph"> </div>

    If we want (b) to hold, we need to strengthen the invariant so
    that it implies the postcondition (8).  One very simple way to do
    this is to let the invariant <i>be</i> the postcondition.  So let's
    return to our skeleton, instantiate <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#I"><span class="id" type="constructor">I</span></a></span> with <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>, and
    check conditions (a) to (c) again.
    (1)      <a href=" X = m /\ Y = n "> X = m /\ Y = n </a>  -&gt;&gt;          (a - WRONG!)
    (2)      <a href=" Y = n - m "> Y = n - m </a>
           WHILE X &lt;&gt; 0 DO
    (3)        <a href=" Y = n - m /\ X <> 0 "> Y = n - m /\ X <> 0 </a>  -&gt;&gt;   (c - WRONG!)
    (4)        <a href=" Y - 1 = n - m "> Y - 1 = n - m </a>
             Y ::= Y - 1;;
    (5)        <a href=" Y = n - m "> Y = n - m </a>
             X ::= X - 1
    (6)        <a href=" Y = n - m "> Y = n - m </a>
           END
    (7)      <a href=" Y = n - m /\ X = 0 "> Y = n - m /\ X = 0 </a>  -&gt;&gt;      (b - OK)
    (8)      <a href=" Y = n - m "> Y = n - m </a>

<div class="paragraph"> </div>

    This time, condition (b) holds trivially, but (a) and (c) are
    broken. Condition (a) requires that (1) <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span>
    implies (2) <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>.  If we substitute <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> by <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> we have to
    show that <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> for arbitrary <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> and <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span>, which does not
    hold (for instance, when <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">1</span>).  Condition (c) requires that
    <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode">1</span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>, which fails, for instance, for <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">1</span> and <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> <span class="inlinecode">=</span>
    <span class="inlinecode">0</span>. So, although <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> holds at the end of the loop, it does
    not hold from the start, and it doesn't hold on each iteration;
    it is not a correct invariant.

<div class="paragraph"> </div>

    This failure is not very surprising: the variable <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> changes
    during the loop, while <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> and <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> are constant, so the assertion
    we chose didn't have much chance of being an invariant!  

<div class="paragraph"> </div>

    To do better, we need to generalize (8) to some statement that is
    equivalent to (8) when <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> is <span class="inlinecode">0</span>, since this will be the case
    when the loop terminates, and that "fills the gap" in some
    appropriate way when <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> is nonzero.  Looking at how the loop
    works, we can observe that <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> are decremented together
    until <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> reaches <span class="inlinecode">0</span>.  So, if <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">2</span> and <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">5</span> initially,
    after one iteration of the loop we obtain <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">1</span> and <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">4</span>;
    after two iterations <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> and <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">3</span>; and then the loop stops.
    Notice that the difference between <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> stays constant
    between iterations; initially, <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>, so this
    difference is always <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>.  So let's try instantiating <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#I"><span class="id" type="constructor">I</span></a></span> in
    the skeleton above with <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>.
    (1)      <a href=" X = m /\ Y = n "> X = m /\ Y = n </a>  -&gt;&gt;               (a - OK)
    (2)      <a href=" Y - X = n - m "> Y - X = n - m </a>
           WHILE X &lt;&gt; 0 DO
    (3)        <a href=" Y - X = n - m /\ X <> 0 "> Y - X = n - m /\ X <> 0 </a>  -&gt;&gt;    (c - OK)
    (4)        <a href=" (Y - 1) - (X - 1) = n - m "> (Y - 1) - (X - 1) = n - m </a>
             Y ::= Y - 1;;
    (5)        <a href=" Y - (X - 1) = n - m "> Y - (X - 1) = n - m </a>
             X ::= X - 1
    (6)        <a href=" Y - X = n - m "> Y - X = n - m </a>
           END
    (7)      <a href=" Y - X = n - m /\ X = 0 "> Y - X = n - m /\ X = 0 </a>  -&gt;&gt;       (b - OK)
    (8)      <a href=" Y = n - m "> Y = n - m </a>

<div class="paragraph"> </div>

    Success!  Conditions (a), (b) and (c) all hold now.  (To
    verify (c), we need to check that, under the assumption that <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">≠</span>
    <span class="inlinecode">0</span>, we have <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">(<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode">1)</span> <span class="inlinecode">-</span> <span class="inlinecode">(<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode">1)</span>; this holds for all
    natural numbers <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span>.) 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab579"></a><h2 class="section">Exercise: Slow Assignment</h2>

<div class="paragraph"> </div>

<a name="lab580"></a><h4 class="section">Exercise: 2 stars (slow_assignment)</h4>
 A roundabout way of assigning a number currently stored in <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> to
    the variable <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> is to start <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> at <span class="inlinecode">0</span>, then decrement <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> until
    it hits <span class="inlinecode">0</span>, incrementing <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> at each step. Here is a program that
    implements this idea:
      <a href=" X = m "> X = m </a>
    Y ::= 0;;
    WHILE X &lt;&gt; 0 DO
      X ::= X - 1;;
      Y ::= Y + 1
    END
      <a href=" Y = m "> Y = m </a>
    Write an informal decorated program showing that this is correct. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab581"></a><h2 class="section">Exercise: Slow Addition</h2>

<div class="paragraph"> </div>

<a name="lab582"></a><h4 class="section">Exercise: 3 stars, optional (add_slowly_decoration)</h4>
 The following program adds the variable X into the variable Z
    by repeatedly decrementing X and incrementing Z.
  WHILE X &lt;&gt; 0 DO
     Z ::= Z + 1;;
     X ::= X - 1
  END

<div class="paragraph"> </div>

    Following the pattern of the <span class="inlinecode"><a class="idref" href="Imp.html#subtract_slowly"><span class="id" type="definition">subtract_slowly</span></a></span> example above, pick
    a precondition and postcondition that give an appropriate
    specification of <span class="inlinecode"><span class="id" type="var">add_slowly</span></span>; then (informally) decorate the
    program accordingly. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab583"></a><h2 class="section">Example: Parity</h2>

<div class="paragraph"> </div>

 Here is a cute little program for computing the parity of the
    value initially stored in <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> (due to Daniel Cristofani).
    <a href=" X = m "> X = m </a>
  WHILE 2 &lt;= X DO
    X ::= X - 2
  END
    <a href=" X = parity m "> X = parity m </a>
    The mathematical <span class="inlinecode"><a class="idref" href="PE.html#parity"><span class="id" type="definition">parity</span></a></span> function used in the specification is
    defined in Coq as follows: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="parity"><span class="id" type="definition">parity</span></a> <span class="id" type="var">x</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Hoare2.html#x"><span class="id" type="variable">x</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| 0 ⇒ 0<br/>
&nbsp;&nbsp;| 1 ⇒ 1<br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">x'</span>) ⇒ <a class="idref" href="Hoare2.html#parity"><span class="id" type="definition">parity</span></a> <span class="id" type="var">x'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The postcondition does not hold at the beginning of the loop,
    since <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="PE.html#parity"><span class="id" type="definition">parity</span></a></span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> does not hold for an arbitrary <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>, so we
    cannot use that as an invariant.  To find an invariant that works,
    let's think a bit about what this loop does.  On each iteration it
    decrements <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> by <span class="inlinecode">2</span>, which preserves the parity of <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span>.  So the
    parity of <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> does not change, i.e. it is invariant.  The initial
    value of <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> is <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>, so the parity of <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> is always equal to the
    parity of <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>. Using <span class="inlinecode"><a class="idref" href="PE.html#parity"><span class="id" type="definition">parity</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="PE.html#parity"><span class="id" type="definition">parity</span></a></span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> as an invariant we
    obtain the following decorated program:
    <a href=" X = m "> X = m </a> -&gt;&gt;                              (a - OK)
    <a href=" parity X = parity m "> parity X = parity m </a>
  WHILE 2 &lt;= X DO
      <a href=" parity X = parity m /\ 2 <= X "> parity X = parity m /\ 2 <= X </a>  -&gt;&gt;    (c - OK)
      <a href=" parity (X-2) = parity m "> parity (X-2) = parity m </a>
    X ::= X - 2
      <a href=" parity X = parity m "> parity X = parity m </a>
  END
    <a href=" parity X = parity m /\ X < 2 "> parity X = parity m /\ X < 2 </a>  -&gt;&gt;       (b - OK)
    <a href=" X = parity m "> X = parity m </a>

<div class="paragraph"> </div>

    With this invariant, conditions (a), (b), and (c) are all
    satisfied. For verifying (b), we observe that, when <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">&lt;</span> <span class="inlinecode">2</span>, we
    have <span class="inlinecode"><a class="idref" href="PE.html#parity"><span class="id" type="definition">parity</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> (we can easily see this in the definition of
    <span class="inlinecode"><a class="idref" href="PE.html#parity"><span class="id" type="definition">parity</span></a></span>).  For verifying (c), we observe that, when <span class="inlinecode">2</span> <span class="inlinecode">≤</span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span>, we
    have <span class="inlinecode"><a class="idref" href="PE.html#parity"><span class="id" type="definition">parity</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="PE.html#parity"><span class="id" type="definition">parity</span></a></span> <span class="inlinecode">(<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>-2)</span>. 
<div class="paragraph"> </div>

<a name="lab584"></a><h4 class="section">Exercise: 3 stars, optional (parity_formal)</h4>
 Translate this proof to Coq. Refer to the reduce-to-zero example
    for ideas. You may find the following two lemmas useful: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="parity_ge_2"><span class="id" type="lemma">parity_ge_2</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>,<br/>
&nbsp;&nbsp;2 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="Hoare2.html#x"><span class="id" type="variable">x</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#parity"><span class="id" type="definition">parity</span></a> (<a class="idref" href="Hoare2.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 2) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare2.html#parity"><span class="id" type="definition">parity</span></a> <a class="idref" href="Hoare2.html#x"><span class="id" type="variable">x</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">intro</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">x</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H1</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> &lt;- <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.Minus.html#minus_n_O"><span class="id" type="lemma">minus_n_O</span></a>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="parity_lt_2"><span class="id" type="lemma">parity_lt_2</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">x</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="Hoare2.html#x"><span class="id" type="variable">x</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#parity"><span class="id" type="definition">parity</span></a> (<a class="idref" href="Hoare2.html#x"><span class="id" type="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare2.html#x"><span class="id" type="variable">x</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">x</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">x</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="SfLib.html#ex_falso_quodlibet"><span class="id" type="lemma">ex_falso_quodlibet</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">omega</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="parity_correct"><span class="id" type="lemma">parity_correct</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BLe"><span class="id" type="constructor">BLe</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 2) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 2)<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare2.html#parity"><span class="id" type="definition">parity</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab585"></a><h2 class="section">Example: Finding Square Roots</h2>

<div class="paragraph"> </div>

 The following program computes the square root of <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span>
    by naive iteration:
      <a href=" X=m "> X=m </a>
    Z ::= 0;;
    WHILE (Z+1)*(Z+1) &lt;= X DO
      Z ::= Z+1
    END
      <a href=" Z*Z<=m /\ m<(Z+1)*(Z+1) "> Z*Z<=m /\ m<(Z+1)*(Z+1) </a>

<div class="paragraph"> </div>

 As above, we can try to use the postcondition as a candidate
    invariant, obtaining the following decorated program:
 (1)  <a href=" X=m "> X=m </a>  -&gt;&gt;           (a - second conjunct of (2) WRONG!)
 (2)  <a href=" 0*0 <= m /\ m<1*1 "> 0*0 <= m /\ m<1*1 </a>
    Z ::= 0;;
 (3)  <a href=" Z*Z <= m /\ m<(Z+1)*(Z+1) "> Z*Z <= m /\ m<(Z+1)*(Z+1) </a>
    WHILE (Z+1)*(Z+1) &lt;= X DO
 (4)    <a href=" Z*Z<=m /\ (Z+1)*(Z+1)<=X "> Z*Z<=m /\ (Z+1)*(Z+1)<=X </a>  -&gt;&gt;           (c - WRONG!)
 (5)    <a href=" (Z+1)*(Z+1)<=m /\ m<(Z+2)*(Z+2) "> (Z+1)*(Z+1)<=m /\ m<(Z+2)*(Z+2) </a>
      Z ::= Z+1
 (6)    <a href=" Z*Z<=m /\ m<(Z+1)*(Z+1) "> Z*Z<=m /\ m<(Z+1)*(Z+1) </a>
    END
 (7)  <a href=" Z*Z<=m /\ m<(Z+1)*(Z+1) /\ X<(Z+1)*(Z+1) "> Z*Z<=m /\ m<(Z+1)*(Z+1) /\ X<(Z+1)*(Z+1) </a>  -&gt;&gt; (b - OK)
 (8)  <a href=" Z*Z<=m /\ m<(Z+1)*(Z+1) "> Z*Z<=m /\ m<(Z+1)*(Z+1) </a>

<div class="paragraph"> </div>

    This didn't work very well: both conditions (a) and (c) failed.
    Looking at condition (c), we see that the second conjunct of (4)
    is almost the same as the first conjunct of (5), except that (4)
    mentions <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> while (5) mentions <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>. But note that <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> is never
    assigned in this program, so we should have <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>=<a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>, but we didn't
    propagate this information from (1) into the loop invariant.

<div class="paragraph"> </div>

    Also, looking at the second conjunct of (8), it seems quite
    hopeless as an invariant -- and we don't even need it, since we
    can obtain it from the negation of the guard (third conjunct
    in (7)), again under the assumption that <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>=<a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>.  

<div class="paragraph"> </div>

    So we now try <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>=<a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a>×<a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> as the loop invariant:
      <a href=" X=m "> X=m </a>  -&gt;&gt;                                      (a - OK)
      <a href=" X=m /\ 0*0 <= m "> X=m /\ 0*0 <= m </a>
    Z ::= 0;
      <a href=" X=m /\ Z*Z <= m "> X=m /\ Z*Z <= m </a>
    WHILE (Z+1)*(Z+1) &lt;= X DO
        <a href=" X=m /\ Z*Z<=m /\ (Z+1)*(Z+1)<=X "> X=m /\ Z*Z<=m /\ (Z+1)*(Z+1)<=X </a>  -&gt;&gt;        (c - OK)
        <a href=" X=m /\ (Z+1)*(Z+1)<=m "> X=m /\ (Z+1)*(Z+1)<=m </a>
      Z ::= Z+1
        <a href=" X=m /\ Z*Z<=m "> X=m /\ Z*Z<=m </a>
    END
      <a href=" X=m /\ Z*Z<=m /\ X<(Z+1)*(Z+1) "> X=m /\ Z*Z<=m /\ X<(Z+1)*(Z+1) </a>  -&gt;&gt;           (b - OK)
      <a href=" Z*Z<=m /\ m<(Z+1)*(Z+1) "> Z*Z<=m /\ m<(Z+1)*(Z+1) </a>

<div class="paragraph"> </div>

    This works, since conditions (a), (b), and (c) are now all
    trivially satisfied.

<div class="paragraph"> </div>

    Very often, if a variable is used in a loop in a read-only
    fashion (i.e., it is referred to by the program or by the
    specification and it is not changed by the loop) it is necessary
    to add the fact that it doesn't change to the loop invariant. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab586"></a><h2 class="section">Example: Squaring</h2>

<div class="paragraph"> </div>

 Here is a program that squares <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> by repeated addition:

<div class="paragraph"> </div>

    <a href=" X = m "> X = m </a>
  Y ::= 0;;
  Z ::= 0;;
  WHILE  Y  &lt;&gt;  X  DO
    Z ::= Z + X;;
    Y ::= Y + 1
  END
    <a href=" Z = m*m "> Z = m*m </a>

<div class="paragraph"> </div>

 The first thing to note is that the loop reads <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> but doesn't
    change its value. As we saw in the previous example, in such cases
    it is a good idea to add <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> to the invariant. The other thing
    we often use in the invariant is the postcondition, so let's add
    that too, leading to the invariant candidate <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> <span class="inlinecode">×</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>.
      <a href=" X = m "> X = m </a> -&gt;&gt;                            (a - WRONG)
      <a href=" 0 = m*m /\ X = m "> 0 = m*m /\ X = m </a>
    Y ::= 0;;
      <a href=" 0 = m*m /\ X = m "> 0 = m*m /\ X = m </a>
    Z ::= 0;;
      <a href=" Z = m*m /\ X = m "> Z = m*m /\ X = m </a>
    WHILE Y &lt;&gt; X DO
        <a href=" Z = Y*m /\ X = m /\ Y <> X "> Z = Y*m /\ X = m /\ Y <> X </a> -&gt;&gt;     (c - WRONG)
        <a href=" Z+X = m*m /\ X = m "> Z+X = m*m /\ X = m </a>
      Z ::= Z + X;;
        <a href=" Z = m*m /\ X = m "> Z = m*m /\ X = m </a>
      Y ::= Y + 1
        <a href=" Z = m*m /\ X = m "> Z = m*m /\ X = m </a>
    END
      <a href=" Z = m*m /\ X = m /\ Y = X "> Z = m*m /\ X = m /\ Y = X </a> -&gt;&gt;         (b - OK)
      <a href=" Z = m*m "> Z = m*m </a>

<div class="paragraph"> </div>

    Conditions (a) and (c) fail because of the <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a>×<a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> part.  While
    <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> starts at <span class="inlinecode">0</span> and works itself up to <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a>×<a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>, we can't expect
    <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> to be <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a>×<a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> from the start.  If we look at how <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> progesses
    in the loop, after the 1st iteration <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>, after the 2nd
    iteration <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">2*<a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>, and at the end <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a>×<a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>.  Since the variable
    <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> tracks how many times we go through the loop, we derive the
    new invariant candidate <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>×<a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>.
      <a href=" X = m "> X = m </a> -&gt;&gt;                               (a - OK)
      <a href=" 0 = 0*m /\ X = m "> 0 = 0*m /\ X = m </a>
    Y ::= 0;;
      <a href=" 0 = Y*m /\ X = m "> 0 = Y*m /\ X = m </a>
    Z ::= 0;;
      <a href=" Z = Y*m /\ X = m "> Z = Y*m /\ X = m </a>
    WHILE Y &lt;&gt; X DO
        <a href=" Z = Y*m /\ X = m /\ Y <> X "> Z = Y*m /\ X = m /\ Y <> X </a> -&gt;&gt;        (c - OK)
        <a href=" Z+X = (Y+1)*m /\ X = m "> Z+X = (Y+1)*m /\ X = m </a>
      Z ::= Z + X;
        <a href=" Z = (Y+1)*m /\ X = m "> Z = (Y+1)*m /\ X = m </a>
      Y ::= Y + 1
        <a href=" Z = Y*m /\ X = m "> Z = Y*m /\ X = m </a>
    END
      <a href=" Z = Y*m /\ X = m /\ Y = X "> Z = Y*m /\ X = m /\ Y = X </a> -&gt;&gt;           (b - OK)
      <a href=" Z = m*m "> Z = m*m </a>

<div class="paragraph"> </div>

    This new invariant makes the proof go through: all three
    conditions are easy to check.

<div class="paragraph"> </div>

    It is worth comparing the postcondition <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a>×<a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> and the <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> <span class="inlinecode">=</span>
    <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>×<a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> conjunct of the invariant. It is often the case that one has
    to replace auxiliary variabes (parameters) with variables -- or
    with expressions involving both variables and parameters (like
    <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span>) -- when going from postconditions to invariants. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab587"></a><h2 class="section">Exercise: Factorial</h2>

<div class="paragraph"> </div>

<a name="lab588"></a><h4 class="section">Exercise: 3 stars (factorial)</h4>
 Recall that <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a>!</span> denotes the factorial of <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> (i.e. <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a>!</span> <span class="inlinecode">=</span>
    <span class="inlinecode">1*2*...*<a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span>).  Here is an Imp program that calculates the factorial
    of the number initially stored in the variable <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> and puts it in
    the variable <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span>:
    <a href=" X = m "> X = m </a> 
  Y ::= 1 ;;
  WHILE X &lt;&gt; 0
  DO
     Y ::= Y * X ;;
     X ::= X - 1
  END
    <a href=" Y = m! "> Y = m! </a>

<div class="paragraph"> </div>

    Fill in the blanks in following decorated program:
    <a href=" X = m "> X = m </a> -&gt;&gt;
    <a href="                                      ">                                      </a>
  Y ::= 1;;
    <a href="                                      ">                                      </a>
  WHILE X &lt;&gt; 0
  DO   <a href="                                      ">                                      </a> -&gt;&gt;
       <a href="                                      ">                                      </a>
     Y ::= Y * X;;
       <a href="                                      ">                                      </a>
     X ::= X - 1
       <a href="                                      ">                                      </a>
  END
    <a href="                                      ">                                      </a> -&gt;&gt;
    <a href=" Y = m! "> Y = m! </a>

<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab589"></a><h2 class="section">Exercise: Min</h2>

<div class="paragraph"> </div>

<a name="lab590"></a><h4 class="section">Exercise: 3 stars (Min_Hoare)</h4>
 Fill in valid decorations for the following program.
  For the =&gt; steps in your annotations, you may rely (silently) on the
  following facts about min

<div class="paragraph"> </div>

  Lemma lemma1 : forall x y,
  (x=0 \/ y=0) -&gt; min x y = 0.
  Lemma lemma2 : forall x y,
  min (x-1) (y-1) = (min x y) - 1.

<div class="paragraph"> </div>

  plus, as usual, standard high-school algebra.

<div class="paragraph"> </div>

  <a href=" True "> True </a> -&gt;&gt;
  <a href="                    ">                    </a>
  X ::= a;;
  <a href="                       ">                       </a>
  Y ::= b;;
  <a href="                       ">                       </a>
  Z ::= 0;;
  <a href="                       ">                       </a>
  WHILE (X &lt;&gt; 0 /\ Y &lt;&gt; 0) DO
  <a href="                                     ">                                     </a> -&gt;&gt;
  <a href="                                ">                                </a>
  X := X - 1;;
  <a href="                            ">                            </a>
  Y := Y - 1;;
  <a href="                        ">                        </a>
  Z := Z + 1
  <a href="                       ">                       </a>
  END
  <a href="                            ">                            </a> -&gt;&gt;
  <a href=" Z = min a b "> Z = min a b </a>

<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab591"></a><h4 class="section">Exercise: 3 stars (two_loops)</h4>
 Here is a very inefficient way of adding 3 numbers:
  X ::= 0;;
  Y ::= 0;;
  Z ::= c;;
  WHILE X &lt;&gt; a DO
    X ::= X + 1;;
    Z ::= Z + 1
  END;;
  WHILE Y &lt;&gt; b DO
    Y ::= Y + 1;;
    Z ::= Z + 1
  END

<div class="paragraph"> </div>

    Show that it does what it should by filling in the blanks in the
    following decorated program.

<div class="paragraph"> </div>

    <a href=" True "> True </a> -&gt;&gt;
    <a href="                                        ">                                        </a>
  X ::= 0;;
    <a href="                                        ">                                        </a>
  Y ::= 0;;
    <a href="                                        ">                                        </a>
  Z ::= c;;
    <a href="                                        ">                                        </a>
  WHILE X &lt;&gt; a DO
      <a href="                                        ">                                        </a> -&gt;&gt;
      <a href="                                        ">                                        </a>
    X ::= X + 1;;
      <a href="                                        ">                                        </a>
    Z ::= Z + 1
      <a href="                                        ">                                        </a>
  END;;
    <a href="                                        ">                                        </a> -&gt;&gt;
    <a href="                                        ">                                        </a>
  WHILE Y &lt;&gt; b DO
      <a href="                                        ">                                        </a> -&gt;&gt;
      <a href="                                        ">                                        </a>
    Y ::= Y + 1;;
      <a href="                                        ">                                        </a>
    Z ::= Z + 1
      <a href="                                        ">                                        </a>
  END
    <a href="                                        ">                                        </a> -&gt;&gt;
    <a href=" Z = a + b + c "> Z = a + b + c </a>

<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab592"></a><h2 class="section">Exercise: Power Series</h2>

<div class="paragraph"> </div>

<a name="lab593"></a><h4 class="section">Exercise: 4 stars, optional (dpow2_down)</h4>
 Here is a program that computes the series:
    <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2^2</span> <span class="inlinecode">+</span> <span class="inlinecode">...</span> <span class="inlinecode">+</span> <span class="inlinecode">2^<a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">2^(<a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a>+1)</span> <span class="inlinecode">-</span> <span class="inlinecode">1</span>
  X ::= 0;;
  Y ::= 1;;
  Z ::= 1;;
  WHILE X &lt;&gt; m DO
    Z ::= 2 * Z;;
    Y ::= Y + Z;;
    X ::= X + 1
  END
    Write a decorated program for this. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab594"></a><h1 class="section">Weakest Preconditions (Advanced)</h1>

<div class="paragraph"> </div>

 Some Hoare triples are more interesting than others.
    For example,
      <a href=" False "> False </a>  X ::= Y + 1  <a href=" X <= 5 "> X <= 5 </a>
    is <i>not</i> very interesting: although it is perfectly valid, it
    tells us nothing useful.  Since the precondition isn't satisfied
    by any state, it doesn't describe any situations where we can use
    the command <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">::=</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> to achieve the postcondition <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode">5</span>.

<div class="paragraph"> </div>

    By contrast,
      <a href=" Y <= 4 /\ Z = 0 "> Y <= 4 /\ Z = 0 </a>  X ::= Y + 1 <a href=" X <= 5 "> X <= 5 </a>
    is useful: it tells us that, if we can somehow create a situation
    in which we know that <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode">4</span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>, then running this command
    will produce a state satisfying the postcondition.  However, this
    triple is still not as useful as it could be, because the <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>
    clause in the precondition actually has nothing to do with the
    postcondition <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode">5</span>.  The <i>most</i> useful triple (for a given
    command and postcondition) is this one:
      <a href=" Y <= 4 "> Y <= 4 </a>  X ::= Y + 1  <a href=" X <= 5 "> X <= 5 </a>
    In other words, <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode">4</span> is the <i>weakest</i> valid precondition of
    the command <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">::=</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> for the postcondition <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode">5</span>. 
<div class="paragraph"> </div>

 In general, we say that "<span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> is the weakest precondition of
    command <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> for postcondition <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span>" if <span class="inlinecode">{{<a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a>}}</span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode">{{<a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>}}</span> and if,
    whenever <span class="inlinecode"><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a></span> is an assertion such that <span class="inlinecode">{{<a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a>}}</span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode">{{<a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>}}</span>, we have
    <span class="inlinecode"><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> implies <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> for all states <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span>.  
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="is_wp"><span class="id" type="definition">is_wp</span></a> <span class="id" type="var">P</span> <span class="id" type="var">c</span> <span class="id" type="var">Q</span> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare2.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare2.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare2.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> <span class="id" type="var">P'</span>, <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare2.html#P'"><span class="id" type="variable">P'</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare2.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare2.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> → (<a class="idref" href="Hoare2.html#P'"><span class="id" type="variable">P'</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">-&gt;&gt;</span></a> <a class="idref" href="Hoare2.html#P"><span class="id" type="variable">P</span></a>).<br/>

<br/>
</div>

<div class="doc">
That is, <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> is the weakest precondition of <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> for <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span>
    if (a) <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <i>is</i> a precondition for <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> and <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span>, and (b) <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> is the
    <i>weakest</i> (easiest to satisfy) assertion that guarantees <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> after
    executing <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span>. 
<div class="paragraph"> </div>

<a name="lab595"></a><h4 class="section">Exercise: 1 star, optional (wp)</h4>
 What are the weakest preconditions of the following commands
   for the following postconditions?
  1) <a href=" ? "> ? </a>  SKIP  <a href=" X = 5 "> X = 5 </a>

<div class="paragraph"> </div>

  2) <a href=" ? "> ? </a>  X ::= Y + Z <a href=" X = 5 "> X = 5 </a>

<div class="paragraph"> </div>

  3) <a href=" ? "> ? </a>  X ::= Y  <a href=" X = Y "> X = Y </a>

<div class="paragraph"> </div>

  4) <a href=" ? "> ? </a>
     IFB X == 0 THEN Y ::= Z + 1 ELSE Y ::= W + 2 FI
     <a href=" Y = 5 "> Y = 5 </a>

<div class="paragraph"> </div>

  5) <a href=" ? "> ? </a>
     X ::= 5
     <a href=" X = 0 "> X = 0 </a>

<div class="paragraph"> </div>

  6) <a href=" ? "> ? </a>
     WHILE True DO X ::= 0 END
     <a href=" X = 0 "> X = 0 </a>

</div>
<div class="code">
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab596"></a><h4 class="section">Exercise: 3 stars, advanced, optional (is_wp_formal)</h4>
 Prove formally using the definition of <span class="inlinecode"><a class="idref" href="Hoare.html#Himp.hoare_triple"><span class="id" type="definition">hoare_triple</span></a></span> that <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode">4</span>
   is indeed the weakest precondition of <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">::=</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> with respect to
   postcondition <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode">5</span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="is_wp_example"><span class="id" type="lemma">is_wp_example</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#is_wp"><span class="id" type="definition">is_wp</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> 4)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)) (<span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> 5).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab597"></a><h4 class="section">Exercise: 2 stars, advanced (hoare_asgn_weakest)</h4>
 Show that the precondition in the rule <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a></span> is in fact the
    weakest precondition. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="hoare_asgn_weakest"><span class="id" type="lemma">hoare_asgn_weakest</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">Q</span> <span class="id" type="var">X</span> <span class="id" type="var">a</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#is_wp"><span class="id" type="definition">is_wp</span></a> (<a class="idref" href="Hoare2.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="Hoare2.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">|-&gt;</span></a> <a class="idref" href="Hoare2.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">]</span></a>) (<a class="idref" href="Hoare2.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Hoare2.html#a"><span class="id" type="variable">a</span></a>) <a class="idref" href="Hoare2.html#Q"><span class="id" type="variable">Q</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab598"></a><h4 class="section">Exercise: 2 stars, advanced, optional (hoare_havoc_weakest)</h4>
 Show that your <span class="inlinecode"><a class="idref" href="Hoare.html#Himp.havoc_pre"><span class="id" type="definition">havoc_pre</span></a></span> rule from the <span class="inlinecode"><span class="id" type="var">himp_hoare</span></span> exercise
    in the <span class="inlinecode"><span class="id" type="library">Hoare</span></span> chapter returns the weakest precondition. 
</div>
<div class="code">
<span class="id" type="keyword">Module</span> <a name="Himp2"><span class="id" type="module">Himp2</span></a>.<br/>
<span class="id" type="keyword">Import</span> <span class="id" type="var">Himp</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="Himp2.hoare_havoc_weakest"><span class="id" type="lemma">hoare_havoc_weakest</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a>) (<span class="id" type="var">X</span> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#Himp.:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <a class="idref" href="Hoare2.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#Himp.:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Hoare2.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Hoare.html#Himp.:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <a class="idref" href="Hoare2.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Hoare.html#Himp.:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">-&gt;&gt;</span></a> <a class="idref" href="Hoare.html#Himp.havoc_pre"><span class="id" type="definition">havoc_pre</span></a> <a class="idref" href="Hoare2.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Hoare2.html#Q"><span class="id" type="variable">Q</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Hoare2.html#Himp2"><span class="id" type="module">Himp2</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab599"></a><h1 class="section">Formal Decorated Programs (Advanced)</h1>

<div class="paragraph"> </div>

 The informal conventions for decorated programs amount to a way of
    displaying Hoare triples in which commands are annotated with
    enough embedded assertions that checking the validity of the
    triple is reduced to simple logical and algebraic calculations
    showing that some assertions imply others.  In this section, we
    show that this informal presentation style can actually be made
    completely formal and indeed that checking the validity of
    decorated programs can mostly be automated.  
<div class="paragraph"> </div>

<a name="lab600"></a><h2 class="section">Syntax</h2>

<div class="paragraph"> </div>

 The first thing we need to do is to formalize a variant of the
    syntax of commands with embedded assertions.  We call the new
    commands <i>decorated commands</i>, or <span class="inlinecode"><a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a></span>s. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="dcom"><span class="id" type="inductive">dcom</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="DCSkip"><span class="id" type="constructor">DCSkip</span></a> :  <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a> → <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a><br/>
&nbsp;&nbsp;| <a name="DCSeq"><span class="id" type="constructor">DCSeq</span></a> : <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a> → <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a> → <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a><br/>
&nbsp;&nbsp;| <a name="DCAsgn"><span class="id" type="constructor">DCAsgn</span></a> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> →  <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a> → <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a><br/>
&nbsp;&nbsp;| <a name="DCIf"><span class="id" type="constructor">DCIf</span></a> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a> →  <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a> → <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a> →  <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a> → <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a>→ <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a><br/>
&nbsp;&nbsp;| <a name="DCWhile"><span class="id" type="constructor">DCWhile</span></a> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a> → <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a> → <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a> → <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a> → <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a><br/>
&nbsp;&nbsp;| <a name="DCPre"><span class="id" type="constructor">DCPre</span></a> : <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a> → <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a> → <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a><br/>
&nbsp;&nbsp;| <a name="DCPost"><span class="id" type="constructor">DCPost</span></a> : <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a> → <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a> → <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "dcom_cases" <span class="id" type="var">tactic</span>(<span class="id" type="tactic">first</span>) <span class="id" type="var">ident</span>(<span class="id" type="var">c</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span>;<br/>
&nbsp;&nbsp;[ <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "Skip" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "Seq" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "Asgn"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "If" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "While"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "Pre" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "Post" ].<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":dcom_scope:'SKIP'_'{{'_x_'}}'"><span class="id" type="notation">"</span></a>'SKIP' {{ P }}"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= (<a class="idref" href="Hoare2.html#DCSkip"><span class="id" type="constructor">DCSkip</span></a> <span class="id" type="var">P</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 10) : <span class="id" type="var">dcom_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name=":dcom_scope:x_'::='_x_'{{'_x_'}}'"><span class="id" type="notation">"</span></a>l '::=' a {{ P }}"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= (<a class="idref" href="Hoare2.html#DCAsgn"><span class="id" type="constructor">DCAsgn</span></a> <span class="id" type="var">l</span> <span class="id" type="var">a</span> <span class="id" type="var">P</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 60, <span class="id" type="var">a</span> <span class="id" type="tactic">at</span> <span class="id" type="var">next</span> <span class="id" type="keyword">level</span>) : <span class="id" type="var">dcom_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name=":dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">"</span></a>'WHILE' b 'DO' {{ Pbody }} d 'END' {{ Ppost }}"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= (<a class="idref" href="Hoare2.html#DCWhile"><span class="id" type="constructor">DCWhile</span></a> <span class="id" type="var">b</span> <span class="id" type="var">Pbody</span> <span class="id" type="var">d</span> <span class="id" type="var">Ppost</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>) : <span class="id" type="var">dcom_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name=":dcom_scope:'IFB'_x_'THEN'_'{{'_x_'}}'_x_'ELSE'_'{{'_x_'}}'_x_'FI'_'{{'_x_'}}'"><span class="id" type="notation">"</span></a>'IFB' b 'THEN' {{ P }} d 'ELSE' {{ P' }} d' 'FI' {{ Q }}"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= (<a class="idref" href="Hoare2.html#DCIf"><span class="id" type="constructor">DCIf</span></a> <span class="id" type="var">b</span> <span class="id" type="var">P</span> <span class="id" type="var">d</span> <span class="id" type="var">P'</span> <span class="id" type="var">d'</span> <span class="id" type="var">Q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>)  : <span class="id" type="var">dcom_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name=":dcom_scope:'->>'_'{{'_x_'}}'_x"><span class="id" type="notation">"</span></a>'-&gt;&gt;' {{ P }} d"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= (<a class="idref" href="Hoare2.html#DCPre"><span class="id" type="constructor">DCPre</span></a> <span class="id" type="var">P</span> <span class="id" type="var">d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 90, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>)  : <span class="id" type="var">dcom_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name=":dcom_scope:'{{'_x_'}}'_x"><span class="id" type="notation">"</span></a>{{ P }} d"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= (<a class="idref" href="Hoare2.html#DCPre"><span class="id" type="constructor">DCPre</span></a> <span class="id" type="var">P</span> <span class="id" type="var">d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 90)  : <span class="id" type="var">dcom_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name=":dcom_scope:x_'->>'_'{{'_x_'}}'"><span class="id" type="notation">"</span></a>d '-&gt;&gt;' {{ P }}"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= (<a class="idref" href="Hoare2.html#DCPost"><span class="id" type="constructor">DCPost</span></a> <span class="id" type="var">d</span> <span class="id" type="var">P</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>)  : <span class="id" type="var">dcom_scope</span>.<br/>
<span class="id" type="keyword">Notation</span> <a name=":dcom_scope:x_';;'_x"><span class="id" type="notation">"</span></a> d ;; d' "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= (<a class="idref" href="Hoare2.html#DCSeq"><span class="id" type="constructor">DCSeq</span></a> <span class="id" type="var">d</span> <span class="id" type="var">d'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>)  : <span class="id" type="var">dcom_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Delimit</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">dcom_scope</span> <span class="id" type="keyword">with</span> <span class="id" type="var">dcom</span>.<br/>

<br/>
</div>

<div class="doc">
To avoid clashing with the existing <span class="inlinecode"><span class="id" type="keyword">Notation</span></span> definitions
    for ordinary <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.com"><span class="id" type="inductive">com</span></a></span>mands, we introduce these notations in a special
    scope called <span class="inlinecode"><span class="id" type="var">dcom_scope</span></span>, and we wrap examples with the
    declaration <span class="inlinecode">%</span> <span class="inlinecode"><a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a></span> to signal that we want the notations to be
    interpreted in this scope.

<div class="paragraph"> </div>

    Careful readers will note that we've defined two notations for the
    <span class="inlinecode"><a class="idref" href="Hoare2.html#DCPre"><span class="id" type="constructor">DCPre</span></a></span> constructor, one with and one without a <span class="inlinecode">-&gt;&gt;</span>.  The
    "without" version is intended to be used to supply the initial
    precondition at the very top of the program. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="dec_while"><span class="id" type="definition">dec_while</span></a> : <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a> := (<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:'{{'_x_'}}'_x"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:'{{'_x_'}}'_x"><span class="id" type="notation">}}</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0))<a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">DO</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<>'_x"><span class="id" type="notation">≠</span></a> 0<a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:x_'::='_x_'{{'_x_'}}'"><span class="id" type="notation">::=</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:x_'::='_x_'{{'_x_'}}'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<a class="idref" href="Hoare2.html#:dcom_scope:x_'::='_x_'{{'_x_'}}'"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:x_'::='_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:x_'::='_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">END</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 0<a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:x_'->>'_'{{'_x_'}}'"><span class="id" type="notation">-&gt;&gt;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:x_'->>'_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 0 <a class="idref" href="Hoare2.html#:dcom_scope:x_'->>'_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a><br/>
) % <span class="id" type="var">dcom</span>.<br/>

<br/>
</div>

<div class="doc">
It is easy to go from a <span class="inlinecode"><a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a></span> to a <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.com"><span class="id" type="inductive">com</span></a></span> by erasing all
    annotations. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="extract"><span class="id" type="definition">extract</span></a> (<span class="id" type="var">d</span>:<a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a>) : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCSkip"><span class="id" type="constructor">DCSkip</span></a> <span class="id" type="var">_</span>           ⇒ <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCSeq"><span class="id" type="constructor">DCSeq</span></a> <span class="id" type="var">d1</span> <span class="id" type="var">d2</span>        ⇒ (<a class="idref" href="Hoare2.html#extract"><span class="id" type="definition">extract</span></a> <span class="id" type="var">d1</span> <a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Hoare2.html#extract"><span class="id" type="definition">extract</span></a> <span class="id" type="var">d2</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCAsgn"><span class="id" type="constructor">DCAsgn</span></a> <span class="id" type="var">X</span> <span class="id" type="var">a</span> <span class="id" type="var">_</span>       ⇒ <span class="id" type="var">X</span> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <span class="id" type="var">a</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCIf"><span class="id" type="constructor">DCIf</span></a> <span class="id" type="var">b</span> <span class="id" type="var">_</span> <span class="id" type="var">d1</span> <span class="id" type="var">_</span> <span class="id" type="var">d2</span> <span class="id" type="var">_</span> ⇒ <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <span class="id" type="var">b</span> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Hoare2.html#extract"><span class="id" type="definition">extract</span></a> <span class="id" type="var">d1</span> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Hoare2.html#extract"><span class="id" type="definition">extract</span></a> <span class="id" type="var">d2</span> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCWhile"><span class="id" type="constructor">DCWhile</span></a> <span class="id" type="var">b</span> <span class="id" type="var">_</span> <span class="id" type="var">d</span> <span class="id" type="var">_</span>    ⇒ <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <span class="id" type="var">b</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Hoare2.html#extract"><span class="id" type="definition">extract</span></a> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCPre"><span class="id" type="constructor">DCPre</span></a> <span class="id" type="var">_</span> <span class="id" type="var">d</span>          ⇒ <a class="idref" href="Hoare2.html#extract"><span class="id" type="definition">extract</span></a> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCPost"><span class="id" type="constructor">DCPost</span></a> <span class="id" type="var">d</span> <span class="id" type="var">_</span>         ⇒ <a class="idref" href="Hoare2.html#extract"><span class="id" type="definition">extract</span></a> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The choice of exactly where to put assertions in the definition of
    <span class="inlinecode"><a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a></span> is a bit subtle.  The simplest thing to do would be to
    annotate every <span class="inlinecode"><a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a></span> with a precondition and postcondition.  But
    this would result in very verbose programs with a lot of repeated
    annotations: for example, a program like <span class="inlinecode"><span class="id" type="var">SKIP</span>;<span class="id" type="var">SKIP</span></span> would have to
    be annotated as
        <a href="P">P</a> (<a href="P">P</a> SKIP <a href="P">P</a>) ;; (<a href="P">P</a> SKIP <a href="P">P</a>) <a href="P">P</a>,
    with pre- and post-conditions on each <span class="inlinecode"><span class="id" type="var">SKIP</span></span>, plus identical pre-
    and post-conditions on the semicolon!

<div class="paragraph"> </div>

    Instead, the rule we've followed is this:

<div class="paragraph"> </div>

<ul class="doclist">
<li> The <i>post</i>-condition expected by each <span class="inlinecode"><a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.d"><span class="id" type="constructor">d</span></a></span> is embedded in <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.d"><span class="id" type="constructor">d</span></a></span>

<div class="paragraph"> </div>


</li>
<li> The <i>pre</i>-condition is supplied by the context. 
</li>
</ul>

<div class="paragraph"> </div>

 In other words, the invariant of the representation is that a
    <span class="inlinecode"><a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.d"><span class="id" type="constructor">d</span></a></span> together with a precondition <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> determines a Hoare
    triple <span class="inlinecode">{{<a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a>}}</span> <span class="inlinecode">(<a class="idref" href="Hoare2.html#extract"><span class="id" type="definition">extract</span></a></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.d"><span class="id" type="constructor">d</span></a>)</span> <span class="inlinecode">{{<a class="idref" href="Hoare2.html#post"><span class="id" type="definition">post</span></a></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.d"><span class="id" type="constructor">d</span></a>}}</span>, where <span class="inlinecode"><a class="idref" href="Hoare2.html#post"><span class="id" type="definition">post</span></a></span> is defined as
    follows: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="post"><span class="id" type="definition">post</span></a> (<span class="id" type="var">d</span>:<a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a>) : <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCSkip"><span class="id" type="constructor">DCSkip</span></a> <span class="id" type="var">P</span>                ⇒ <span class="id" type="var">P</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCSeq"><span class="id" type="constructor">DCSeq</span></a> <span class="id" type="var">d1</span> <span class="id" type="var">d2</span>             ⇒ <a class="idref" href="Hoare2.html#post"><span class="id" type="definition">post</span></a> <span class="id" type="var">d2</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCAsgn"><span class="id" type="constructor">DCAsgn</span></a> <span class="id" type="var">X</span> <span class="id" type="var">a</span> <span class="id" type="var">Q</span>            ⇒ <span class="id" type="var">Q</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCIf"><span class="id" type="constructor">DCIf</span></a>  <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">d1</span> <span class="id" type="var">_</span> <span class="id" type="var">d2</span> <span class="id" type="var">Q</span>     ⇒ <span class="id" type="var">Q</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCWhile"><span class="id" type="constructor">DCWhile</span></a> <span class="id" type="var">b</span> <span class="id" type="var">Pbody</span> <span class="id" type="var">c</span> <span class="id" type="var">Ppost</span> ⇒ <span class="id" type="var">Ppost</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCPre"><span class="id" type="constructor">DCPre</span></a> <span class="id" type="var">_</span> <span class="id" type="var">d</span>               ⇒ <a class="idref" href="Hoare2.html#post"><span class="id" type="definition">post</span></a> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCPost"><span class="id" type="constructor">DCPost</span></a> <span class="id" type="var">c</span> <span class="id" type="var">Q</span>              ⇒ <span class="id" type="var">Q</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Similarly, we can extract the "initial precondition" from a
    decorated program. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="pre"><span class="id" type="definition">pre</span></a> (<span class="id" type="var">d</span>:<a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a>) : <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCSkip"><span class="id" type="constructor">DCSkip</span></a> <span class="id" type="var">P</span>                ⇒ <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCSeq"><span class="id" type="constructor">DCSeq</span></a> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span>             ⇒ <a class="idref" href="Hoare2.html#pre"><span class="id" type="definition">pre</span></a> <span class="id" type="var">c1</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCAsgn"><span class="id" type="constructor">DCAsgn</span></a> <span class="id" type="var">X</span> <span class="id" type="var">a</span> <span class="id" type="var">Q</span>            ⇒ <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCIf"><span class="id" type="constructor">DCIf</span></a>  <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">t</span> <span class="id" type="var">_</span> <span class="id" type="var">e</span> <span class="id" type="var">_</span>       ⇒ <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCWhile"><span class="id" type="constructor">DCWhile</span></a> <span class="id" type="var">b</span> <span class="id" type="var">Pbody</span> <span class="id" type="var">c</span> <span class="id" type="var">Ppost</span> ⇒ <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCPre"><span class="id" type="constructor">DCPre</span></a> <span class="id" type="var">P</span> <span class="id" type="var">c</span>               ⇒ <span class="id" type="var">P</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCPost"><span class="id" type="constructor">DCPost</span></a> <span class="id" type="var">c</span> <span class="id" type="var">Q</span>              ⇒ <a class="idref" href="Hoare2.html#pre"><span class="id" type="definition">pre</span></a> <span class="id" type="var">c</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
This function is not doing anything sophisticated like calculating
    a weakest precondition; it just recursively searches for an
    explicit annotation at the very beginning of the program,
    returning default answers for programs that lack an explicit
    precondition (like a bare assignment or <span class="inlinecode"><span class="id" type="var">SKIP</span></span>). 
<div class="paragraph"> </div>

 Using <span class="inlinecode"><a class="idref" href="Hoare2.html#pre"><span class="id" type="definition">pre</span></a></span> and <span class="inlinecode"><a class="idref" href="Hoare2.html#post"><span class="id" type="definition">post</span></a></span>, and assuming that we adopt the convention
    of always supplying an explicit precondition annotation at the
    very beginning of our decorated programs, we can express what it
    means for a decorated program to be correct as follows: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="dec_correct"><span class="id" type="definition">dec_correct</span></a> (<span class="id" type="var">d</span>:<a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a>) :=<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare2.html#pre"><span class="id" type="definition">pre</span></a> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare2.html#extract"><span class="id" type="definition">extract</span></a> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare2.html#post"><span class="id" type="definition">post</span></a> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>

<br/>
</div>

<div class="doc">
To check whether this Hoare triple is <i>valid</i>, we need a way to
    extract the "proof obligations" from a decorated program.  These
    obligations are often called <i>verification conditions</i>, because
    they are the facts that must be verified to see that the
    decorations are logically consistent and thus add up to a complete
    proof of correctness. 
<div class="paragraph"> </div>

<a name="lab601"></a><h2 class="section">Extracting Verification Conditions</h2>

<div class="paragraph"> </div>

 The function <span class="inlinecode"><a class="idref" href="Hoare2.html#verification_conditions"><span class="id" type="definition">verification_conditions</span></a></span> takes a <span class="inlinecode"><a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.d"><span class="id" type="constructor">d</span></a></span> together
    with a precondition <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> and returns a <i>proposition</i> that, if it
    can be proved, implies that the triple <span class="inlinecode">{{<a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a>}}</span> <span class="inlinecode">(<a class="idref" href="Hoare2.html#extract"><span class="id" type="definition">extract</span></a></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.d"><span class="id" type="constructor">d</span></a>)</span> <span class="inlinecode">{{<a class="idref" href="Hoare2.html#post"><span class="id" type="definition">post</span></a></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.d"><span class="id" type="constructor">d</span></a>}}</span>
    is valid. 
<div class="paragraph"> </div>

 It does this by walking over <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.d"><span class="id" type="constructor">d</span></a></span> and generating a big
    conjunction including all the "local checks" that we listed when
    we described the informal rules for decorated programs.  (Strictly
    speaking, we need to massage the informal rules a little bit to
    add some uses of the rule of consequence, but the correspondence
    should be clear.) 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="verification_conditions"><span class="id" type="definition">verification_conditions</span></a> (<span class="id" type="var">P</span> : <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a>) (<span class="id" type="var">d</span>:<a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCSkip"><span class="id" type="constructor">DCSkip</span></a> <span class="id" type="var">Q</span>          ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Hoare2.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">-&gt;&gt;</span></a> <span class="id" type="var">Q</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCSeq"><span class="id" type="constructor">DCSeq</span></a> <span class="id" type="var">d1</span> <span class="id" type="var">d2</span>      ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare2.html#verification_conditions"><span class="id" type="definition">verification_conditions</span></a> <a class="idref" href="Hoare2.html#P"><span class="id" type="variable">P</span></a> <span class="id" type="var">d1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare2.html#verification_conditions"><span class="id" type="definition">verification_conditions</span></a> (<a class="idref" href="Hoare2.html#post"><span class="id" type="definition">post</span></a> <span class="id" type="var">d1</span>) <span class="id" type="var">d2</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCAsgn"><span class="id" type="constructor">DCAsgn</span></a> <span class="id" type="var">X</span> <span class="id" type="var">a</span> <span class="id" type="var">Q</span>      ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Hoare2.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">-&gt;&gt;</span></a> <span class="id" type="var">Q</span> <a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">[</span></a><span class="id" type="var">X</span> <a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">|-&gt;</span></a> <span class="id" type="var">a</span><a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">]</span></a>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCIf"><span class="id" type="constructor">DCIf</span></a> <span class="id" type="var">b</span> <span class="id" type="var">P1</span> <span class="id" type="var">d1</span> <span class="id" type="var">P2</span> <span class="id" type="var">d2</span> <span class="id" type="var">Q</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a> <span class="id" type="var">b</span> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">-&gt;&gt;</span></a> <span class="id" type="var">P1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a> <span class="id" type="var">b</span> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">-&gt;&gt;</span></a> <span class="id" type="var">P2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">Q</span> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'<<->>'_x"><span class="id" type="notation">&lt;&lt;-&gt;&gt;</span></a> <a class="idref" href="Hoare2.html#post"><span class="id" type="definition">post</span></a> <span class="id" type="var">d1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">Q</span> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'<<->>'_x"><span class="id" type="notation">&lt;&lt;-&gt;&gt;</span></a> <a class="idref" href="Hoare2.html#post"><span class="id" type="definition">post</span></a> <span class="id" type="var">d2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare2.html#verification_conditions"><span class="id" type="definition">verification_conditions</span></a> <span class="id" type="var">P1</span> <span class="id" type="var">d1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare2.html#verification_conditions"><span class="id" type="definition">verification_conditions</span></a> <span class="id" type="var">P2</span> <span class="id" type="var">d2</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCWhile"><span class="id" type="constructor">DCWhile</span></a> <span class="id" type="var">b</span> <span class="id" type="var">Pbody</span> <span class="id" type="var">d</span> <span class="id" type="var">Ppost</span>      ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare2.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">-&gt;&gt;</span></a> <a class="idref" href="Hoare2.html#post"><span class="id" type="definition">post</span></a> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">Pbody</span> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'<<->>'_x"><span class="id" type="notation">&lt;&lt;-&gt;&gt;</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'<<->>'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#post"><span class="id" type="definition">post</span></a> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a> <span class="id" type="var">b</span> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:x_'<<->>'_x"><span class="id" type="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><span class="id" type="var">Ppost</span> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'<<->>'_x"><span class="id" type="notation">&lt;&lt;-&gt;&gt;</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'<<->>'_x"><span class="id" type="notation">(</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#post"><span class="id" type="definition">post</span></a> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~(</span></a><a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a> <span class="id" type="var">b</span> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:x_'<<->>'_x"><span class="id" type="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare2.html#verification_conditions"><span class="id" type="definition">verification_conditions</span></a> <span class="id" type="var">Pbody</span> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCPre"><span class="id" type="constructor">DCPre</span></a> <span class="id" type="var">P'</span> <span class="id" type="var">d</span>         ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare2.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">-&gt;&gt;</span></a> <span class="id" type="var">P'</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare2.html#verification_conditions"><span class="id" type="definition">verification_conditions</span></a> <span class="id" type="var">P'</span> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Hoare2.html#DCPost"><span class="id" type="constructor">DCPost</span></a> <span class="id" type="var">d</span> <span class="id" type="var">Q</span>        ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare2.html#verification_conditions"><span class="id" type="definition">verification_conditions</span></a> <a class="idref" href="Hoare2.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare2.html#post"><span class="id" type="definition">post</span></a> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">-&gt;&gt;</span></a> <span class="id" type="var">Q</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
And now, the key theorem, which states that
    <span class="inlinecode"><a class="idref" href="Hoare2.html#verification_conditions"><span class="id" type="definition">verification_conditions</span></a></span> does its job correctly.  Not
    surprisingly, we need to use each of the Hoare Logic rules at some
    point in the proof.  We have used <i>in</i> variants of several tactics before to
    apply them to values in the context rather than the goal. An
    extension of this idea is the syntax <span class="inlinecode"><span class="id" type="var">tactic</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span> <span class="inlinecode">×</span>, which applies
    <span class="inlinecode"><span class="id" type="var">tactic</span></span> in the goal and every hypothesis in the context.  We most
    commonly use this facility in conjunction with the <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> tactic,
    as below. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="verification_correct"><span class="id" type="lemma">verification_correct</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">d</span> <span class="id" type="var">P</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#verification_conditions"><span class="id" type="definition">verification_conditions</span></a> <a class="idref" href="Hoare2.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a> → <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare2.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare2.html#extract"><span class="id" type="definition">extract</span></a> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare2.html#post"><span class="id" type="definition">post</span></a> <a class="idref" href="Hoare2.html#d"><span class="id" type="variable">d</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">dcom_cases</span> (<span class="id" type="tactic">induction</span> <span class="id" type="var">d</span>) <span class="id" type="var">Case</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> ×.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "Skip".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_skip"><span class="id" type="lemma">hoare_skip</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "Seq".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">H1</span> <span class="id" type="var">H2</span>]. <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_seq"><span class="id" type="lemma">hoare_seq</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHd2</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHd1</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H1</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "Asgn".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "If".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HPre1</span> [<span class="id" type="var">HPre2</span> [[<span class="id" type="var">Hd11</span> <span class="id" type="var">Hd12</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[<span class="id" type="var">Hd21</span> <span class="id" type="var">Hd22</span>] [<span class="id" type="var">HThen</span> <span class="id" type="var">HElse</span>]]]]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHd1</span> <span class="id" type="keyword">in</span> <span class="id" type="var">HThen</span>. <span class="id" type="tactic">clear</span> <span class="id" type="var">IHd1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHd2</span> <span class="id" type="keyword">in</span> <span class="id" type="var">HElse</span>. <span class="id" type="tactic">clear</span> <span class="id" type="var">IHd2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_if"><span class="id" type="lemma">hoare_if</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a>; <span class="id" type="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_post"><span class="id" type="lemma">hoare_consequence_post</span></a>; <span class="id" type="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a>; <span class="id" type="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_post"><span class="id" type="lemma">hoare_consequence_post</span></a>; <span class="id" type="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "While".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">Hpre</span> [[<span class="id" type="var">Hbody1</span> <span class="id" type="var">Hbody2</span>] [[<span class="id" type="var">Hpost1</span> <span class="id" type="var">Hpost2</span>]  <span class="id" type="var">Hd</span>]]];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">subst</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a>; <span class="id" type="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_post"><span class="id" type="lemma">hoare_consequence_post</span></a>; <span class="id" type="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_while"><span class="id" type="lemma">hoare_while</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a>; <span class="id" type="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "Pre".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> <span class="id" type="var">Hd</span>]; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHd</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">Hd</span>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "Post".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">Hd</span> <span class="id" type="var">HQ</span>]; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_post"><span class="id" type="lemma">hoare_consequence_post</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHd</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">Hd</span>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab602"></a><h2 class="section">Examples</h2>

<div class="paragraph"> </div>

 The propositions generated by <span class="inlinecode"><a class="idref" href="Hoare2.html#verification_conditions"><span class="id" type="definition">verification_conditions</span></a></span> are fairly
    big, and they contain many conjuncts that are essentially trivial. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> (<a class="idref" href="Hoare2.html#verification_conditions"><span class="id" type="definition">verification_conditions</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>) <a class="idref" href="Hoare2.html#dec_while"><span class="id" type="definition">dec_while</span></a>).<br/>
</div>

<div class="doc">
==&gt;
(((fun _ : state =&gt; True) -&gt;&gt; (fun _ : state =&gt; True)) /\
 ((fun _ : state =&gt; True) -&gt;&gt; (fun _ : state =&gt; True)) /\
 (fun st : state =&gt; True /\ bassn (BNot (BEq (AId X) (ANum 0))) st) =
 (fun st : state =&gt; True /\ bassn (BNot (BEq (AId X) (ANum 0))) st) /\
 (fun st : state =&gt; True /\ ~ bassn (BNot (BEq (AId X) (ANum 0))) st) =
 (fun st : state =&gt; True /\ ~ bassn (BNot (BEq (AId X) (ANum 0))) st) /\
 (fun st : state =&gt; True /\ bassn (BNot (BEq (AId X) (ANum 0))) st) -&gt;&gt;
 (fun _ : state =&gt; True) <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">|-&gt;</span> <span class="inlinecode"><a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a></span> <span class="inlinecode">(<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>)</span> <span class="inlinecode">(<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a></span> <span class="inlinecode">1)</span>) /\
(fun st : state =&gt; True /\ ~ bassn (BNot (BEq (AId X) (ANum 0))) st) -&gt;&gt;
(fun st : state =&gt; st X = 0)

<div class="paragraph"> </div>

 In principle, we could certainly work with them using just the
    tactics we have so far, but we can make things much smoother with
    a bit of automation.  We first define a custom <span class="inlinecode"><span class="id" type="var">verify</span></span> tactic
    that applies splitting repeatedly to turn all the conjunctions
    into separate subgoals and then uses <span class="inlinecode"><span class="id" type="tactic">omega</span></span> and <span class="inlinecode"><span class="id" type="tactic">eauto</span></span> (a handy
    general-purpose automation tactic that we'll discuss in detail
    later) to deal with as many of them as possible. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="ble_nat_true_iff"><span class="id" type="lemma">ble_nat_true_iff</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="SfLib.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> <a class="idref" href="Hoare2.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="Hoare2.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">split</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="SfLib.html#ble_nat_true"><span class="id" type="axiom">ble_nat_true</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">m</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.Le.html#le_S_n"><span class="id" type="lemma">le_S_n</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHn</span>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="ble_nat_false_iff"><span class="id" type="lemma">ble_nat_false_iff</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="SfLib.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> <a class="idref" href="Hoare2.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~(</span></a><a class="idref" href="Hoare2.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">split</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="SfLib.html#ble_nat_false"><span class="id" type="axiom">ble_nat_false</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">n</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">m</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="SfLib.html#ex_falso_quodlibet"><span class="id" type="lemma">ex_falso_quodlibet</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.Le.html#le_0_n"><span class="id" type="lemma">le_0_n</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHn</span>. <span class="id" type="tactic">intro</span> <span class="id" type="var">Hc</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.Le.html#le_n_S"><span class="id" type="lemma">le_n_S</span></a>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "verify" :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare2.html#verification_correct"><span class="id" type="lemma">verification_correct</span></a>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="tactic">split</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#assert_implies"><span class="id" type="definition">assert_implies</span></a>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">unfold</span> <a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">unfold</span> <a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <span class="id" type="keyword">in</span> *;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#assn_sub"><span class="id" type="definition">assn_sub</span></a>; <span class="id" type="tactic">intros</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="tactic">rewrite</span> <a class="idref" href="Imp.html#update_eq"><span class="id" type="axiom">update_eq</span></a>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> (<span class="id" type="tactic">rewrite</span> <a class="idref" href="Imp.html#update_neq"><span class="id" type="axiom">update_neq</span></a>; [| (<span class="id" type="tactic">intro</span> <span class="id" type="var">X</span>; <span class="id" type="tactic">inversion</span> <span class="id" type="var">X</span>)]);<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> *;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span> [<span class="id" type="var">H</span> : <span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <span class="id" type="var">_</span> |- <span class="id" type="var">_</span>] ⇒ <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">end</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Bool.Bool.html#not_true_iff_false"><span class="id" type="lemma">not_true_iff_false</span></a> <span class="id" type="keyword">in</span> *;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Bool.Bool.html#not_false_iff_true"><span class="id" type="lemma">not_false_iff_true</span></a> <span class="id" type="keyword">in</span> *;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Bool.Bool.html#negb_true_iff"><span class="id" type="lemma">negb_true_iff</span></a> <span class="id" type="keyword">in</span> *;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Bool.Bool.html#negb_false_iff"><span class="id" type="lemma">negb_false_iff</span></a> <span class="id" type="keyword">in</span> *;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.EqNat.html#beq_nat_true_iff"><span class="id" type="lemma">beq_nat_true_iff</span></a> <span class="id" type="keyword">in</span> *;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.EqNat.html#beq_nat_false_iff"><span class="id" type="lemma">beq_nat_false_iff</span></a> <span class="id" type="keyword">in</span> *;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="tactic">rewrite</span> <a class="idref" href="Hoare2.html#ble_nat_true_iff"><span class="id" type="lemma">ble_nat_true_iff</span></a> <span class="id" type="keyword">in</span> *;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> <span class="id" type="tactic">rewrite</span> <a class="idref" href="Hoare2.html#ble_nat_false_iff"><span class="id" type="lemma">ble_nat_false_iff</span></a> <span class="id" type="keyword">in</span> *;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="tactic">subst</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> |- <span class="id" type="var">_</span>] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="keyword">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" type="var">H</span> : <span class="id" type="var">st</span> <span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">_</span> |- <span class="id" type="var">_</span>] ⇒ <span class="id" type="tactic">rewrite</span> → <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [<span class="id" type="var">H</span> : <span class="id" type="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">st</span> <span class="id" type="var">_</span> |- <span class="id" type="var">_</span>] ⇒ <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="tactic">eauto</span>; <span class="id" type="tactic">try</span> <span class="id" type="tactic">omega</span>.<br/>

<br/>
</div>

<div class="doc">
What's left after <span class="inlinecode"><span class="id" type="var">verify</span></span> does its thing is "just the interesting
    parts" of checking that the decorations are correct. For very
    simple examples <span class="inlinecode"><span class="id" type="var">verify</span></span> immediately solves the goal (provided
    that the annotations are correct). 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="dec_while_correct"><span class="id" type="lemma">dec_while_correct</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#dec_correct"><span class="id" type="definition">dec_correct</span></a> <a class="idref" href="Hoare2.html#dec_while"><span class="id" type="definition">dec_while</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="var">verify</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Another example (formalizing a decorated program we've seen
    before): 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="subtract_slowly_dec"><span class="id" type="definition">subtract_slowly_dec</span></a> (<span class="id" type="var">m</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">p</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a> := (<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:'{{'_x_'}}'_x"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare2.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:'{{'_x_'}}'_x"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:'->>'_'{{'_x_'}}'_x"><span class="id" type="notation">-&gt;&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:'->>'_'{{'_x_'}}'_x"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare2.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:'->>'_'{{'_x_'}}'_x"><span class="id" type="notation">}}</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0))<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">DO</span></a>   <a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare2.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<>'_x"><span class="id" type="notation">≠</span></a> 0 <a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:'->>'_'{{'_x_'}}'_x"><span class="id" type="notation">-&gt;&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:'->>'_'{{'_x_'}}'_x"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 1<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 1<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare2.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:'->>'_'{{'_x_'}}'_x"><span class="id" type="notation">}}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:x_'::='_x_'{{'_x_'}}'"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:x_'::='_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> 1<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare2.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:x_'::='_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:x_'::='_x_'{{'_x_'}}'"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:x_'::='_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare2.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:x_'::='_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">END</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare2.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 0 <a class="idref" href="Hoare2.html#:dcom_scope:'WHILE'_x_'DO'_'{{'_x_'}}'_x_'END'_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:x_'->>'_'{{'_x_'}}'"><span class="id" type="notation">-&gt;&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare2.html#:dcom_scope:x_'->>'_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare2.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare2.html#p"><span class="id" type="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="Hoare2.html#:dcom_scope:x_'->>'_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a><br/>
) % <span class="id" type="var">dcom</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="subtract_slowly_dec_correct"><span class="id" type="lemma">subtract_slowly_dec_correct</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#dec_correct"><span class="id" type="definition">dec_correct</span></a> (<a class="idref" href="Hoare2.html#subtract_slowly_dec"><span class="id" type="definition">subtract_slowly_dec</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="Hoare2.html#p"><span class="id" type="variable">p</span></a>).<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>. <span class="id" type="var">verify</span>.  <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab603"></a><h4 class="section">Exercise: 3 stars, advanced (slow_assignment_dec)</h4>

<div class="paragraph"> </div>

 In the <span class="inlinecode"><span class="id" type="var">slow_assignment</span></span> exercise above, we saw a roundabout way
    of assigning a number currently stored in <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> to the variable <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span>:
    start <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> at <span class="inlinecode">0</span>, then decrement <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> until it hits <span class="inlinecode">0</span>,
    incrementing <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> at each step. 

<div class="paragraph"> </div>

    Write a <i>formal</i> version of this decorated program and prove it
    correct. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="slow_assignment_dec"><span class="id" type="definition">slow_assignment_dec</span></a> (<span class="id" type="var">m</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="Hoare2.html#dcom"><span class="id" type="inductive">dcom</span></a> :=<br/>
 <a class="idref" href="SfLib.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="slow_assignment_dec_correct"><span class="id" type="lemma">slow_assignment_dec_correct</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare2.html#dec_correct"><span class="id" type="definition">dec_correct</span></a> (<a class="idref" href="Hoare2.html#slow_assignment_dec"><span class="id" type="definition">slow_assignment_dec</span></a> <a class="idref" href="Hoare2.html#m"><span class="id" type="variable">m</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.  <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab604"></a><h4 class="section">Exercise: 4 stars, advanced (factorial_dec)</h4>
 Remember the factorial function we worked with before: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="real_fact"><span class="id" type="definition">real_fact</span></a> (<span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Hoare2.html#n"><span class="id" type="variable">n</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#O"><span class="id" type="constructor">O</span></a> ⇒ 1<br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n'</span> ⇒ <a class="idref" href="Hoare2.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare2.html#real_fact"><span class="id" type="definition">real_fact</span></a> <span class="id" type="var">n'</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Following the pattern of <span class="inlinecode"><a class="idref" href="Hoare2.html#subtract_slowly_dec"><span class="id" type="definition">subtract_slowly_dec</span></a></span>, write a decorated
    program <span class="inlinecode"><span class="id" type="var">factorial_dec</span></span> that implements the factorial function and 
    prove it correct as <span class="inlinecode"><span class="id" type="var">factorial_dec_correct</span></span>. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

  
</div>
<div class="code">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>