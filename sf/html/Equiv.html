<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Equiv</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Equiv</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab476"></a><h1 class="section">Equiv: Program Equivalence</h1>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="Imp.html#"><span class="id" type="library">Imp</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab477"></a><h3 class="section">Some general advice for working on exercises:</h3>


<div class="paragraph"> </div>

<ul class="doclist">
<li> Most of the Coq proofs we ask you to do are similar to proofs
      that we've provided.  Before starting to work on the homework
      problems, take the time to work through our proofs (both
      informally, on paper, and in Coq) and make sure you understand
      them in detail.  This will save you a lot of time.

<div class="paragraph"> </div>


</li>
<li> The Coq proofs we're doing now are sufficiently complicated that
      it is more or less impossible to complete them simply by random
      experimentation or "following your nose."  You need to start
      with an idea about why the property is true and how the proof is
      going to go.  The best way to do this is to write out at least a
      sketch of an informal proof on paper -- one that intuitively
      convinces you of the truth of the theorem -- before starting to
      work on the formal one.  Alternately, grab a friend and try to
      convince them that the theorem is true; then try to formalize
      your explanation.

<div class="paragraph"> </div>


</li>
<li> Use automation to save work!  Some of the proofs in this
      chapter's exercises are pretty long if you try to write out all
      the cases explicitly. 
</li>
</ul>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab478"></a><h1 class="section">Behavioral Equivalence</h1>

<div class="paragraph"> </div>

 In the last chapter, we investigated the correctness of a very
    simple program transformation: the <span class="inlinecode"><a class="idref" href="Imp.html#AExp.optimize_0plus"><span class="id" type="definition">optimize_0plus</span></a></span> function.  The
    programming language we were considering was the first version of
    the language of arithmetic expressions -- with no variables -- so
    in that setting it was very easy to define what it <i>means</i> for a
    program transformation to be correct: it should always yield a
    program that evaluates to the same number as the original.  

<div class="paragraph"> </div>

    To go further and talk about the correctness of program
    transformations in the full Imp language, we need to consider the
    role of variables and state. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab479"></a><h2 class="section">Definitions</h2>

<div class="paragraph"> </div>

 For <span class="inlinecode"><a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a></span>s and <span class="inlinecode"><a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a></span>s with variables, the definition we want is
    clear.  We say
    that two <span class="inlinecode"><a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a></span>s or <span class="inlinecode"><a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a></span>s are <i>behaviorally equivalent</i> if they
    evaluate to the same result <i>in every state</i>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="aequiv"><span class="id" type="definition">aequiv</span></a> (<span class="id" type="var">a1</span> <span class="id" type="var">a2</span> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span>:<a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>), <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="bequiv"><span class="id" type="definition">bequiv</span></a> (<span class="id" type="var">b1</span> <span class="id" type="var">b2</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span>:<a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>), <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#b2"><span class="id" type="variable">b2</span></a>.<br/>

<br/>
</div>

<div class="doc">
For commands, the situation is a little more subtle.  We can't
    simply say "two commands are behaviorally equivalent if they
    evaluate to the same ending state whenever they are started in the
    same initial state," because some commands (in some starting
    states) don't terminate in any final state at all!  What we need
    instead is this: two commands are behaviorally equivalent if, for
    any given starting state, they either both diverge or both
    terminate in the same final state.  A compact way to express this
    is "if the first one terminates in a particular state then so does
    the second, and vice versa." 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="cequiv"><span class="id" type="definition">cequiv</span></a> (<span class="id" type="var">c1</span> <span class="id" type="var">c2</span> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> <span class="id" type="var">st'</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>), <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab480"></a><h4 class="section">Exercise: 2 stars (equiv_classes)</h4>

<div class="paragraph"> </div>

 Given the following programs, group together those that are
    equivalent in <span class="inlinecode"><span class="id" type="library">Imp</span></span>. Your answer should be given as a list of
    lists, where each sub-list represents a group of equivalent
    programs. For example, if you think programs (a) through (h) are
    all equivalent to each other, but not to (i), your answer should
    look like this:

<div class="paragraph"> </div>

    <span class="inlinecode"></span> <span class="inlinecode">[<a class="idref" href="Equiv.html#prog_a"><span class="id" type="definition">prog_a</span></a>;<a class="idref" href="Equiv.html#prog_b"><span class="id" type="definition">prog_b</span></a>;<a class="idref" href="Equiv.html#prog_c"><span class="id" type="definition">prog_c</span></a>;<a class="idref" href="Equiv.html#prog_d"><span class="id" type="definition">prog_d</span></a>;<a class="idref" href="Equiv.html#prog_e"><span class="id" type="definition">prog_e</span></a>;<a class="idref" href="Equiv.html#prog_f"><span class="id" type="definition">prog_f</span></a>;<a class="idref" href="Equiv.html#prog_g"><span class="id" type="definition">prog_g</span></a>;<a class="idref" href="Equiv.html#prog_h"><span class="id" type="definition">prog_h</span></a>]</span> <span class="inlinecode">;</span>
      <span class="inlinecode">[<a class="idref" href="Equiv.html#prog_i"><span class="id" type="definition">prog_i</span></a>]</span> <span class="inlinecode"></span>

<div class="paragraph"> </div>

    Write down your answer below in the definition of <span class="inlinecode"><a class="idref" href="Equiv.html#equiv_classes"><span class="id" type="definition">equiv_classes</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="prog_a"><span class="id" type="definition">prog_a</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BLe"><span class="id" type="constructor">BLe</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0)) <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="prog_b"><span class="id" type="definition">prog_b</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0) <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>)<a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="prog_c"><span class="id" type="definition">prog_c</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="prog_d"><span class="id" type="definition">prog_d</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0)) <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AMult"><span class="id" type="constructor">AMult</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>)) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="prog_e"><span class="id" type="definition">prog_e</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="prog_f"><span class="id" type="definition">prog_f</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>)) <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="prog_g"><span class="id" type="definition">prog_g</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="prog_h"><span class="id" type="definition">prog_h</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>)) <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="prog_i"><span class="id" type="definition">prog_i</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>)) <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="equiv_classes"><span class="id" type="definition">equiv_classes</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a>) :=<br/>
 <a class="idref" href="SfLib.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab481"></a><h2 class="section">Examples</h2>

<div class="paragraph"> </div>

 Here are some simple examples of equivalences of arithmetic
    and boolean expressions. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="aequiv_example"><span class="id" type="lemma">aequiv_example</span></a>:<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#aequiv"><span class="id" type="definition">aequiv</span></a> (<a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>)) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">omega</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="bequiv_example"><span class="id" type="lemma">bequiv_example</span></a>:<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>)) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0)) <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st</span>. <span class="id" type="tactic">unfold</span> <a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <a class="idref" href="Equiv.html#aequiv_example"><span class="id" type="lemma">aequiv_example</span></a>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
For examples of command equivalence, let's start by looking at
    some trivial program transformations involving <span class="inlinecode"><span class="id" type="var">SKIP</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="skip_left"><span class="id" type="lemma">skip_left</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">c</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "-&gt;".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H2</span>. <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "&lt;-".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_Seq"><span class="id" type="constructor">E_Seq</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">st</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_Skip"><span class="id" type="constructor">E_Skip</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab482"></a><h4 class="section">Exercise: 2 stars (skip_right)</h4>
 Prove that adding a SKIP after a command results in an equivalent
    program 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="skip_right"><span class="id" type="lemma">skip_right</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Similarly, here is a simple transformations that simplifies <span class="inlinecode"><span class="id" type="var">IFB</span></span>
    commands: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="IFB_true_simple"><span class="id" type="lemma">IFB_true_simple</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "-&gt;".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">subst</span>. <span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H5</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "&lt;-".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_IfTrue"><span class="id" type="constructor">E_IfTrue</span></a>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="tactic">assumption</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Of course, few programmers would be tempted to write a conditional
    whose guard is literally <span class="inlinecode"><a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a></span>.  A more interesting case is when
    the guard is <i>equivalent</i> to true:

<div class="paragraph"> </div>

   <i>Theorem</i>: If <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> is equivalent to <span class="inlinecode"><a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a></span>, then <span class="inlinecode"><span class="id" type="var">IFB</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">THEN</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span>
   <span class="inlinecode"><span class="id" type="var">ELSE</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> <span class="inlinecode"><span class="id" type="var">FI</span></span> is equivalent to <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span>.
<a name="lab483"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

   <i>Proof</i>: 

<div class="paragraph"> </div>

<ul class="doclist">
<li> (<span class="inlinecode">→</span>) We must show, for all <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>, that if <span class="inlinecode"><span class="id" type="var">IFB</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span>
       <span class="inlinecode"><span class="id" type="var">THEN</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode"><span class="id" type="var">ELSE</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> <span class="inlinecode"><span class="id" type="var">FI</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span> then <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>.

<div class="paragraph"> </div>

       Proceed by cases on the rules that could possibly have been
       used to show <span class="inlinecode"><span class="id" type="var">IFB</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">THEN</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode"><span class="id" type="var">ELSE</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> <span class="inlinecode"><span class="id" type="var">FI</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>, namely
       <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.E_IfTrue"><span class="id" type="constructor">E_IfTrue</span></a></span> and <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.E_IfFalse"><span class="id" type="constructor">E_IfFalse</span></a></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Suppose the final rule rule in the derivation of <span class="inlinecode"><span class="id" type="var">IFB</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">THEN</span></span>
         <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode"><span class="id" type="var">ELSE</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> <span class="inlinecode"><span class="id" type="var">FI</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span> was <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.E_IfTrue"><span class="id" type="constructor">E_IfTrue</span></a></span>.  We then have, by
         the premises of <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.E_IfTrue"><span class="id" type="constructor">E_IfTrue</span></a></span>, that <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>.  This is
         exactly what we set out to prove.

<div class="paragraph"> </div>


</li>
<li> On the other hand, suppose the final rule in the derivation
         of <span class="inlinecode"><span class="id" type="var">IFB</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">THEN</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode"><span class="id" type="var">ELSE</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> <span class="inlinecode"><span class="id" type="var">FI</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span> was <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.E_IfFalse"><span class="id" type="constructor">E_IfFalse</span></a></span>.
         We then know that <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a></span> and <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>.

<div class="paragraph"> </div>

         Recall that <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> is equivalent to <span class="inlinecode"><a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a></span>, i.e. forall <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span>,
         <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a></span>.  In particular, this means
         that <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a></span>, since <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a></span>.  But
         this is a contradiction, since <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.E_IfFalse"><span class="id" type="constructor">E_IfFalse</span></a></span> requires that
         <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a></span>.  Thus, the final rule could not have
         been <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.E_IfFalse"><span class="id" type="constructor">E_IfFalse</span></a></span>.

<div class="paragraph"> </div>


</li>
</ul>

</li>
<li> (<span class="inlinecode">&lt;-</span>) We must show, for all <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>, that if <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span>
       <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span> then <span class="inlinecode"><span class="id" type="var">IFB</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">THEN</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode"><span class="id" type="var">ELSE</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> <span class="inlinecode"><span class="id" type="var">FI</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>.

<div class="paragraph"> </div>

       Since <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> is equivalent to <span class="inlinecode"><a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a></span>, we know that <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> =
       <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a></span> = <span class="inlinecode"><a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a></span>.  Together with the assumption that
       <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>, we can apply <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.E_IfTrue"><span class="id" type="constructor">E_IfTrue</span></a></span> to derive <span class="inlinecode"><span class="id" type="var">IFB</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">THEN</span></span>
       <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode"><span class="id" type="var">ELSE</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> <span class="inlinecode"><span class="id" type="var">FI</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>.  <font size=-2>&#9744;</font>

</li>
</ul>

<div class="paragraph"> </div>

   Here is the formal version of this proof: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="IFB_true"><span class="id" type="lemma">IFB_true</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a>  →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span> <span class="id" type="var">Hb</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "-&gt;".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "b evaluates to true".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "b evaluates to false (contradiction)".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">Hb</span>. <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hb</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H5</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "&lt;-".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_IfTrue"><span class="id" type="constructor">E_IfTrue</span></a>; <span class="id" type="tactic">try</span> <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">Hb</span>. <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hb</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab484"></a><h4 class="section">Exercise: 2 stars (IFB_false)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="IFB_false"><span class="id" type="lemma">IFB_false</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a>  →<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab485"></a><h4 class="section">Exercise: 3 stars (swap_if_branches)</h4>
 Show that we can swap the branches of an IF by negating its
    condition 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="swap_if_branches"><span class="id" type="lemma">swap_if_branches</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> <span class="id" type="var">e1</span> <span class="id" type="var">e2</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Equiv.html#e1"><span class="id" type="variable">e1</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Equiv.html#e2"><span class="id" type="variable">e2</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Equiv.html#e2"><span class="id" type="variable">e2</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Equiv.html#e1"><span class="id" type="variable">e1</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab486"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 For <span class="inlinecode"><span class="id" type="var">WHILE</span></span> loops, we can give a similar pair of theorems.  A loop
    whose guard is equivalent to <span class="inlinecode"><a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a></span> is equivalent to <span class="inlinecode"><span class="id" type="var">SKIP</span></span>,
    while a loop whose guard is equivalent to <span class="inlinecode"><a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a></span> is equivalent to
    <span class="inlinecode"><span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><span class="id" type="var">SKIP</span></span> <span class="inlinecode"><span class="id" type="var">END</span></span> (or any other non-terminating program).
    The first of these facts is easy. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="WHILE_false"><span class="id" type="lemma">WHILE_false</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">Hb</span>. <span class="id" type="tactic">split</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "-&gt;".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "E_WhileEnd".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_Skip"><span class="id" type="constructor">E_Skip</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "E_WhileLoop".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hb</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H2</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "&lt;-".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_WhileEnd"><span class="id" type="constructor">E_WhileEnd</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab487"></a><h4 class="section">Exercise: 2 stars, advanced, optional (WHILE_false_informal)</h4>
 Write an informal proof of <span class="inlinecode"><a class="idref" href="Equiv.html#WHILE_false"><span class="id" type="lemma">WHILE_false</span></a></span>.

<div class="paragraph"> </div>

<font size=-2>&#9744;</font>

<div class="paragraph"> </div>

<a name="lab488"></a><h3 class="section"> </h3>
 To prove the second fact, we need an auxiliary lemma stating that
    <span class="inlinecode"><span class="id" type="var">WHILE</span></span> loops whose guards are equivalent to <span class="inlinecode"><a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a></span> never
    terminate:

<div class="paragraph"> </div>

    <i>Lemma</i>: If <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> is equivalent to <span class="inlinecode"><a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a></span>, then it cannot be the
    case that <span class="inlinecode">(<span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span>)</span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>.

<div class="paragraph"> </div>

    <i>Proof</i>: Suppose that <span class="inlinecode">(<span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span>)</span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>.  We show,
    by induction on a derivation of <span class="inlinecode">(<span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span>)</span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>,
    that this assumption leads to a contradiction.  

<div class="paragraph"> </div>

<ul class="doclist">
<li> Suppose <span class="inlinecode">(<span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span>)</span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span> is proved using rule
        <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.E_WhileEnd"><span class="id" type="constructor">E_WhileEnd</span></a></span>.  Then by assumption <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a></span>.  But
        this contradicts the assumption that <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> is equivalent to
        <span class="inlinecode"><a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a></span>.

<div class="paragraph"> </div>


</li>
<li> Suppose <span class="inlinecode">(<span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span>)</span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span> is proved using rule
        <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.E_WhileLoop"><span class="id" type="constructor">E_WhileLoop</span></a></span>.  Then we are given the induction hypothesis
        that <span class="inlinecode">(<span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span>)</span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span> is contradictory, which
        is exactly what we are trying to prove!

<div class="paragraph"> </div>


</li>
<li> Since these are the only rules that could have been used to
        prove <span class="inlinecode">(<span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span>)</span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>, the other cases of
        the induction are immediately contradictory. <font size=-2>&#9744;</font> 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="WHILE_true_nonterm"><span class="id" type="lemma">WHILE_true_nonterm</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~(</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">Hb</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <span class="id" type="var">b</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <span class="id" type="var">c</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>) <span class="id" type="keyword">as</span> <span class="id" type="var">cw</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Heqcw</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">ceval_cases</span> (<span class="id" type="tactic">induction</span> <span class="id" type="var">H</span>) <span class="id" type="var">Case</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqcw</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">Heqcw</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "E_WhileEnd". &nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">Hb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hb</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "E_WhileLoop". &nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHceval2</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab489"></a><h4 class="section">Exercise: 2 stars, optional (WHILE_true_nonterm_informal)</h4>
 Explain what the lemma <span class="inlinecode"><a class="idref" href="Equiv.html#WHILE_true_nonterm"><span class="id" type="lemma">WHILE_true_nonterm</span></a></span> means in English.

<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab490"></a><h4 class="section">Exercise: 2 stars (WHILE_true)</h4>
 Prove the following theorem. <i>Hint</i>: You'll want to use
    <span class="inlinecode"><a class="idref" href="Equiv.html#WHILE_true_nonterm"><span class="id" type="lemma">WHILE_true_nonterm</span></a></span> here. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="WHILE_true"><span class="id" type="lemma">WHILE_true</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a>  →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="loop_unrolling"><span class="id" type="lemma">loop_unrolling</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">Hce</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "-&gt;".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">Hce</span>; <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "loop doesn't run".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_IfFalse"><span class="id" type="constructor">E_IfFalse</span></a>. <span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_Skip"><span class="id" type="constructor">E_Skip</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "loop runs".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_IfTrue"><span class="id" type="constructor">E_IfTrue</span></a>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_Seq"><span class="id" type="constructor">E_Seq</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">st'</span> := <span class="id" type="var">st'0</span>). <span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "&lt;-".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">Hce</span>; <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "loop runs".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H5</span>; <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_WhileLoop"><span class="id" type="constructor">E_WhileLoop</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">st'</span> := <span class="id" type="var">st'0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "loop doesn't run".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H5</span>; <span class="id" type="tactic">subst</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_WhileEnd"><span class="id" type="constructor">E_WhileEnd</span></a>. <span class="id" type="tactic">assumption</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab491"></a><h4 class="section">Exercise: 2 stars, optional (seq_assoc)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="seq_assoc"><span class="id" type="lemma">seq_assoc</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span> <span class="id" type="var">c3</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> (<a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">);;</span></a><a class="idref" href="Equiv.html#c3"><span class="id" type="variable">c3</span></a>) (<a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;(</span></a><a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><a class="idref" href="Equiv.html#c3"><span class="id" type="variable">c3</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">)</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab492"></a><h2 class="section">The Functional Equivalence Axiom</h2>

<div class="paragraph"> </div>

 Finally, let's look at simple equivalences involving assignments.
    For example, we might expect to be able to show that <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">::=</span> <span class="inlinecode"><a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span>
    is equivalent to <span class="inlinecode"><span class="id" type="var">SKIP</span></span>.  However, when we try to show it, we get
    stuck in an interesting way. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="identity_assignment_first_try"><span class="id" type="lemma">identity_assignment_first_try</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">X</span>:<a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> (<a class="idref" href="Equiv.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Equiv.html#X"><span class="id" type="variable">X</span></a>) <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">split</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "-&gt;".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">subst</span>. <span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">replace</span> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <span class="id" type="var">st</span> <span class="id" type="var">X</span> (<span class="id" type="var">st</span> <span class="id" type="var">X</span>)) <span class="id" type="keyword">with</span> <span class="id" type="var">st</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">constructor</span>.<br/>
 <span class="id" type="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Here we're stuck. The goal looks reasonable, but in fact it is not
    provable!  If we look back at the set of lemmas we proved about
    <span class="inlinecode"><a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a></span> in the last chapter, we can see that lemma <span class="inlinecode"><a class="idref" href="Imp.html#update_same"><span class="id" type="lemma">update_same</span></a></span>
    almost does the job, but not quite: it says that the original and
    updated states agree at all values, but this is not the same thing
    as saying that they are <span class="inlinecode">=</span> in Coq's sense! 
<div class="paragraph"> </div>

 What is going on here?  Recall that our states are just
    functions from identifiers to values.  For Coq, functions are only
    equal when their definitions are syntactically the same, modulo
    simplification.  (This is the only way we can legally apply the
    <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#refl_equal"><span class="id" type="abbreviation">refl_equal</span></a></span> constructor of the inductively defined proposition
    <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.eq"><span class="id" type="abbreviation">eq</span></a></span>!) In practice, for functions built up by repeated uses of the
    <span class="inlinecode"><a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a></span> operation, this means that two functions can be proven
    equal only if they were constructed using the <i>same</i> <span class="inlinecode"><a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a></span>
    operations, applied in the same order.  In the theorem above, the
    sequence of updates on the first parameter <span class="inlinecode"><a class="idref" href="Equiv.html#Himp.cequiv"><span class="id" type="definition">cequiv</span></a></span> is one longer
    than for the second parameter, so it is no wonder that the
    equality doesn't hold. 
<div class="paragraph"> </div>

<a name="lab493"></a><h3 class="section"> </h3>
 This problem is actually quite general. If we try to prove other
    simple facts, such as
    cequiv (X ::= X + 1;;
            X ::= X + 1)
           (X ::= X + 2)
    or
    cequiv (X ::= 1;; Y ::= 2)
           (y ::= 2;; X ::= 1)

<div class="paragraph"> </div>

    we'll get stuck in the same way: we'll have two functions that
    behave the same way on all inputs, but cannot be proven to be <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.eq"><span class="id" type="abbreviation">eq</span></a></span>
    to each other.

<div class="paragraph"> </div>

    The reasoning principle we would like to use in these situations
    is called <i>functional extensionality</i>:
                        forall x, f x = g x
<hr/>

                               f = g
    Although this principle is not derivable in Coq's built-in logic,
    it is safe to add it as an additional <i>axiom</i>.  
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Axiom</span> <a name="functional_extensionality"><span class="id" type="axiom">functional_extensionality</span></a> : <span class="id" type="keyword">∀</span> {<span class="id" type="var">X</span> <span class="id" type="var">Y</span>: <span class="id" type="keyword">Type</span>} {<span class="id" type="var">f</span> <span class="id" type="var">g</span> : <a class="idref" href="Equiv.html#X"><span class="id" type="variable">X</span></a> → <a class="idref" href="Equiv.html#Y"><span class="id" type="variable">Y</span></a>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> (<span class="id" type="var">x</span>: <a class="idref" href="Equiv.html#X"><span class="id" type="variable">X</span></a>), <a class="idref" href="Equiv.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="Equiv.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Equiv.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="Equiv.html#x"><span class="id" type="variable">x</span></a>) →  <a class="idref" href="Equiv.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Equiv.html#g"><span class="id" type="variable">g</span></a>.<br/>

<br/>
</div>

<div class="doc">
It can be shown that adding this axiom doesn't introduce any
    inconsistencies into Coq.  (In this way, it is similar to adding
    one of the classical logic axioms, such as <span class="inlinecode"><a class="idref" href="Logic.html#excluded_middle"><span class="id" type="definition">excluded_middle</span></a></span>.) 
<div class="paragraph"> </div>

 With the benefit of this axiom we can prove our theorem.  
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="identity_assignment"><span class="id" type="lemma">identity_assignment</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">X</span>:<a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Equiv.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Equiv.html#X"><span class="id" type="variable">X</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">split</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "-&gt;".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">subst</span>. <span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">replace</span> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <span class="id" type="var">st</span> <span class="id" type="var">X</span> (<span class="id" type="var">st</span> <span class="id" type="var">X</span>)) <span class="id" type="keyword">with</span> <span class="id" type="var">st</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#functional_extensionality"><span class="id" type="axiom">functional_extensionality</span></a>. <span class="id" type="tactic">intro</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <a class="idref" href="Imp.html#update_same"><span class="id" type="axiom">update_same</span></a>; <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "&lt;-".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">st'</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <span class="id" type="var">st'</span> <span class="id" type="var">X</span> (<span class="id" type="var">st'</span> <span class="id" type="var">X</span>)<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#functional_extensionality"><span class="id" type="axiom">functional_extensionality</span></a>. <span class="id" type="tactic">intro</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <a class="idref" href="Imp.html#update_same"><span class="id" type="axiom">update_same</span></a>; <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H0</span> <span class="id" type="tactic">at</span> 2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">constructor</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab494"></a><h4 class="section">Exercise: 2 stars (assign_aequiv)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="assign_aequiv"><span class="id" type="lemma">assign_aequiv</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">X</span> <span class="id" type="var">e</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#aequiv"><span class="id" type="definition">aequiv</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Equiv.html#X"><span class="id" type="variable">X</span></a>) <a class="idref" href="Equiv.html#e"><span class="id" type="variable">e</span></a> → <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a> (<a class="idref" href="Equiv.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Equiv.html#e"><span class="id" type="variable">e</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab495"></a><h1 class="section">Properties of Behavioral Equivalence</h1>

<div class="paragraph"> </div>

 We now turn to developing some of the properties of the program
    equivalences we have defined. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab496"></a><h2 class="section">Behavioral Equivalence is an Equivalence</h2>

<div class="paragraph"> </div>

 First, we verify that the equivalences on <span class="inlinecode"><span class="id" type="var">aexps</span></span>, <span class="inlinecode"><span class="id" type="var">bexps</span></span>, and
    <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.com"><span class="id" type="inductive">com</span></a></span>s really are <i>equivalences</i> -- i.e., that they are reflexive,
    symmetric, and transitive.  The proofs are all easy. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="refl_aequiv"><span class="id" type="lemma">refl_aequiv</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">a</span> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>), <a class="idref" href="Equiv.html#aequiv"><span class="id" type="definition">aequiv</span></a> <a class="idref" href="Equiv.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Equiv.html#a"><span class="id" type="variable">a</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">a</span> <span class="id" type="var">st</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="sym_aequiv"><span class="id" type="lemma">sym_aequiv</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">a1</span> <span class="id" type="var">a2</span> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>), <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#aequiv"><span class="id" type="definition">aequiv</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a> → <a class="idref" href="Equiv.html#aequiv"><span class="id" type="definition">aequiv</span></a> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">st</span>. <span class="id" type="tactic">symmetry</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="trans_aequiv"><span class="id" type="lemma">trans_aequiv</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">a1</span> <span class="id" type="var">a2</span> <span class="id" type="var">a3</span> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>), <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#aequiv"><span class="id" type="definition">aequiv</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a> → <a class="idref" href="Equiv.html#aequiv"><span class="id" type="definition">aequiv</span></a> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a> <a class="idref" href="Equiv.html#a3"><span class="id" type="variable">a3</span></a> → <a class="idref" href="Equiv.html#aequiv"><span class="id" type="definition">aequiv</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Equiv.html#a3"><span class="id" type="variable">a3</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#aequiv"><span class="id" type="definition">aequiv</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span> <span class="id" type="var">a3</span> <span class="id" type="var">H12</span> <span class="id" type="var">H23</span> <span class="id" type="var">st</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">H12</span> <span class="id" type="var">st</span>). <span class="id" type="tactic">rewrite</span> (<span class="id" type="var">H23</span> <span class="id" type="var">st</span>). <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="refl_bequiv"><span class="id" type="lemma">refl_bequiv</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">b</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>), <a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">st</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="sym_bequiv"><span class="id" type="lemma">sym_bequiv</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">b1</span> <span class="id" type="var">b2</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>), <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Equiv.html#b2"><span class="id" type="variable">b2</span></a> → <a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <a class="idref" href="Equiv.html#b2"><span class="id" type="variable">b2</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">st</span>. <span class="id" type="tactic">symmetry</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="trans_bequiv"><span class="id" type="lemma">trans_bequiv</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">b1</span> <span class="id" type="var">b2</span> <span class="id" type="var">b3</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>), <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Equiv.html#b2"><span class="id" type="variable">b2</span></a> → <a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <a class="idref" href="Equiv.html#b2"><span class="id" type="variable">b2</span></a> <a class="idref" href="Equiv.html#b3"><span class="id" type="variable">b3</span></a> → <a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Equiv.html#b3"><span class="id" type="variable">b3</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span> <span class="id" type="var">b3</span> <span class="id" type="var">H12</span> <span class="id" type="var">H23</span> <span class="id" type="var">st</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">H12</span> <span class="id" type="var">st</span>). <span class="id" type="tactic">rewrite</span> (<span class="id" type="var">H23</span> <span class="id" type="var">st</span>). <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="refl_cequiv"><span class="id" type="lemma">refl_cequiv</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">c</span> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a>), <a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">c</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#iff_refl"><span class="id" type="lemma">iff_refl</span></a>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="sym_cequiv"><span class="id" type="lemma">sym_cequiv</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">c1</span> <span class="id" type="var">c2</span> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a>), <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> → <a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span> <span class="id" type="var">H</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">c1</span> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <span class="id" type="var">st</span> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <span class="id" type="var">st'</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <span class="id" type="var">c2</span> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <span class="id" type="var">st</span> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <span class="id" type="var">st'</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">H'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "Proof of assertion". <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#iff_sym"><span class="id" type="lemma">iff_sym</span></a>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="iff_trans"><span class="id" type="lemma">iff_trans</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">P1</span> <span class="id" type="var">P2</span> <span class="id" type="var">P3</span> : <span class="id" type="keyword">Prop</span>), <br/>
&nbsp;&nbsp;(<a class="idref" href="Equiv.html#P1"><span class="id" type="variable">P1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="Equiv.html#P2"><span class="id" type="variable">P2</span></a>) → (<a class="idref" href="Equiv.html#P2"><span class="id" type="variable">P2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="Equiv.html#P3"><span class="id" type="variable">P3</span></a>) → (<a class="idref" href="Equiv.html#P1"><span class="id" type="variable">P1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="Equiv.html#P3"><span class="id" type="variable">P3</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P1</span> <span class="id" type="var">P2</span> <span class="id" type="var">P3</span> <span class="id" type="var">H12</span> <span class="id" type="var">H23</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H12</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H23</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H1</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H0</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H2</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">A</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="trans_cequiv"><span class="id" type="lemma">trans_cequiv</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">c1</span> <span class="id" type="var">c2</span> <span class="id" type="var">c3</span> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a>), <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> → <a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Equiv.html#c3"><span class="id" type="variable">c3</span></a> → <a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#c3"><span class="id" type="variable">c3</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span> <span class="id" type="var">c3</span> <span class="id" type="var">H12</span> <span class="id" type="var">H23</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#iff_trans"><span class="id" type="lemma">iff_trans</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">c2</span> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <span class="id" type="var">st</span> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <span class="id" type="var">st'</span>). <span class="id" type="tactic">apply</span> <span class="id" type="var">H12</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H23</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab497"></a><h2 class="section">Behavioral Equivalence is a Congruence</h2>

<div class="paragraph"> </div>

 Less obviously, behavioral equivalence is also a <i>congruence</i>.
    That is, the equivalence of two subprograms implies the
    equivalence of the larger programs in which they are embedded:
              aequiv a1 a1'
<hr/>

      cequiv (i ::= a1) (i ::= a1')

<div class="paragraph"> </div>

              cequiv c1 c1'    
              cequiv c2 c2'
<hr/>

         cequiv (c1;;c2) (c1';;c2')
    ...and so on.  

<div class="paragraph"> </div>

    (Note that we are using the inference rule notation here not as
    part of a definition, but simply to write down some valid
    implications in a readable format. We prove these implications
    below.) 
<div class="paragraph"> </div>

 We will see a concrete example of why these congruence
    properties are important in the following section (in the proof of
    <span class="inlinecode"><a class="idref" href="Equiv.html#fold_constants_com_sound"><span class="id" type="lemma">fold_constants_com_sound</span></a></span>), but the main idea is that they allow
    us to replace a small part of a large program with an equivalent
    small part and know that the whole large programs are equivalent
    <i>without</i> doing an explicit proof about the non-varying parts --
    i.e., the "proof burden" of a small change to a large program is
    proportional to the size of the change, not the program. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="CAss_congruence"><span class="id" type="lemma">CAss_congruence</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">i</span> <span class="id" type="var">a1</span> <span class="id" type="var">a1'</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#aequiv"><span class="id" type="definition">aequiv</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Equiv.html#a1'"><span class="id" type="variable">a1'</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> (<a class="idref" href="Imp.html#CAss"><span class="id" type="constructor">CAss</span></a> <a class="idref" href="Equiv.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a>) (<a class="idref" href="Imp.html#CAss"><span class="id" type="constructor">CAss</span></a> <a class="idref" href="Equiv.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="Equiv.html#a1'"><span class="id" type="variable">a1'</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">i</span> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span> <span class="id" type="var">Heqv</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">Hceval</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "-&gt;".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">Hceval</span>. <span class="id" type="tactic">subst</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_Ass"><span class="id" type="constructor">E_Ass</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Heqv</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "&lt;-".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">Hceval</span>. <span class="id" type="tactic">subst</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_Ass"><span class="id" type="constructor">E_Ass</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Heqv</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The congruence property for loops is a little more interesting,
    since it requires induction.

<div class="paragraph"> </div>

    <i>Theorem</i>: Equivalence is a congruence for <span class="inlinecode"><span class="id" type="var">WHILE</span></span> -- that is, if
    <span class="inlinecode"><a class="idref" href="Basics.html#b1"><span class="id" type="variable">b1</span></a></span> is equivalent to <span class="inlinecode"><a class="idref" href="Equiv.html#b1'"><span class="id" type="variable">b1'</span></a></span> and <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> is equivalent to <span class="inlinecode"><a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a></span>, then
    <span class="inlinecode"><span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Basics.html#b1"><span class="id" type="variable">b1</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span></span> is equivalent to <span class="inlinecode"><span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Equiv.html#b1'"><span class="id" type="variable">b1'</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span></span>.

<div class="paragraph"> </div>

    <i>Proof</i>: Suppose <span class="inlinecode"><a class="idref" href="Basics.html#b1"><span class="id" type="variable">b1</span></a></span> is equivalent to <span class="inlinecode"><a class="idref" href="Equiv.html#b1'"><span class="id" type="variable">b1'</span></a></span> and <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> is
    equivalent to <span class="inlinecode"><a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a></span>.  We must show, for every <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>, that
    <span class="inlinecode"><span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Basics.html#b1"><span class="id" type="variable">b1</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span> iff <span class="inlinecode"><span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Equiv.html#b1'"><span class="id" type="variable">b1'</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span>
    <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>.  We consider the two directions separately.

<div class="paragraph"> </div>

<ul class="doclist">
<li> (<span class="inlinecode">→</span>) We show that <span class="inlinecode"><span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Basics.html#b1"><span class="id" type="variable">b1</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span> implies
        <span class="inlinecode"><span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Equiv.html#b1'"><span class="id" type="variable">b1'</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>, by induction on a
        derivation of <span class="inlinecode"><span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Basics.html#b1"><span class="id" type="variable">b1</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>.  The only
        nontrivial cases are when the final rule in the derivation is
        <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.E_WhileEnd"><span class="id" type="constructor">E_WhileEnd</span></a></span> or <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.E_WhileLoop"><span class="id" type="constructor">E_WhileLoop</span></a></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.E_WhileEnd"><span class="id" type="constructor">E_WhileEnd</span></a></span>: In this case, the form of the rule gives us
            <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode"><a class="idref" href="Basics.html#b1"><span class="id" type="variable">b1</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>.  But then, since
            <span class="inlinecode"><a class="idref" href="Basics.html#b1"><span class="id" type="variable">b1</span></a></span> and <span class="inlinecode"><a class="idref" href="Equiv.html#b1'"><span class="id" type="variable">b1'</span></a></span> are equivalent, we have <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode"><a class="idref" href="Equiv.html#b1'"><span class="id" type="variable">b1'</span></a></span> <span class="inlinecode">=</span>
            <span class="inlinecode"><a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a></span>, and <span class="inlinecode"><span class="id" type="var">E</span>-<span class="id" type="var">WhileEnd</span></span> applies, giving us <span class="inlinecode"><span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Equiv.html#b1'"><span class="id" type="variable">b1'</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span>
            <span class="inlinecode"><a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>, as required.

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.E_WhileLoop"><span class="id" type="constructor">E_WhileLoop</span></a></span>: The form of the rule now gives us <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span>
            <span class="inlinecode"><a class="idref" href="Basics.html#b1"><span class="id" type="variable">b1</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a></span>, with <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><span class="id" type="var">st'0</span></span> and <span class="inlinecode"><span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Basics.html#b1"><span class="id" type="variable">b1</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span>
            <span class="inlinecode"><span class="id" type="var">END</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><span class="id" type="var">st'0</span></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span> for some state <span class="inlinecode"><span class="id" type="var">st'0</span></span>, with the
            induction hypothesis <span class="inlinecode"><span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Equiv.html#b1'"><span class="id" type="variable">b1'</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><span class="id" type="var">st'0</span></span> <span class="inlinecode">||</span>
            <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>.  

<div class="paragraph"> </div>

            Since <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> and <span class="inlinecode"><a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a></span> are equivalent, we know that <span class="inlinecode"><a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a></span> <span class="inlinecode">/</span>
            <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><span class="id" type="var">st'0</span></span>.  And since <span class="inlinecode"><a class="idref" href="Basics.html#b1"><span class="id" type="variable">b1</span></a></span> and <span class="inlinecode"><a class="idref" href="Equiv.html#b1'"><span class="id" type="variable">b1'</span></a></span> are equivalent, we
            have <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode"><a class="idref" href="Equiv.html#b1'"><span class="id" type="variable">b1'</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a></span>.  Now <span class="inlinecode"><span class="id" type="var">E</span>-<span class="id" type="var">WhileLoop</span></span> applies,
            giving us <span class="inlinecode"><span class="id" type="var">WHILE</span></span> <span class="inlinecode"><a class="idref" href="Equiv.html#b1'"><span class="id" type="variable">b1'</span></a></span> <span class="inlinecode"><span class="id" type="var">DO</span></span> <span class="inlinecode"><a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a></span> <span class="inlinecode"><span class="id" type="var">END</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">||</span> <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span>, as
            required.

<div class="paragraph"> </div>


</li>
</ul>

</li>
<li> (<span class="inlinecode">&lt;-</span>) Similar. <font size=-2>&#9744;</font> 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="CWhile_congruence"><span class="id" type="lemma">CWhile_congruence</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b1</span> <span class="id" type="var">b1'</span> <span class="id" type="var">c1</span> <span class="id" type="var">c1'</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Equiv.html#b1'"><span class="id" type="variable">b1'</span></a> → <a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> (<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>) (<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Equiv.html#b1'"><span class="id" type="variable">b1'</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a>,<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b1</span> <span class="id" type="var">b1'</span> <span class="id" type="var">c1</span> <span class="id" type="var">c1'</span> <span class="id" type="var">Hb1e</span> <span class="id" type="var">Hc1e</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">Hce</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "-&gt;".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <span class="id" type="var">b1</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <span class="id" type="var">c1</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>) <span class="id" type="keyword">as</span> <span class="id" type="var">cwhile</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Heqcwhile</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">Hce</span>; <span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqcwhile</span>; <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "E_WhileEnd".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_WhileEnd"><span class="id" type="constructor">E_WhileEnd</span></a>. <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">Hb1e</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "E_WhileLoop".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_WhileLoop"><span class="id" type="constructor">E_WhileLoop</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">st'</span> := <span class="id" type="var">st'</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SSCase</span> "show loop runs". <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">Hb1e</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SSCase</span> "body execution".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">Hc1e</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>). <span class="id" type="tactic">apply</span> <span class="id" type="var">Hce1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SSCase</span> "subsequent loop execution".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHHce2</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "&lt;-".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <span class="id" type="var">b1'</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <span class="id" type="var">c1'</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>) <span class="id" type="keyword">as</span> <span class="id" type="var">c'while</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Heqc'while</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">Hce</span>; <span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqc'while</span>; <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "E_WhileEnd".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_WhileEnd"><span class="id" type="constructor">E_WhileEnd</span></a>. <span class="id" type="tactic">rewrite</span> → <span class="id" type="var">Hb1e</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "E_WhileLoop".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_WhileLoop"><span class="id" type="constructor">E_WhileLoop</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">st'</span> := <span class="id" type="var">st'</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SSCase</span> "show loop runs". <span class="id" type="tactic">rewrite</span> → <span class="id" type="var">Hb1e</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SSCase</span> "body execution".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">Hc1e</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>). <span class="id" type="tactic">apply</span> <span class="id" type="var">Hce1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SSCase</span> "subsequent loop execution".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHHce2</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab498"></a><h4 class="section">Exercise: 3 stars, optional (CSeq_congruence)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="CSeq_congruence"><span class="id" type="lemma">CSeq_congruence</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">c1</span> <span class="id" type="var">c1'</span> <span class="id" type="var">c2</span> <span class="id" type="var">c2'</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a> → <a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Equiv.html#c2'"><span class="id" type="variable">c2'</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> (<a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a>) (<a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><a class="idref" href="Equiv.html#c2'"><span class="id" type="variable">c2'</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab499"></a><h4 class="section">Exercise: 3 stars (CIf_congruence)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="CIf_congruence"><span class="id" type="lemma">CIf_congruence</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> <span class="id" type="var">b'</span> <span class="id" type="var">c1</span> <span class="id" type="var">c1'</span> <span class="id" type="var">c2</span> <span class="id" type="var">c2'</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Equiv.html#b'"><span class="id" type="variable">b'</span></a> → <a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a> → <a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Equiv.html#c2'"><span class="id" type="variable">c2'</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> (<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a>) (<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Equiv.html#b'"><span class="id" type="variable">b'</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Equiv.html#c1'"><span class="id" type="variable">c1'</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Equiv.html#c2'"><span class="id" type="variable">c2'</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab500"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 For example, here are two equivalent programs and a proof of their
    equivalence... 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="congruence_example"><span class="id" type="definition">congruence_example</span></a>:<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0<a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0)<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 42<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0<a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0)<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>)   <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 42<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#CSeq_congruence"><span class="id" type="axiom">CSeq_congruence</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#refl_cequiv"><span class="id" type="lemma">refl_cequiv</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#CIf_congruence"><span class="id" type="axiom">CIf_congruence</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#refl_bequiv"><span class="id" type="lemma">refl_bequiv</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#CAss_congruence"><span class="id" type="lemma">CAss_congruence</span></a>. <span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#aequiv"><span class="id" type="definition">aequiv</span></a>. <span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">symmetry</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.Minus.html#minus_diag"><span class="id" type="lemma">minus_diag</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#refl_cequiv"><span class="id" type="lemma">refl_cequiv</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab501"></a><h1 class="section">Program Transformations</h1>

<div class="paragraph"> </div>

 A <i>program transformation</i> is a function that takes a program
    as input and produces some variant of the program as its
    output.  Compiler optimizations such as constant folding are
    a canonical example, but there are many others. 
<div class="paragraph"> </div>

 A program transformation is <i>sound</i> if it preserves the
    behavior of the original program. 

<div class="paragraph"> </div>

    We can define a notion of soundness for translations of
    <span class="inlinecode"><a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a></span>s, <span class="inlinecode"><a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a></span>s, and <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.com"><span class="id" type="inductive">com</span></a></span>s. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="atrans_sound"><span class="id" type="definition">atrans_sound</span></a> (<span class="id" type="var">atrans</span> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">a</span> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#aequiv"><span class="id" type="definition">aequiv</span></a> <a class="idref" href="Equiv.html#a"><span class="id" type="variable">a</span></a> (<a class="idref" href="Equiv.html#atrans"><span class="id" type="variable">atrans</span></a> <a class="idref" href="Equiv.html#a"><span class="id" type="variable">a</span></a>).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="btrans_sound"><span class="id" type="definition">btrans_sound</span></a> (<span class="id" type="var">btrans</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a> → <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">b</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> (<a class="idref" href="Equiv.html#btrans"><span class="id" type="variable">btrans</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a>).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="ctrans_sound"><span class="id" type="definition">ctrans_sound</span></a> (<span class="id" type="var">ctrans</span> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">c</span> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a> (<a class="idref" href="Equiv.html#ctrans"><span class="id" type="variable">ctrans</span></a> <a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab502"></a><h2 class="section">The Constant-Folding Transformation</h2>

<div class="paragraph"> </div>

 An expression is <i>constant</i> when it contains no variable
    references.

<div class="paragraph"> </div>

    Constant folding is an optimization that finds constant
    expressions and replaces them by their values. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> (<span class="id" type="var">a</span> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>) : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Equiv.html#a"><span class="id" type="variable">a</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n</span>       ⇒ <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <span class="id" type="var">i</span>        ⇒ <a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <span class="id" type="var">i</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span>  ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <span class="id" type="var">a1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <span class="id" type="var">a2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> (<span class="id" type="var">n1</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <span class="id" type="var">n2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a1'</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <span class="id" type="var">a2'</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> <span class="id" type="var">a1'</span> <span class="id" type="var">a2'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <span class="id" type="var">a1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <span class="id" type="var">a2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> (<span class="id" type="var">n1</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'-'_x"><span class="id" type="notation">-</span></a> <span class="id" type="var">n2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a1'</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <span class="id" type="var">a2'</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> <span class="id" type="var">a1'</span> <span class="id" type="var">a2'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#AMult"><span class="id" type="constructor">AMult</span></a> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span>  ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <span class="id" type="var">a1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <span class="id" type="var">a2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> (<span class="id" type="var">n1</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <span class="id" type="var">n2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a1'</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <span class="id" type="var">a2'</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <a class="idref" href="Imp.html#AMult"><span class="id" type="constructor">AMult</span></a> <span class="id" type="var">a1'</span> <span class="id" type="var">a2'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="fold_aexp_ex1"><span class="id" type="definition">fold_aexp_ex1</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#AMult"><span class="id" type="constructor">AMult</span></a> (<a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 2)) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>)) <br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#AMult"><span class="id" type="constructor">AMult</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 3) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>).<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Note that this version of constant folding doesn't eliminate
    trivial additions, etc. -- we are focusing attention on a single
    optimization for the sake of simplicity.  It is not hard to
    incorporate other ways of simplifying expressions; the definitions
    and proofs just get longer. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="fold_aexp_ex2"><span class="id" type="definition">fold_aexp_ex2</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AMult"><span class="id" type="constructor">AMult</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 6)) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>)))<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>)).<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab503"></a><h3 class="section"> </h3>
 Not only can we lift <span class="inlinecode"><a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a></span> to <span class="inlinecode"><a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a></span>s (in the
    <span class="inlinecode"><a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#BLe"><span class="id" type="constructor">BLe</span></a></span> cases), we can also find constant <i>boolean</i>
    expressions and reduce them in-place. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a> (<span class="id" type="var">b</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a>        ⇒ <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a>       ⇒ <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span>  ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <span class="id" type="var">a1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <span class="id" type="var">a2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <span class="id" type="keyword">if</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.EqNat.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n1</span> <span class="id" type="var">n2</span> <span class="id" type="keyword">then</span> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a1'</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <span class="id" type="var">a2'</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> <span class="id" type="var">a1'</span> <span class="id" type="var">a2'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#BLe"><span class="id" type="constructor">BLe</span></a> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span>  ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <span class="id" type="var">a1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <span class="id" type="var">a2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <span class="id" type="keyword">if</span> <a class="idref" href="SfLib.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> <span class="id" type="var">n1</span> <span class="id" type="var">n2</span> <span class="id" type="keyword">then</span> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">a1'</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <span class="id" type="var">a2'</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <a class="idref" href="Imp.html#BLe"><span class="id" type="constructor">BLe</span></a> <span class="id" type="var">a1'</span> <span class="id" type="var">a2'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> <span class="id" type="var">b1</span>  ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<a class="idref" href="Equiv.html#fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a> <span class="id" type="var">b1</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> ⇒ <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a> ⇒ <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">b1'</span> ⇒ <a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> <span class="id" type="var">b1'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#BAnd"><span class="id" type="constructor">BAnd</span></a> <span class="id" type="var">b1</span> <span class="id" type="var">b2</span>  ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a> <span class="id" type="var">b1</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="Equiv.html#fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a> <span class="id" type="var">b2</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">(</span></a><span class="id" type="var">b1'</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">,</span></a> <span class="id" type="var">b2'</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#:core_scope:'('_x_','_x_','_'..'_','_x_')'"><span class="id" type="notation">)</span></a> ⇒ <a class="idref" href="Imp.html#BAnd"><span class="id" type="constructor">BAnd</span></a> <span class="id" type="var">b1'</span> <span class="id" type="var">b2'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="fold_bexp_ex1"><span class="id" type="definition">fold_bexp_ex1</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a> (<a class="idref" href="Imp.html#BAnd"><span class="id" type="constructor">BAnd</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> (<a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BAnd"><span class="id" type="constructor">BAnd</span></a> <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a>)))<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="fold_bexp_ex2"><span class="id" type="definition">fold_bexp_ex2</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#BAnd"><span class="id" type="constructor">BAnd</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>)) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 2) (<a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)))))<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#BAnd"><span class="id" type="constructor">BAnd</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>)) <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab504"></a><h3 class="section"> </h3>
 To fold constants in a command, we apply the appropriate folding
    functions on all embedded expressions. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="fold_constants_com"><span class="id" type="definition">fold_constants_com</span></a> (<span class="id" type="var">c</span> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a>) : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a>      ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a><br/>
&nbsp;&nbsp;| <span class="id" type="var">i</span> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <span class="id" type="var">a</span>  ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#CAss"><span class="id" type="constructor">CAss</span></a> <span class="id" type="var">i</span> (<a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <span class="id" type="var">a</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">c1</span> <a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <span class="id" type="var">c2</span>  ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#fold_constants_com"><span class="id" type="definition">fold_constants_com</span></a> <span class="id" type="var">c1</span><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#fold_constants_com"><span class="id" type="definition">fold_constants_com</span></a> <span class="id" type="var">c2</span><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <span class="id" type="var">b</span> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <span class="id" type="var">c1</span> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <span class="id" type="var">c2</span> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Equiv.html#fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a> <span class="id" type="var">b</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> ⇒ <a class="idref" href="Equiv.html#fold_constants_com"><span class="id" type="definition">fold_constants_com</span></a> <span class="id" type="var">c1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a> ⇒ <a class="idref" href="Equiv.html#fold_constants_com"><span class="id" type="definition">fold_constants_com</span></a> <span class="id" type="var">c2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">b'</span> ⇒ <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <span class="id" type="var">b'</span> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Equiv.html#fold_constants_com"><span class="id" type="definition">fold_constants_com</span></a> <span class="id" type="var">c1</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Equiv.html#fold_constants_com"><span class="id" type="definition">fold_constants_com</span></a> <span class="id" type="var">c2</span> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <span class="id" type="var">b</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <span class="id" type="var">c</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Equiv.html#fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a> <span class="id" type="var">b</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> ⇒ <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Imp.html#BFalse"><span class="id" type="constructor">BFalse</span></a> ⇒ <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">b'</span> ⇒ <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <span class="id" type="var">b'</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#fold_constants_com"><span class="id" type="definition">fold_constants_com</span></a> <a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a><a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">)</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab505"></a><h3 class="section"> </h3>

</div>
<div class="code">
<span class="id" type="keyword">Example</span> <a name="fold_com_ex1"><span class="id" type="definition">fold_com_ex1</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#fold_constants_com"><span class="id" type="definition">fold_constants_com</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 4) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 5)<a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 3)<a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>)) (<a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 2) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 4)) <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Imp.html#BLe"><span class="id" type="constructor">BLe</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0) (<a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 4) (<a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 2) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1))) <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0) <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>) <br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 9<a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 3)<a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>)) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 6) <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">)</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0<a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0) <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab506"></a><h2 class="section">Soundness of Constant Folding</h2>

<div class="paragraph"> </div>

 Now we need to show that what we've done is correct. 
<div class="paragraph"> </div>

 Here's the proof for arithmetic expressions: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="fold_constants_aexp_sound"><span class="id" type="lemma">fold_constants_aexp_sound</span></a> : <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#atrans_sound"><span class="id" type="definition">atrans_sound</span></a> <a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#atrans_sound"><span class="id" type="definition">atrans_sound</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">a</span>. <span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#aequiv"><span class="id" type="definition">aequiv</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">st</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">aexp_cases</span> (<span class="id" type="tactic">induction</span> <span class="id" type="var">a</span>) <span class="id" type="var">Case</span>; <span class="id" type="tactic">simpl</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="tactic">reflexivity</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> (<span class="id" type="tactic">destruct</span> (<a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <span class="id" type="var">a1</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <span class="id" type="var">a2</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa1</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHa2</span>; <span class="id" type="tactic">reflexivity</span>). <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab507"></a><h4 class="section">Exercise: 3 stars, optional (fold_bexp_Eq_informal)</h4>
 Here is an informal proof of the <span class="inlinecode"><a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a></span> case of the soundness
    argument for boolean expression constant folding.  Read it
    carefully and compare it to the formal proof that follows.  Then
    fill in the <span class="inlinecode"><a class="idref" href="Imp.html#BLe"><span class="id" type="constructor">BLe</span></a></span> case of the formal proof (without looking at the
    <span class="inlinecode"><a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a></span> case, if possible).

<div class="paragraph"> </div>

   <i>Theorem</i>: The constant folding function for booleans,
   <span class="inlinecode"><a class="idref" href="Equiv.html#fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a></span>, is sound.

<div class="paragraph"> </div>

   <i>Proof</i>: We must show that <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> is equivalent to <span class="inlinecode"><a class="idref" href="Equiv.html#fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a></span>,
   for all boolean expressions <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span>.  Proceed by induction on <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span>.  We
   show just the case where <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> has the form <span class="inlinecode"><a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a></span>.

<div class="paragraph"> </div>

   In this case, we must show 
       beval st (BEq a1 a2) 
     = beval st (fold_constants_bexp (BEq a1 a2)).
   There are two cases to consider:

<div class="paragraph"> </div>

<ul class="doclist">
<li> First, suppose <span class="inlinecode"><a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a></span> <span class="inlinecode"><a class="idref" href="Prop.html#n1"><span class="id" type="variable">n1</span></a></span> and
       <span class="inlinecode"><a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a></span> <span class="inlinecode"><a class="idref" href="Prop.html#n2"><span class="id" type="variable">n2</span></a></span> for some <span class="inlinecode"><a class="idref" href="Prop.html#n1"><span class="id" type="variable">n1</span></a></span> and <span class="inlinecode"><a class="idref" href="Prop.html#n2"><span class="id" type="variable">n2</span></a></span>.

<div class="paragraph"> </div>

       In this case, we have
           fold_constants_bexp (BEq a1 a2) 
         = if beq_nat n1 n2 then BTrue else BFalse
       and
           beval st (BEq a1 a2) 
         = beq_nat (aeval st a1) (aeval st a2).
       By the soundness of constant folding for arithmetic
       expressions (Lemma <span class="inlinecode"><a class="idref" href="Equiv.html#fold_constants_aexp_sound"><span class="id" type="lemma">fold_constants_aexp_sound</span></a></span>), we know
           aeval st a1 
         = aeval st (fold_constants_aexp a1) 
         = aeval st (ANum n1) 
         = n1
       and
           aeval st a2 
         = aeval st (fold_constants_aexp a2) 
         = aeval st (ANum n2) 
         = n2,
       so
           beval st (BEq a1 a2) 
         = beq_nat (aeval a1) (aeval a2)
         = beq_nat n1 n2.
       Also, it is easy to see (by considering the cases <span class="inlinecode"><a class="idref" href="Prop.html#n1"><span class="id" type="variable">n1</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Prop.html#n2"><span class="id" type="variable">n2</span></a></span> and
       <span class="inlinecode"><a class="idref" href="Prop.html#n1"><span class="id" type="variable">n1</span></a></span> <span class="inlinecode">≠</span> <span class="inlinecode"><a class="idref" href="Prop.html#n2"><span class="id" type="variable">n2</span></a></span> separately) that
           beval st (if beq_nat n1 n2 then BTrue else BFalse)
         = if beq_nat n1 n2 then beval st BTrue else beval st BFalse
         = if beq_nat n1 n2 then true else false
         = beq_nat n1 n2.
       So
           beval st (BEq a1 a2) 
         = beq_nat n1 n2.
         = beval st (if beq_nat n1 n2 then BTrue else BFalse),

</li>
</ul>
]]         
       as required.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Otherwise, one of <span class="inlinecode"><a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a></span> and
       <span class="inlinecode"><a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a></span> is not a constant.  In this case, we
       must show
           beval st (BEq a1 a2) 
         = beval st (BEq (fold_constants_aexp a1)
                         (fold_constants_aexp a2)),
       which, by the definition of <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span>, is the same as showing
           beq_nat (aeval st a1) (aeval st a2) 
         = beq_nat (aeval st (fold_constants_aexp a1))
                   (aeval st (fold_constants_aexp a2)).
       But the soundness of constant folding for arithmetic
       expressions (<span class="inlinecode"><a class="idref" href="Equiv.html#fold_constants_aexp_sound"><span class="id" type="lemma">fold_constants_aexp_sound</span></a></span>) gives us
         aeval st a1 = aeval st (fold_constants_aexp a1)
         aeval st a2 = aeval st (fold_constants_aexp a2),
       completing the case.  <font size=-2>&#9744;</font>

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="fold_constants_bexp_sound"><span class="id" type="lemma">fold_constants_bexp_sound</span></a>: <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#btrans_sound"><span class="id" type="definition">btrans_sound</span></a> <a class="idref" href="Equiv.html#fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#btrans_sound"><span class="id" type="definition">btrans_sound</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">b</span>. <span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">st</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">bexp_cases</span> (<span class="id" type="tactic">induction</span> <span class="id" type="var">b</span>) <span class="id" type="var">Case</span>; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "BEq".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rename</span> <span class="id" type="var">a</span> <span class="id" type="var">into</span> <span class="id" type="var">a1</span>. <span class="id" type="tactic">rename</span> <span class="id" type="var">a0</span> <span class="id" type="var">into</span> <span class="id" type="var">a2</span>. <span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <span class="id" type="var">a1</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">a1'</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Heqa1'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="Equiv.html#fold_constants_aexp"><span class="id" type="definition">fold_constants_aexp</span></a> <span class="id" type="var">a2</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">a2'</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Heqa2'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">replace</span> (<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <span class="id" type="var">st</span> <span class="id" type="var">a1</span>) <span class="id" type="keyword">with</span> (<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <span class="id" type="var">st</span> <span class="id" type="var">a1'</span>) <span class="id" type="tactic">by</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">subst</span> <span class="id" type="var">a1'</span>; <span class="id" type="tactic">rewrite</span> &lt;- <a class="idref" href="Equiv.html#fold_constants_aexp_sound"><span class="id" type="lemma">fold_constants_aexp_sound</span></a>; <span class="id" type="tactic">reflexivity</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">replace</span> (<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <span class="id" type="var">st</span> <span class="id" type="var">a2</span>) <span class="id" type="keyword">with</span> (<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <span class="id" type="var">st</span> <span class="id" type="var">a2'</span>) <span class="id" type="tactic">by</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">subst</span> <span class="id" type="var">a2'</span>; <span class="id" type="tactic">rewrite</span> &lt;- <a class="idref" href="Equiv.html#fold_constants_aexp_sound"><span class="id" type="lemma">fold_constants_aexp_sound</span></a>; <span class="id" type="tactic">reflexivity</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">a1'</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">a2'</span>; <span class="id" type="tactic">try</span> <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">destruct</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.EqNat.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">n0</span>); <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "BLe".<br/>
 <span class="id" type="var">admit</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "BNot".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="var">remember</span> (<a class="idref" href="Equiv.html#fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a> <span class="id" type="var">b</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">b'</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Heqb'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">b'</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "BAnd".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="Equiv.html#fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a> <span class="id" type="var">b1</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">b1'</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Heqb1'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="Equiv.html#fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a> <span class="id" type="var">b2</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">b2'</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Heqb2'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHb1</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHb2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">b1'</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">b2'</span>; <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab508"></a><h4 class="section">Exercise: 3 stars (fold_constants_com_sound)</h4>
 Complete the <span class="inlinecode"><span class="id" type="var">WHILE</span></span> case of the following proof. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="fold_constants_com_sound"><span class="id" type="lemma">fold_constants_com_sound</span></a> : <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#ctrans_sound"><span class="id" type="definition">ctrans_sound</span></a> <a class="idref" href="Equiv.html#fold_constants_com"><span class="id" type="definition">fold_constants_com</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#ctrans_sound"><span class="id" type="definition">ctrans_sound</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">c</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">com_cases</span> (<span class="id" type="tactic">induction</span> <span class="id" type="var">c</span>) <span class="id" type="var">Case</span>; <span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "SKIP". <span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#refl_cequiv"><span class="id" type="lemma">refl_cequiv</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "::=". <span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#CAss_congruence"><span class="id" type="lemma">CAss_congruence</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#fold_constants_aexp_sound"><span class="id" type="lemma">fold_constants_aexp_sound</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> ";;". <span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#CSeq_congruence"><span class="id" type="axiom">CSeq_congruence</span></a>; <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "IFB".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<a class="idref" href="Equiv.html#bequiv"><span class="id" type="definition">bequiv</span></a> <span class="id" type="var">b</span> (<a class="idref" href="Equiv.html#fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a> <span class="id" type="var">b</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "Pf of assertion". <span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#fold_constants_bexp_sound"><span class="id" type="lemma">fold_constants_bexp_sound</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<a class="idref" href="Equiv.html#fold_constants_bexp"><span class="id" type="definition">fold_constants_bexp</span></a> <span class="id" type="var">b</span>) <span class="id" type="var">eqn</span>:<span class="id" type="var">Heqb</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> (<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#CIf_congruence"><span class="id" type="axiom">CIf_congruence</span></a>; <span class="id" type="tactic">assumption</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "b always true".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#trans_cequiv"><span class="id" type="lemma">trans_cequiv</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">c1</span>; <span class="id" type="tactic">try</span> <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#IFB_true"><span class="id" type="lemma">IFB_true</span></a>; <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">SCase</span> "b always false".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#trans_cequiv"><span class="id" type="lemma">trans_cequiv</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">c2</span>; <span class="id" type="tactic">try</span> <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#IFB_false"><span class="id" type="axiom">IFB_false</span></a>; <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "WHILE".<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab509"></a><h3 class="section">Soundness of (0 + n) Elimination, Redux</h3>

<div class="paragraph"> </div>

<a name="lab510"></a><h4 class="section">Exercise: 4 stars, advanced, optional (optimize_0plus)</h4>
 Recall the definition <span class="inlinecode"><a class="idref" href="Imp.html#AExp.optimize_0plus"><span class="id" type="definition">optimize_0plus</span></a></span> from Imp.v:
    Fixpoint optimize_0plus (e:aexp) : aexp := 
      match e with
      | ANum n =&gt; 
          ANum n
      | APlus (ANum 0) e2 =&gt; 
          optimize_0plus e2
      | APlus e1 e2 =&gt; 
          APlus (optimize_0plus e1) (optimize_0plus e2)
      | AMinus e1 e2 =&gt; 
          AMinus (optimize_0plus e1) (optimize_0plus e2)
      | AMult e1 e2 =&gt; 
          AMult (optimize_0plus e1) (optimize_0plus e2)
      end.
   Note that this function is defined over the old <span class="inlinecode"><a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a></span>s,
   without states.

<div class="paragraph"> </div>

   Write a new version of this function that accounts for variables,
   and analogous ones for <span class="inlinecode"><a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a></span>s and commands:
     optimize_0plus_aexp
     optimize_0plus_bexp
     optimize_0plus_com
   Prove that these three functions are sound, as we did for
   <span class="inlinecode"><span class="id" type="var">fold_constants_</span>×</span>.  (Make sure you use the congruence lemmas in
   the proof of <span class="inlinecode"><span class="id" type="var">optimize_0plus_com</span></span> -- otherwise it will be <i>long</i>!)

<div class="paragraph"> </div>

   Then define an optimizer on commands that first folds
   constants (using <span class="inlinecode"><a class="idref" href="Equiv.html#fold_constants_com"><span class="id" type="definition">fold_constants_com</span></a></span>) and then eliminates <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span>
   terms (using <span class="inlinecode"><span class="id" type="var">optimize_0plus_com</span></span>).

<div class="paragraph"> </div>

<ul class="doclist">
<li> Give a meaningful example of this optimizer's output.

<div class="paragraph"> </div>


</li>
<li> Prove that the optimizer is sound.  (This part should be <i>very</i>
     easy.)  
</li>
</ul>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab511"></a><h1 class="section">Proving That Programs Are <i>Not</i> Equivalent</h1>

<div class="paragraph"> </div>

 Suppose that <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> is a command of the form <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">::=</span> <span class="inlinecode"><a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a>;;</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">::=</span> <span class="inlinecode"><a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a></span>
    and <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> is the command <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">::=</span> <span class="inlinecode"><a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a>;;</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">::=</span> <span class="inlinecode"><a class="idref" href="Smallstep.html#a2'"><span class="id" type="variable">a2'</span></a></span>, where <span class="inlinecode"><a class="idref" href="Smallstep.html#a2'"><span class="id" type="variable">a2'</span></a></span> is
    formed by substituting <span class="inlinecode"><a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a></span> for all occurrences of <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> in <span class="inlinecode"><a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a></span>.
    For example, <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> and <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> might be:
       c1  =  (X ::= 42 + 53;; 
               Y ::= Y + X)
       c2  =  (X ::= 42 + 53;; 
               Y ::= Y + (42 + 53))
    Clearly, this <i>particular</i> <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> and <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> are equivalent.  Is this
    true in general? 
<div class="paragraph"> </div>

 We will see in a moment that it is not, but it is worthwhile
    to pause, now, and see if you can find a counter-example on your
    own. 
<div class="paragraph"> </div>

 Here, formally, is the function that substitutes an arithmetic
    expression for each occurrence of a given variable in another
    expression: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <a name="subst_aexp"><span class="id" type="definition">subst_aexp</span></a> (<span class="id" type="var">i</span> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a>) (<span class="id" type="var">u</span> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>) (<span class="id" type="var">a</span> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>) : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="Equiv.html#a"><span class="id" type="variable">a</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n</span>       ⇒ <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <span class="id" type="var">n</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <span class="id" type="var">i'</span>       ⇒ <span class="id" type="keyword">if</span> <a class="idref" href="SfLib.html#eq_id_dec"><span class="id" type="lemma">eq_id_dec</span></a> <a class="idref" href="Equiv.html#i"><span class="id" type="variable">i</span></a> <span class="id" type="var">i'</span> <span class="id" type="keyword">then</span> <a class="idref" href="Equiv.html#u"><span class="id" type="variable">u</span></a> <span class="id" type="keyword">else</span> <a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <span class="id" type="var">i'</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span>  ⇒ <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Equiv.html#subst_aexp"><span class="id" type="definition">subst_aexp</span></a> <a class="idref" href="Equiv.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="Equiv.html#u"><span class="id" type="variable">u</span></a> <span class="id" type="var">a1</span>) (<a class="idref" href="Equiv.html#subst_aexp"><span class="id" type="definition">subst_aexp</span></a> <a class="idref" href="Equiv.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="Equiv.html#u"><span class="id" type="variable">u</span></a> <span class="id" type="var">a2</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span> ⇒ <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Equiv.html#subst_aexp"><span class="id" type="definition">subst_aexp</span></a> <a class="idref" href="Equiv.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="Equiv.html#u"><span class="id" type="variable">u</span></a> <span class="id" type="var">a1</span>) (<a class="idref" href="Equiv.html#subst_aexp"><span class="id" type="definition">subst_aexp</span></a> <a class="idref" href="Equiv.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="Equiv.html#u"><span class="id" type="variable">u</span></a> <span class="id" type="var">a2</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="Imp.html#AMult"><span class="id" type="constructor">AMult</span></a> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span>  ⇒ <a class="idref" href="Imp.html#AMult"><span class="id" type="constructor">AMult</span></a> (<a class="idref" href="Equiv.html#subst_aexp"><span class="id" type="definition">subst_aexp</span></a> <a class="idref" href="Equiv.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="Equiv.html#u"><span class="id" type="variable">u</span></a> <span class="id" type="var">a1</span>) (<a class="idref" href="Equiv.html#subst_aexp"><span class="id" type="definition">subst_aexp</span></a> <a class="idref" href="Equiv.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="Equiv.html#u"><span class="id" type="variable">u</span></a> <span class="id" type="var">a2</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="subst_aexp_ex"><span class="id" type="definition">subst_aexp_ex</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#subst_aexp"><span class="id" type="definition">subst_aexp</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> (<a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 42) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 53)) (<a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>)) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>) (<a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 42) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 53))<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
And here is the property we are interested in, expressing the
    claim that commands <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> and <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> as described above are
    always equivalent.  
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="subst_equiv_property"><span class="id" type="definition">subst_equiv_property</span></a> := <span class="id" type="keyword">∀</span> <span class="id" type="var">i1</span> <span class="id" type="var">i2</span> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> (<a class="idref" href="Equiv.html#i1"><span class="id" type="variable">i1</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Equiv.html#i2"><span class="id" type="variable">i2</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Equiv.html#i1"><span class="id" type="variable">i1</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Equiv.html#i2"><span class="id" type="variable">i2</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Equiv.html#subst_aexp"><span class="id" type="definition">subst_aexp</span></a> <a class="idref" href="Equiv.html#i1"><span class="id" type="variable">i1</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a name="lab512"></a><h3 class="section"> </h3>
 Sadly, the property does <i>not</i> always hold. 

<div class="paragraph"> </div>

    <i>Theorem</i>: It is not the case that, for all <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.i1"><span class="id" type="abbreviation">i1</span></a></span>, <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.i2"><span class="id" type="abbreviation">i2</span></a></span>, <span class="inlinecode"><a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a></span>,
    and <span class="inlinecode"><a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a></span>,
         cequiv (i1 ::= a1;; i2 ::= a2)
                (i1 ::= a1;; i2 ::= subst_aexp i1 a1 a2).
]] 
    <i>Proof</i>: Suppose, for a contradiction, that for all <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.i1"><span class="id" type="abbreviation">i1</span></a></span>, <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.i2"><span class="id" type="abbreviation">i2</span></a></span>,
    <span class="inlinecode"><a class="idref" href="Imp.html#a1"><span class="id" type="variable">a1</span></a></span>, and <span class="inlinecode"><a class="idref" href="Imp.html#a2"><span class="id" type="variable">a2</span></a></span>, we have
      cequiv (i1 ::= a1;; i2 ::= a2) 
             (i1 ::= a1;; i2 ::= subst_aexp i1 a1 a2).
    Consider the following program:
         X ::= APlus (AId X) (ANum 1);; Y ::= AId X
    Note that
         (X ::= APlus (AId X) (ANum 1);; Y ::= AId X)
         / empty_state || st1,
    where <span class="inlinecode"><a class="idref" href="Imp.html#st1"><span class="id" type="variable">st1</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">{</span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">|-&gt;</span> <span class="inlinecode">1,</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">|-&gt;</span> <span class="inlinecode">1</span> <span class="inlinecode">}</span>.

<div class="paragraph"> </div>

    By our assumption, we know that
        cequiv (X ::= APlus (AId X) (ANum 1);; Y ::= AId X)
               (X ::= APlus (AId X) (ANum 1);; Y ::= APlus (AId X) (ANum 1))
    so, by the definition of <span class="inlinecode"><a class="idref" href="Equiv.html#Himp.cequiv"><span class="id" type="definition">cequiv</span></a></span>, we have
        (X ::= APlus (AId X) (ANum 1);; Y ::= APlus (AId X) (ANum 1))
        / empty_state || st1.
    But we can also derive
        (X ::= APlus (AId X) (ANum 1);; Y ::= APlus (AId X) (ANum 1))
        / empty_state || st2,
    where <span class="inlinecode"><a class="idref" href="Imp.html#st2"><span class="id" type="variable">st2</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">{</span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">|-&gt;</span> <span class="inlinecode">1,</span> <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">|-&gt;</span> <span class="inlinecode">2</span> <span class="inlinecode">}</span>.  Note that <span class="inlinecode"><a class="idref" href="Imp.html#st1"><span class="id" type="variable">st1</span></a></span> <span class="inlinecode">≠</span> <span class="inlinecode"><a class="idref" href="Imp.html#st2"><span class="id" type="variable">st2</span></a></span>; this
    is a contradiction, since <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.ceval"><span class="id" type="inductive">ceval</span></a></span> is deterministic!  <font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="subst_inequiv"><span class="id" type="lemma">subst_inequiv</span></a> : <br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#subst_equiv_property"><span class="id" type="definition">subst_equiv_property</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#subst_equiv_property"><span class="id" type="definition">subst_equiv_property</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">Contra</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">as</span> <span class="id" type="var">c1</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">as</span> <span class="id" type="var">c2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span>) <span class="id" type="tactic">by</span> (<span class="id" type="tactic">subst</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Contra</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> 1) <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> 1) <span class="id" type="keyword">as</span> <span class="id" type="var">st1</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> 1) <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> 2) <span class="id" type="keyword">as</span> <span class="id" type="var">st2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">H1</span>: <span class="id" type="var">c1</span> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <span class="id" type="var">st1</span>);<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">H2</span>: <span class="id" type="var">c2</span> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <span class="id" type="var">st2</span>);<br/>
&nbsp;&nbsp;<span class="id" type="tactic">try</span> (<span class="id" type="tactic">subst</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_Seq"><span class="id" type="constructor">E_Seq</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">st'</span> := (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> 1)); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_Ass"><span class="id" type="constructor">E_Ass</span></a>; <span class="id" type="tactic">reflexivity</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H1</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hcontra</span>: <span class="id" type="var">st1</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">st2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">by</span> (<span class="id" type="tactic">apply</span> (<a class="idref" href="Imp.html#ceval_deterministic"><span class="id" type="lemma">ceval_deterministic</span></a> <span class="id" type="var">c2</span> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a>); <span class="id" type="tactic">assumption</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hcontra'</span>: <span class="id" type="var">st1</span> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <span class="id" type="var">st2</span> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">by</span> (<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hcontra</span>; <span class="id" type="tactic">reflexivity</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">subst</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">Hcontra'</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab513"></a><h4 class="section">Exercise: 4 stars, optional (better_subst_equiv)</h4>
 The equivalence we had in mind above was not complete nonsense --
    it was actually almost right.  To make it correct, we just need to
    exclude the case where the variable <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> occurs in the
    right-hand-side of the first assignment statement. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a> (<span class="id" type="var">X</span>:<a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a>) : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="VNUNum"><span class="id" type="constructor">VNUNum</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span>, <a class="idref" href="Equiv.html#var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a> <span class="id" type="var">X</span> (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> <a class="idref" href="Equiv.html#n"><span class="id" type="variable">n</span></a>)<br/>
&nbsp;&nbsp;| <a name="VNUId"><span class="id" type="constructor">VNUId</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">Y</span>, <span class="id" type="var">X</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<>'_x"><span class="id" type="notation">≠</span></a> <a class="idref" href="Equiv.html#Y"><span class="id" type="variable">Y</span></a> → <a class="idref" href="Equiv.html#var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a> <span class="id" type="var">X</span> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Equiv.html#Y"><span class="id" type="variable">Y</span></a>)<br/>
&nbsp;&nbsp;| <a name="VNUPlus"><span class="id" type="constructor">VNUPlus</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a> <span class="id" type="var">X</span> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a> <span class="id" type="var">X</span> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a> <span class="id" type="var">X</span> (<a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a>)<br/>
&nbsp;&nbsp;| <a name="VNUMinus"><span class="id" type="constructor">VNUMinus</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a> <span class="id" type="var">X</span> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a> <span class="id" type="var">X</span> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a> <span class="id" type="var">X</span> (<a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a>)<br/>
&nbsp;&nbsp;| <a name="VNUMult"><span class="id" type="constructor">VNUMult</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a> <span class="id" type="var">X</span> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a> <span class="id" type="var">X</span> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a> <span class="id" type="var">X</span> (<a class="idref" href="Imp.html#AMult"><span class="id" type="constructor">AMult</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a>).<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="aeval_weakening"><span class="id" type="lemma">aeval_weakening</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">i</span> <span class="id" type="var">st</span> <span class="id" type="var">a</span> <span class="id" type="var">ni</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a> <a class="idref" href="Equiv.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="Equiv.html#a"><span class="id" type="variable">a</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#i"><span class="id" type="variable">i</span></a> <a class="idref" href="Equiv.html#ni"><span class="id" type="variable">ni</span></a>) <a class="idref" href="Equiv.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#a"><span class="id" type="variable">a</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Using <span class="inlinecode"><a class="idref" href="Equiv.html#var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a></span>, formalize and prove a correct verson
    of <span class="inlinecode"><a class="idref" href="Equiv.html#subst_equiv_property"><span class="id" type="definition">subst_equiv_property</span></a></span>. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab514"></a><h4 class="section">Exercise: 3 stars, optional (inequiv_exercise)</h4>
 Prove that an infinite loop is not equivalent to <span class="inlinecode"><span class="id" type="var">SKIP</span></span> 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="inequiv_exercise"><span class="id" type="lemma">inequiv_exercise</span></a>: <br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> (<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>) <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab515"></a><h1 class="section">Extended exercise: Non-deterministic Imp</h1>

<div class="paragraph"> </div>

 As we have seen (in theorem <span class="inlinecode"><a class="idref" href="UseAuto.html#DeterministicImp.ceval_deterministic"><span class="id" type="lemma">ceval_deterministic</span></a></span> in the Imp
    chapter), Imp's evaluation relation is deterministic.  However,
    <i>non</i>-determinism is an important part of the definition of many
    real programming languages. For example, in many imperative
    languages (such as C and its relatives), the order in which
    function arguments are evaluated is unspecified.  The program
    fragment
      x = 0;;
      f(++x, x)
    might call <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.f"><span class="id" type="abbreviation">f</span></a></span> with arguments <span class="inlinecode">(1,</span> <span class="inlinecode">0)</span> or <span class="inlinecode">(1,</span> <span class="inlinecode">1)</span>, depending how
    the compiler chooses to order things.  This can be a little
    confusing for programmers, but it gives the compiler writer useful
    freedom.

<div class="paragraph"> </div>

    In this exercise, we will extend Imp with a simple
    non-deterministic command and study how this change affects
    program equivalence.  The new command has the syntax <span class="inlinecode"><span class="id" type="var">HAVOC</span></span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span>,
    where <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> is an identifier. The effect of executing <span class="inlinecode"><span class="id" type="var">HAVOC</span></span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> is
    to assign an <i>arbitrary</i> number to the variable <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span>,
    non-deterministically. For example, after executing the program:
      HAVOC Y;;
      Z ::= Y * 2
    the value of <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> can be any number, while the value of <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> is
    twice that of <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> (so <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> is always even). Note that we are not
    saying anything about the <i>probabilities</i> of the outcomes -- just
    that there are (infinitely) many different outcomes that can
    possibly happen after executing this non-deterministic code.

<div class="paragraph"> </div>

    In a sense a variable on which we do <span class="inlinecode"><span class="id" type="var">HAVOC</span></span> roughly corresponds
    to an unitialized variable in the C programming language. After
    the <span class="inlinecode"><span class="id" type="var">HAVOC</span></span> the variable holds a fixed but arbitrary number.  Most
    sources of nondeterminism in language definitions are there
    precisely because programmers don't care which choice is made (and
    so it is good to leave it open to the compiler to choose whichever
    will run faster).

<div class="paragraph"> </div>

    We call this new language <i>Himp</i> (``Imp extended with <span class="inlinecode"><span class="id" type="var">HAVOC</span></span>''). 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Module</span> <a name="Himp"><span class="id" type="module">Himp</span></a>.<br/>

<br/>
</div>

<div class="doc">
To formalize the language, we first add a clause to the definition of
   commands. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="Himp.com"><span class="id" type="inductive">com</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="Himp.CSkip"><span class="id" type="constructor">CSkip</span></a> : <a class="idref" href="Equiv.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.CAss"><span class="id" type="constructor">CAss</span></a> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Equiv.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.CSeq"><span class="id" type="constructor">CSeq</span></a> : <a class="idref" href="Equiv.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Equiv.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Equiv.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.CIf"><span class="id" type="constructor">CIf</span></a> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a> → <a class="idref" href="Equiv.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Equiv.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Equiv.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.CWhile"><span class="id" type="constructor">CWhile</span></a> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a> → <a class="idref" href="Equiv.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Equiv.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.CHavoc"><span class="id" type="constructor">CHavoc</span></a> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a> → <a class="idref" href="Equiv.html#com"><span class="id" type="inductive">com</span></a>. 
<br/>
<span class="id" type="keyword">Tactic Notation</span> "com_cases" <span class="id" type="var">tactic</span>(<span class="id" type="tactic">first</span>) <span class="id" type="var">ident</span>(<span class="id" type="var">c</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span>;<br/>
&nbsp;&nbsp;[ <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "SKIP" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "::=" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> ";;"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "IFB" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "WHILE" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "HAVOC" ].<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name="Himp.::'SKIP'"><span class="id" type="notation">"</span></a>'SKIP'" :=<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.CSkip"><span class="id" type="constructor">CSkip</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="Himp.::x_'::='_x"><span class="id" type="notation">"</span></a>X '::=' a" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Equiv.html#Himp.CAss"><span class="id" type="constructor">CAss</span></a> <span class="id" type="var">X</span> <span class="id" type="var">a</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 60).<br/>
<span class="id" type="keyword">Notation</span> <a name="Himp.::x_';;'_x"><span class="id" type="notation">"</span></a>c1 ;; c2" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Equiv.html#Himp.CSeq"><span class="id" type="constructor">CSeq</span></a> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">"</span></a>'WHILE' b 'DO' c 'END'" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Equiv.html#Himp.CWhile"><span class="id" type="constructor">CWhile</span></a> <span class="id" type="var">b</span> <span class="id" type="var">c</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">"</span></a>'IFB' e1 'THEN' e2 'ELSE' e3 'FI'" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Equiv.html#Himp.CIf"><span class="id" type="constructor">CIf</span></a> <span class="id" type="var">e1</span> <span class="id" type="var">e2</span> <span class="id" type="var">e3</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="Himp.::'HAVOC'_x"><span class="id" type="notation">"</span></a>'HAVOC' l" := (<a class="idref" href="Equiv.html#Himp.CHavoc"><span class="id" type="constructor">CHavoc</span></a> <span class="id" type="var">l</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 60).<br/>

<br/>
</div>

<div class="doc">
<a name="lab516"></a><h4 class="section">Exercise: 2 stars (himp_ceval)</h4>
 Now, we must extend the operational semantics. We have provided
   a template for the <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.ceval"><span class="id" type="inductive">ceval</span></a></span> relation below, specifying the big-step
   semantics. What rule(s) must be added to the definition of <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.ceval"><span class="id" type="inductive">ceval</span></a></span>
   to formalize the behavior of the <span class="inlinecode"><span class="id" type="var">HAVOC</span></span> command? 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Reserved Notation</span> "c1 '/' st '||' st'" (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 40, <span class="id" type="var">st</span> <span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 39).<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <a name="Himp.ceval"><span class="id" type="inductive">ceval</span></a> : <a class="idref" href="Equiv.html#Himp.com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> → <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="Himp.E_Skip"><span class="id" type="constructor">E_Skip</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>, <a class="idref" href="Equiv.html#Himp.::'SKIP'"><span class="id" type="notation">SKIP</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.E_Ass"><span class="id" type="constructor">E_Ass</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">a1</span> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>) (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">X</span> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Equiv.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Equiv.html#Himp.::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a><a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Equiv.html#n"><span class="id" type="variable">n</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.E_Seq"><span class="id" type="constructor">E_Seq</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">c1</span> <span class="id" type="var">c2</span> : <a class="idref" href="Equiv.html#Himp.com"><span class="id" type="inductive">com</span></a>) (<span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">st''</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a> → <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st''"><span class="id" type="variable">st''</span></a> → <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#Himp.::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a><a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st''"><span class="id" type="variable">st''</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.E_IfTrue"><span class="id" type="constructor">E_IfTrue</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> <span class="id" type="var">st'</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">b1</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) (<span class="id" type="var">c1</span> <span class="id" type="var">c2</span> : <a class="idref" href="Equiv.html#Himp.com"><span class="id" type="inductive">com</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a> → <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Equiv.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Equiv.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a><a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.E_IfFalse"><span class="id" type="constructor">E_IfFalse</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> <span class="id" type="var">st'</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">b1</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) (<span class="id" type="var">c1</span> <span class="id" type="var">c2</span> : <a class="idref" href="Equiv.html#Himp.com"><span class="id" type="inductive">com</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a> → <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Equiv.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Equiv.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a><a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.E_WhileEnd"><span class="id" type="constructor">E_WhileEnd</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">b1</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">c1</span> : <a class="idref" href="Equiv.html#Himp.com"><span class="id" type="inductive">com</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> → <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.E_WhileLoop"><span class="id" type="constructor">E_WhileLoop</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">st''</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">b1</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) (<span class="id" type="var">c1</span> : <a class="idref" href="Equiv.html#Himp.com"><span class="id" type="inductive">com</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st''"><span class="id" type="variable">st''</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Equiv.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st''"><span class="id" type="variable">st''</span></a><br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="id" type="keyword">where</span> <a name="Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">"</span></a>c1 '/' st '||' st'" := (<a class="idref" href="Equiv.html#ceval"><span class="id" type="inductive">ceval</span></a> <span class="id" type="var">c1</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>).<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "ceval_cases" <span class="id" type="var">tactic</span>(<span class="id" type="tactic">first</span>) <span class="id" type="var">ident</span>(<span class="id" type="var">c</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span>;<br/>
&nbsp;&nbsp;[ <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_Skip" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_Ass" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_Seq"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_IfTrue" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_IfFalse"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_WhileEnd" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_WhileLoop"<br/>
<br/>
].<br/>

<br/>
</div>

<div class="doc">
As a sanity check, the following claims should be provable for
   your definition: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="Himp.havoc_example1"><span class="id" type="definition">havoc_example1</span></a> : <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a><a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> 0.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Example</span> <a name="Himp.havoc_example2"><span class="id" type="definition">havoc_example2</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#Himp.::'SKIP'"><span class="id" type="notation">SKIP</span></a><a class="idref" href="Equiv.html#Himp.::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Equiv.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a><a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> 42.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Finally, we repeat the definition of command equivalence from above: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="Himp.cequiv"><span class="id" type="definition">cequiv</span></a> (<span class="id" type="var">c1</span> <span class="id" type="var">c2</span> : <a class="idref" href="Equiv.html#Himp.com"><span class="id" type="inductive">com</span></a>) : <span class="id" type="keyword">Prop</span> := <span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a>.<br/>

<br/>
</div>

<div class="doc">
This definition still makes perfect sense in the case of always
    terminating programs, so let's apply it to prove some
    non-deterministic programs equivalent or non-equivalent. 
<div class="paragraph"> </div>

<a name="lab517"></a><h4 class="section">Exercise: 3 stars (havoc_swap)</h4>
 Are the following two programs equivalent? 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="Himp.pXY"><span class="id" type="definition">pXY</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a><a class="idref" href="Equiv.html#Himp.::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Equiv.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="Himp.pYX"><span class="id" type="definition">pYX</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a><a class="idref" href="Equiv.html#Himp.::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Equiv.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>.<br/>

<br/>
</div>

<div class="doc">
If you think they are equivalent, prove it. If you think they are
    not, prove that. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="Himp.pXY_cequiv_pYX"><span class="id" type="lemma">pXY_cequiv_pYX</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#Himp.pXY"><span class="id" type="definition">pXY</span></a> <a class="idref" href="Equiv.html#Himp.pYX"><span class="id" type="definition">pYX</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="Equiv.html#Himp.cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#Himp.pXY"><span class="id" type="definition">pXY</span></a> <a class="idref" href="Equiv.html#Himp.pYX"><span class="id" type="definition">pYX</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.  <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab518"></a><h4 class="section">Exercise: 4 stars, optional (havoc_copy)</h4>
 Are the following two programs equivalent? 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="Himp.ptwice"><span class="id" type="definition">ptwice</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a><a class="idref" href="Equiv.html#Himp.::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Equiv.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="Himp.pcopy"><span class="id" type="definition">pcopy</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a><a class="idref" href="Equiv.html#Himp.::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Equiv.html#Himp.::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>.<br/>

<br/>
</div>

<div class="doc">
If you think they are equivalent, then prove it. If you think they
    are not, then prove that.  (Hint: You may find the <span class="inlinecode"><span class="id" type="tactic">assert</span></span> tactic
    useful.) 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="Himp.ptwice_cequiv_pcopy"><span class="id" type="lemma">ptwice_cequiv_pcopy</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#Himp.ptwice"><span class="id" type="definition">ptwice</span></a> <a class="idref" href="Equiv.html#Himp.pcopy"><span class="id" type="definition">pcopy</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a><a class="idref" href="Equiv.html#Himp.cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#Himp.ptwice"><span class="id" type="definition">ptwice</span></a> <a class="idref" href="Equiv.html#Himp.pcopy"><span class="id" type="definition">pcopy</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.  <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 The definition of program equivalence we are using here has some
    subtle consequences on programs that may loop forever.  What
    <span class="inlinecode"><a class="idref" href="Equiv.html#Himp.cequiv"><span class="id" type="definition">cequiv</span></a></span> says is that the set of possible <i>terminating</i> outcomes
    of two equivalent programs is the same. However, in a language
    with non-determinism, like Himp, some programs always terminate,
    some programs always diverge, and some programs can
    non-deterministically terminate in some runs and diverge in
    others. The final part of the following exercise illustrates this
    phenomenon.

<div class="paragraph"> </div>

<a name="lab519"></a><h4 class="section">Exercise: 5 stars, advanced (p1_p2_equiv)</h4>
 Prove that p1 and p2 are equivalent. In this and the following
    exercises, try to understand why the <span class="inlinecode"><a class="idref" href="Equiv.html#Himp.cequiv"><span class="id" type="definition">cequiv</span></a></span> definition has the
    behavior it has on these examples. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="Himp.p1"><span class="id" type="definition">p1</span></a> : <a class="idref" href="Equiv.html#Himp.com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0))<a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">)</span></a> <a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a><a class="idref" href="Equiv.html#Himp.::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Equiv.html#Himp.::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="Himp.p2"><span class="id" type="definition">p2</span></a> : <a class="idref" href="Equiv.html#Himp.com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0))<a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">)</span></a> <a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'SKIP'"><span class="id" type="notation">SKIP</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>.<br/>

<br/>
</div>

<div class="doc">
Intuitively, the programs have the same termination
    behavior: either they loop forever, or they terminate in the
    same state they started in.  We can capture the termination
    behavior of p1 and p2 individually with these lemmas: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="Himp.p1_may_diverge"><span class="id" type="lemma">p1_may_diverge</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>, <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<>'_x"><span class="id" type="notation">≠</span></a> 0 →<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#Himp.p1"><span class="id" type="definition">p1</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.  <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="Himp.p2_may_diverge"><span class="id" type="lemma">p2_may_diverge</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>, <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<>'_x"><span class="id" type="notation">≠</span></a> 0 →<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#Himp.p2"><span class="id" type="definition">p2</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
You should use these lemmas to prove that p1 and p2 are actually
    equivalent. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="Himp.p1_p2_equiv"><span class="id" type="lemma">p1_p2_equiv</span></a> : <a class="idref" href="Equiv.html#Himp.cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#Himp.p1"><span class="id" type="definition">p1</span></a> <a class="idref" href="Equiv.html#Himp.p2"><span class="id" type="definition">p2</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.  <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab520"></a><h4 class="section">Exercise: 4 stars, advanced (p3_p4_inquiv)</h4>

<div class="paragraph"> </div>

 Prove that the following programs are <i>not</i> equivalent. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="Himp.p3"><span class="id" type="definition">p3</span></a> : <a class="idref" href="Equiv.html#Himp.com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="Equiv.html#Himp.::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1<a class="idref" href="Equiv.html#Himp.::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0))<a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">)</span></a> <a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a><a class="idref" href="Equiv.html#Himp.::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="Himp.p4"><span class="id" type="definition">p4</span></a> : <a class="idref" href="Equiv.html#Himp.com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Equiv.html#Himp.::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Equiv.html#Himp.::x_'::='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0<a class="idref" href="Equiv.html#Himp.::x_'::='_x"><span class="id" type="notation">)</span></a><a class="idref" href="Equiv.html#Himp.::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="Equiv.html#Himp.::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Equiv.html#Himp.::x_'::='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1<a class="idref" href="Equiv.html#Himp.::x_'::='_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="Himp.p3_p4_inequiv"><span class="id" type="lemma">p3_p4_inequiv</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#Himp.cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#Himp.p3"><span class="id" type="definition">p3</span></a> <a class="idref" href="Equiv.html#Himp.p4"><span class="id" type="definition">p4</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.  <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab521"></a><h4 class="section">Exercise: 5 stars, advanced, optional (p5_p6_equiv)</h4>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="Himp.p5"><span class="id" type="definition">p5</span></a> : <a class="idref" href="Equiv.html#Himp.com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1))<a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">)</span></a> <a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="Himp.p6"><span class="id" type="definition">p6</span></a> : <a class="idref" href="Equiv.html#Himp.com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Equiv.html#Himp.::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="Himp.p5_p6_equiv"><span class="id" type="lemma">p5_p6_equiv</span></a> : <a class="idref" href="Equiv.html#Himp.cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#Himp.p5"><span class="id" type="definition">p5</span></a> <a class="idref" href="Equiv.html#Himp.p6"><span class="id" type="definition">p6</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.  <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Equiv.html#Himp"><span class="id" type="module">Himp</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab522"></a><h1 class="section">Doing Without Extensionality (Advanced)</h1>

<div class="paragraph"> </div>

 Purists might object to using the <span class="inlinecode"><a class="idref" href="Equiv.html#functional_extensionality"><span class="id" type="axiom">functional_extensionality</span></a></span>
    axiom.  In general, it can be quite dangerous to add axioms,
    particularly several at once (as they may be mutually
    inconsistent). In fact, <span class="inlinecode"><a class="idref" href="Equiv.html#functional_extensionality"><span class="id" type="axiom">functional_extensionality</span></a></span> and
    <span class="inlinecode"><a class="idref" href="Logic.html#excluded_middle"><span class="id" type="definition">excluded_middle</span></a></span> can both be assumed without any problems, but
    some Coq users prefer to avoid such "heavyweight" general
    techniques, and instead craft solutions for specific problems that
    stay within Coq's standard logic.

<div class="paragraph"> </div>

    For our particular problem here, rather than extending the
    definition of equality to do what we want on functions
    representing states, we could instead give an explicit notion of
    <i>equivalence</i> on states.  For example: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="stequiv"><span class="id" type="definition">stequiv</span></a> (<span class="id" type="var">st1</span> <span class="id" type="var">st2</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">X</span>:<a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a>), <a class="idref" href="Equiv.html#st1"><span class="id" type="variable">st1</span></a> <a class="idref" href="Equiv.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Equiv.html#st2"><span class="id" type="variable">st2</span></a> <a class="idref" href="Equiv.html#X"><span class="id" type="variable">X</span></a>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name="::x_'~'_x"><span class="id" type="notation">"</span></a>st1 '~' st2" := (<a class="idref" href="Equiv.html#stequiv"><span class="id" type="definition">stequiv</span></a> <span class="id" type="var">st1</span> <span class="id" type="var">st2</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 30).<br/>

<br/>
</div>

<div class="doc">
It is easy to prove that <span class="inlinecode"><a class="idref" href="Equiv.html#stequiv"><span class="id" type="definition">stequiv</span></a></span> is an <i>equivalence</i> (i.e., it
   is reflexive, symmetric, and transitive), so it partitions the set
   of all states into equivalence classes. 
<div class="paragraph"> </div>

<a name="lab523"></a><h4 class="section">Exercise: 1 star, optional (stequiv_refl)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="stequiv_refl"><span class="id" type="lemma">stequiv_refl</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>), <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#::x_'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab524"></a><h4 class="section">Exercise: 1 star, optional (stequiv_sym)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="stequiv_sym"><span class="id" type="lemma">stequiv_sym</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st1</span> <span class="id" type="var">st2</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>), <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#st1"><span class="id" type="variable">st1</span></a> <a class="idref" href="Equiv.html#::x_'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#st2"><span class="id" type="variable">st2</span></a> → <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#st2"><span class="id" type="variable">st2</span></a> <a class="idref" href="Equiv.html#::x_'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#st1"><span class="id" type="variable">st1</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab525"></a><h4 class="section">Exercise: 1 star, optional (stequiv_trans)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="stequiv_trans"><span class="id" type="lemma">stequiv_trans</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st1</span> <span class="id" type="var">st2</span> <span class="id" type="var">st3</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>), <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#st1"><span class="id" type="variable">st1</span></a> <a class="idref" href="Equiv.html#::x_'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#st2"><span class="id" type="variable">st2</span></a> → <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#st2"><span class="id" type="variable">st2</span></a> <a class="idref" href="Equiv.html#::x_'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#st3"><span class="id" type="variable">st3</span></a> → <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#st1"><span class="id" type="variable">st1</span></a> <a class="idref" href="Equiv.html#::x_'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#st3"><span class="id" type="variable">st3</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Another useful fact... <a name="lab526"></a><h4 class="section">Exercise: 1 star, optional (stequiv_update)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="stequiv_update"><span class="id" type="lemma">stequiv_update</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st1</span> <span class="id" type="var">st2</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#st1"><span class="id" type="variable">st1</span></a> <a class="idref" href="Equiv.html#::x_'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#st2"><span class="id" type="variable">st2</span></a> → <br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">X</span>:<a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a>) (<span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Equiv.html#st1"><span class="id" type="variable">st1</span></a> <a class="idref" href="Equiv.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Equiv.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="Equiv.html#::x_'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Equiv.html#st2"><span class="id" type="variable">st2</span></a> <a class="idref" href="Equiv.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Equiv.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 It is then straightforward to show that <span class="inlinecode"><a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a></span> behave
    uniformly on all members of an equivalence class: 
<div class="paragraph"> </div>

<a name="lab527"></a><h4 class="section">Exercise: 2 stars, optional (stequiv_aeval)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="stequiv_aeval"><span class="id" type="lemma">stequiv_aeval</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st1</span> <span class="id" type="var">st2</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>), <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#st1"><span class="id" type="variable">st1</span></a> <a class="idref" href="Equiv.html#::x_'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#st2"><span class="id" type="variable">st2</span></a> →<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">a</span>:<a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>), <a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Equiv.html#st1"><span class="id" type="variable">st1</span></a> <a class="idref" href="Equiv.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Equiv.html#st2"><span class="id" type="variable">st2</span></a> <a class="idref" href="Equiv.html#a"><span class="id" type="variable">a</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab528"></a><h4 class="section">Exercise: 2 stars, optional (stequiv_beval)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Lemma</span> <a name="stequiv_beval"><span class="id" type="lemma">stequiv_beval</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st1</span> <span class="id" type="var">st2</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>), <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#st1"><span class="id" type="variable">st1</span></a> <a class="idref" href="Equiv.html#::x_'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#st2"><span class="id" type="variable">st2</span></a> →<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">b</span>:<a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>), <a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Equiv.html#st1"><span class="id" type="variable">st1</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Equiv.html#st2"><span class="id" type="variable">st2</span></a> <a class="idref" href="Equiv.html#b"><span class="id" type="variable">b</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 We can also characterize the behavior of <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.ceval"><span class="id" type="inductive">ceval</span></a></span> on equivalent
    states (this result is a bit more complicated to write down
    because <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.ceval"><span class="id" type="inductive">ceval</span></a></span> is a relation). 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="stequiv_ceval"><span class="id" type="lemma">stequiv_ceval</span></a>: <span class="id" type="keyword">∀</span> (<span class="id" type="var">st1</span> <span class="id" type="var">st2</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#st1"><span class="id" type="variable">st1</span></a> <a class="idref" href="Equiv.html#::x_'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#st2"><span class="id" type="variable">st2</span></a> →<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">c</span>: <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a>) (<span class="id" type="var">st1'</span>: <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st1"><span class="id" type="variable">st1</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st1'"><span class="id" type="variable">st1'</span></a>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <span class="id" type="var">st2'</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st2"><span class="id" type="variable">st2</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st2'"><span class="id" type="variable">st2'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a>  <a class="idref" href="Equiv.html#st1'"><span class="id" type="variable">st1'</span></a> <a class="idref" href="Equiv.html#::x_'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#st2'"><span class="id" type="variable">st2'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st1</span> <span class="id" type="var">st2</span> <span class="id" type="var">STEQV</span> <span class="id" type="var">c</span> <span class="id" type="var">st1'</span> <span class="id" type="var">CEV1</span>. <span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">st2</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">CEV1</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">st2</span> <span class="id" type="var">STEQV</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "SKIP".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">∃</span> <span class="id" type="var">st2</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> ":=".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">∃</span> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <span class="id" type="var">st2</span> <span class="id" type="var">x</span> <span class="id" type="var">n</span>). <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">constructor</span>. <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">H</span>. <span class="id" type="tactic">symmetry</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#stequiv_aeval"><span class="id" type="axiom">stequiv_aeval</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#stequiv_update"><span class="id" type="axiom">stequiv_update</span></a>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> ";".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">IHCEV1_1</span> <span class="id" type="var">st2</span> <span class="id" type="var">STEQV</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">st2'</span> [<span class="id" type="var">P1</span> <span class="id" type="var">EQV1</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">IHCEV1_2</span> <span class="id" type="var">st2'</span> <span class="id" type="var">EQV1</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">st2''</span> [<span class="id" type="var">P2</span> <span class="id" type="var">EQV2</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">∃</span> <span class="id" type="var">st2''</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_Seq"><span class="id" type="constructor">E_Seq</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">st2'</span>;  <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "IfTrue".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">IHCEV1</span> <span class="id" type="var">st2</span> <span class="id" type="var">STEQV</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">st2'</span> [<span class="id" type="var">P</span> <span class="id" type="var">EQV</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">∃</span> <span class="id" type="var">st2'</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_IfTrue"><span class="id" type="constructor">E_IfTrue</span></a>. <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">H</span>. <span class="id" type="tactic">symmetry</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#stequiv_beval"><span class="id" type="axiom">stequiv_beval</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "IfFalse".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">IHCEV1</span> <span class="id" type="var">st2</span> <span class="id" type="var">STEQV</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">st2'</span> [<span class="id" type="var">P</span> <span class="id" type="var">EQV</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">∃</span> <span class="id" type="var">st2'</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_IfFalse"><span class="id" type="constructor">E_IfFalse</span></a>. <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">H</span>. <span class="id" type="tactic">symmetry</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#stequiv_beval"><span class="id" type="axiom">stequiv_beval</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "WhileEnd".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">∃</span> <span class="id" type="var">st2</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_WhileEnd"><span class="id" type="constructor">E_WhileEnd</span></a>. <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">H</span>. <span class="id" type="tactic">symmetry</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#stequiv_beval"><span class="id" type="axiom">stequiv_beval</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "WhileLoop".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">IHCEV1_1</span> <span class="id" type="var">st2</span> <span class="id" type="var">STEQV</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">st2'</span> [<span class="id" type="var">P1</span> <span class="id" type="var">EQV1</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">IHCEV1_2</span> <span class="id" type="var">st2'</span> <span class="id" type="var">EQV1</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">st2''</span> [<span class="id" type="var">P2</span> <span class="id" type="var">EQV2</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">∃</span> <span class="id" type="var">st2''</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#E_WhileLoop"><span class="id" type="constructor">E_WhileLoop</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">st2'</span>. <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">H</span>. <span class="id" type="tactic">symmetry</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#stequiv_beval"><span class="id" type="axiom">stequiv_beval</span></a>. <span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Now we need to redefine <span class="inlinecode"><a class="idref" href="Equiv.html#Himp.cequiv"><span class="id" type="definition">cequiv</span></a></span> to use <span class="inlinecode">¬</span> instead of <span class="inlinecode">=</span>.  It is
    not completely trivial to do this in a way that keeps the
    definition simple and symmetric, but here is one approach (thanks
    to Andrew McCreight). We first define a looser variant of <span class="inlinecode">||</span>
    that "folds in" the notion of equivalence. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Reserved Notation</span> "c1 '/' st '||'' st'" (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 40, <span class="id" type="var">st</span> <span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 39).<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <a name="ceval'"><span class="id" type="inductive">ceval'</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> → <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="E_equiv"><span class="id" type="constructor">E_equiv</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">c</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">st''</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a> → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a> <a class="idref" href="Equiv.html#::x_'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="Equiv.html#st''"><span class="id" type="variable">st''</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Equiv.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Equiv.html#::x_'/'_x_'||'''_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#::x_'/'_x_'||'''_x"><span class="id" type="notation">||'</span></a> <a class="idref" href="Equiv.html#st''"><span class="id" type="variable">st''</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">where</span>   <a name="::x_'/'_x_'||'''_x"><span class="id" type="notation">"</span></a>c1 '/' st '||'' st'" := (<a class="idref" href="Equiv.html#ceval'"><span class="id" type="inductive">ceval'</span></a> <span class="id" type="var">c1</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>).<br/>

<br/>
</div>

<div class="doc">
Now the revised definition of <span class="inlinecode"><a class="idref" href="Equiv.html#cequiv'"><span class="id" type="definition">cequiv'</span></a></span> looks familiar: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="cequiv'"><span class="id" type="definition">cequiv'</span></a> (<span class="id" type="var">c1</span> <span class="id" type="var">c2</span> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> <span class="id" type="var">st'</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#::x_'/'_x_'||'''_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#::x_'/'_x_'||'''_x"><span class="id" type="notation">||'</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Equiv.html#::x_'/'_x_'||'''_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Equiv.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Equiv.html#::x_'/'_x_'||'''_x"><span class="id" type="notation">||'</span></a> <a class="idref" href="Equiv.html#st'"><span class="id" type="variable">st'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">)</span></a>.<br/>

<br/>
</div>

<div class="doc">
A sanity check shows that the original notion of command
   equivalence is at least as strong as this new one.  (The converse
   is not true, naturally.) 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="cequiv__cequiv'"><span class="id" type="lemma">cequiv__cequiv'</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">c1</span> <span class="id" type="var">c2</span>: <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a> → <a class="idref" href="Equiv.html#cequiv'"><span class="id" type="definition">cequiv'</span></a> <a class="idref" href="Equiv.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Equiv.html#c2"><span class="id" type="variable">c2</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a>, <a class="idref" href="Equiv.html#cequiv'"><span class="id" type="definition">cequiv'</span></a>; <span class="id" type="tactic">split</span>; <span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H0</span> ; <span class="id" type="tactic">subst</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#E_equiv"><span class="id" type="constructor">E_equiv</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">st'0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">H</span> <span class="id" type="var">st</span> <span class="id" type="var">st'0</span>); <span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H0</span> ; <span class="id" type="tactic">subst</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#E_equiv"><span class="id" type="constructor">E_equiv</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">st'0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">H</span> <span class="id" type="var">st</span> <span class="id" type="var">st'0</span>). <span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab529"></a><h4 class="section">Exercise: 2 stars, optional (identity_assignment')</h4>
 Finally, here is our example once more... (You can complete the
    proof.) 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="identity_assignment'"><span class="id" type="definition">identity_assignment'</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv'"><span class="id" type="definition">cequiv'</span></a> <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a> (<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#cequiv'"><span class="id" type="definition">cequiv'</span></a>. <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">split</span>; <span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "-&gt;".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H0</span>; <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#E_equiv"><span class="id" type="constructor">E_equiv</span></a> <span class="id" type="keyword">with</span> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <span class="id" type="var">st'0</span> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> (<span class="id" type="var">st'0</span> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">constructor</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Equiv.html#stequiv_trans"><span class="id" type="axiom">stequiv_trans</span></a> <span class="id" type="keyword">with</span> <span class="id" type="var">st'0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Equiv.html#stequiv"><span class="id" type="definition">stequiv</span></a>. <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Imp.html#update_same"><span class="id" type="axiom">update_same</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Case</span> "&lt;-".<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 On the whole, this explicit equivalence approach is considerably
    harder to work with than relying on functional
    extensionality. (Coq does have an advanced mechanism called
    "setoids" that makes working with equivalences somewhat easier, by
    allowing them to be registered with the system so that standard
    rewriting tactics work for them almost as well as for equalities.)
    But it is worth knowing about, because it applies even in
    situations where the equivalence in question is <i>not</i> over
    functions.  For example, if we chose to represent state mappings
    as binary search trees, we would need to use an explicit
    equivalence of this kind. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab530"></a><h1 class="section">Additional Exercises</h1>

<div class="paragraph"> </div>

<a name="lab531"></a><h4 class="section">Exercise: 4 stars, optional (for_while_equiv)</h4>
 This exercise extends the optional <span class="inlinecode"><span class="id" type="var">add_for_loop</span></span> exercise from
    Imp.v, where you were asked to extend the language of commands
    with C-style <span class="inlinecode"><span class="id" type="keyword">for</span></span> loops.  Prove that the command:
      for (c1 ; b ; c2) {
          c3
      }
    is equivalent to:
       c1 ; 
       WHILE b DO
         c3 ;
         c2
       END

</div>
<div class="code">
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab532"></a><h4 class="section">Exercise: 3 stars, optional (swap_noninterfering_assignments)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Theorem</span> <a name="swap_noninterfering_assignments"><span class="id" type="lemma">swap_noninterfering_assignments</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span> <span class="id" type="var">a1</span> <span class="id" type="var">a2</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#l1"><span class="id" type="variable">l1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'<>'_x"><span class="id" type="notation">≠</span></a> <a class="idref" href="Equiv.html#l2"><span class="id" type="variable">l2</span></a> → <br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a> <a class="idref" href="Equiv.html#l1"><span class="id" type="variable">l1</span></a> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#var_not_used_in_aexp"><span class="id" type="inductive">var_not_used_in_aexp</span></a> <a class="idref" href="Equiv.html#l2"><span class="id" type="variable">l2</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Equiv.html#cequiv"><span class="id" type="definition">cequiv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Equiv.html#l1"><span class="id" type="variable">l1</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Equiv.html#l2"><span class="id" type="variable">l2</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Equiv.html#l2"><span class="id" type="variable">l2</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Equiv.html#a2"><span class="id" type="variable">a2</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Equiv.html#l1"><span class="id" type="variable">l1</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Equiv.html#a1"><span class="id" type="variable">a1</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>