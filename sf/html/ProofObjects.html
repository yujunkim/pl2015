<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>ProofObjects</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library ProofObjects</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab321"></a><h1 class="section">ProofObjects: Working with Explicit Evidence in Coq</h1>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="MoreLogic.html#"><span class="id" type="library">MoreLogic</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
 We have seen that Coq has mechanisms both for <i>programming</i>,
    using inductive data types (like <span class="inlinecode"><a class="idref" href="Poly.html#Church.nat"><span class="id" type="definition">nat</span></a></span> or <span class="inlinecode"><a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a></span>) and functions
    over these types, and for <i>proving</i> properties of these programs,
    using inductive propositions (like <span class="inlinecode"><a class="idref" href="SfLib.html#ev"><span class="id" type="inductive">ev</span></a></span> or <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.eq"><span class="id" type="abbreviation">eq</span></a></span>), implication, and 
    universal quantification.  So far, we have treated these mechanisms
    as if they were quite separate, and for many purposes this is
    a good way to think. But we have also seen hints that Coq's programming and 
    proving facilities are closely related. For example, the
    keyword <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> is used to declare both data types and 
    propositions, and <span class="inlinecode">→</span> is used both to describe the type of
    functions on data and logical implication. This is not just a
    syntactic accident!  In fact, programs and proofs in Coq are almost
    the same thing.  In this chapter we will study how this works.

<div class="paragraph"> </div>

    We have already seen the fundamental idea: provability in Coq is
    represented by concrete <i>evidence</i>.  When we construct the proof
    of a basic proposition, we are actually building a tree of evidence, 
    which can be thought of as a data structure. If the proposition
    is an implication like <span class="inlinecode"><a class="idref" href="RecordSub.html#Examples.A"><span class="id" type="abbreviation">A</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="RecordSub.html#Examples.B"><span class="id" type="abbreviation">B</span></a></span>, then its proof will be an 
    evidence <i>transformer</i>: a recipe for converting evidence for
    A into evidence for B.  So at a fundamental level, proofs are simply
    programs that manipulate evidence.

<div class="paragraph"> </div>

    Q. If evidence is data, what are propositions themselves?

<div class="paragraph"> </div>

    A. They are types!

<div class="paragraph"> </div>

    Look again at the formal definition of the <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span> property.  
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">beautiful</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab322"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 The trick is to introduce an alternative pronunciation of "<span class="inlinecode">:</span>".
    Instead of "has type," we can also say "is a proof of."  For
    example, the second line in the definition of <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span> declares
    that <span class="inlinecode"><a class="idref" href="Prop.html#b_0"><span class="id" type="constructor">b_0</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span> <span class="inlinecode">0</span>.  Instead of "<span class="inlinecode"><a class="idref" href="Prop.html#b_0"><span class="id" type="constructor">b_0</span></a></span> has type 
    <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span> <span class="inlinecode">0</span>," we can say that "<span class="inlinecode"><a class="idref" href="Prop.html#b_0"><span class="id" type="constructor">b_0</span></a></span> is a proof of <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span> <span class="inlinecode">0</span>."
    Similarly for <span class="inlinecode"><a class="idref" href="Prop.html#b_3"><span class="id" type="constructor">b_3</span></a></span> and <span class="inlinecode"><a class="idref" href="Prop.html#b_5"><span class="id" type="constructor">b_5</span></a></span>. 
<div class="paragraph"> </div>

<a name="lab323"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 This pun between types and propositions (between <span class="inlinecode">:</span> as "has type"
    and <span class="inlinecode">:</span> as "is a proof of" or "is evidence for") is called the
    <i>Curry-Howard correspondence</i>.  It proposes a deep connection
    between the world of logic and the world of computation.
<pre>
                 propositions  ~  types
                 proofs        ~  data values
</pre>
    Many useful insights follow from this connection.  To begin with, it
    gives us a natural interpretation of the type of <span class="inlinecode"><a class="idref" href="Prop.html#b_sum"><span class="id" type="constructor">b_sum</span></a></span> constructor: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Prop.html#b_sum"><span class="id" type="constructor">b_sum</span></a>.<br/>
</div>

<div class="doc">
This can be read "<span class="inlinecode"><a class="idref" href="Prop.html#b_sum"><span class="id" type="constructor">b_sum</span></a></span> is a constructor that takes four
    arguments -- two numbers, <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> and <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>, and two pieces of evidence,
    for the propositions <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> and <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span>, respectively -- 
    and yields evidence for the proposition <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span> <span class="inlinecode">(<a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a>+<a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a>)</span>." 
<div class="paragraph"> </div>

 Now let's look again at a previous proof involving <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="eight_is_beautiful"><span class="id" type="lemma">eight_is_beautiful</span></a>: <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> 8.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#b_sum"><span class="id" type="constructor">b_sum</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">n</span> := 3) (<span class="id" type="var">m</span> := 5).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#b_3"><span class="id" type="constructor">b_3</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#b_5"><span class="id" type="constructor">b_5</span></a>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Just as with ordinary data values and functions, we can use the <span class="inlinecode"><span class="id" type="keyword">Print</span></span>
command to see the <i>proof object</i> that results from this proof script. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">eight_is_beautiful</span>.<br/>

<br/>
</div>

<div class="doc">
In view of this, we might wonder whether we can write such
    an expression ourselves. Indeed, we can: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Check</span> (<a class="idref" href="Prop.html#b_sum"><span class="id" type="constructor">b_sum</span></a> 3 5 <a class="idref" href="Prop.html#b_3"><span class="id" type="constructor">b_3</span></a> <a class="idref" href="Prop.html#b_5"><span class="id" type="constructor">b_5</span></a>).<br/>

<br/>
</div>

<div class="doc">
The expression <span class="inlinecode"><a class="idref" href="Prop.html#b_sum"><span class="id" type="constructor">b_sum</span></a></span> <span class="inlinecode">3</span> <span class="inlinecode">5</span> <span class="inlinecode"><a class="idref" href="Prop.html#b_3"><span class="id" type="constructor">b_3</span></a></span> <span class="inlinecode"><a class="idref" href="Prop.html#b_5"><span class="id" type="constructor">b_5</span></a></span> can be thought of as
    instantiating the parameterized constructor <span class="inlinecode"><a class="idref" href="Prop.html#b_sum"><span class="id" type="constructor">b_sum</span></a></span> with the
    specific arguments <span class="inlinecode">3</span> <span class="inlinecode">5</span> and the corresponding proof objects for
    its premises <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span> <span class="inlinecode">3</span> and <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span> <span class="inlinecode">5</span> (Coq is smart enough
    to figure out that 3+5=8).  Alternatively, we can think of <span class="inlinecode"><a class="idref" href="Prop.html#b_sum"><span class="id" type="constructor">b_sum</span></a></span>
    as a primitive "evidence constructor" that, when applied to two
    particular numbers, wants to be further applied to evidence that
    those two numbers are beautiful; its type, 
    forall n m, beautiful n -&gt; beautiful m -&gt; beautiful (n+m),
    expresses this functionality, in the same way that the polymorphic
    type <span class="inlinecode"><span class="id" type="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>,</span> <span class="inlinecode"><a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> in the previous chapter expressed the fact
    that the constructor <span class="inlinecode"><a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a></span> can be thought of as a function from
    types to empty lists with elements of that type. 
<div class="paragraph"> </div>

 This gives us an alternative way to write the proof that <span class="inlinecode">8</span> is
    beautiful: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="eight_is_beautiful'"><span class="id" type="lemma">eight_is_beautiful'</span></a>: <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> 8.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<a class="idref" href="Prop.html#b_sum"><span class="id" type="constructor">b_sum</span></a> 3 5 <a class="idref" href="Prop.html#b_3"><span class="id" type="constructor">b_3</span></a> <a class="idref" href="Prop.html#b_5"><span class="id" type="constructor">b_5</span></a>).<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Notice that we're using <span class="inlinecode"><span class="id" type="tactic">apply</span></span> here in a new way: instead of just
    supplying the <i>name</i> of a hypothesis or previously proved theorem
    whose type matches the current goal, we are supplying an
    <i>expression</i> that directly builds evidence with the required
    type. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab324"></a><h1 class="section">Proof Scripts and Proof Objects</h1>

<div class="paragraph"> </div>

 These proof objects lie at the core of how Coq operates. 

<div class="paragraph"> </div>

    When Coq is following a proof script, what is happening internally
    is that it is gradually constructing a proof object -- a term
    whose type is the proposition being proved.  The tactics between
    the <span class="inlinecode"><span class="id" type="keyword">Proof</span></span> command and the <span class="inlinecode"><span class="id" type="keyword">Qed</span></span> instruct Coq how to build up a
    term of the required type.  To see this process in action, let's
    use the <span class="inlinecode"><span class="id" type="keyword">Show</span></span> <span class="inlinecode"><span class="id" type="keyword">Proof</span></span> command to display the current state of the
    proof tree at various points in the following tactic proof. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="eight_is_beautiful''"><span class="id" type="lemma">eight_is_beautiful''</span></a>: <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> 8.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Show</span> <span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#b_sum"><span class="id" type="constructor">b_sum</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">n</span>:=3) (<span class="id" type="var">m</span>:=5).<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Show</span> <span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#b_3"><span class="id" type="constructor">b_3</span></a>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Show</span> <span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#b_5"><span class="id" type="constructor">b_5</span></a>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Show</span> <span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
At any given moment, Coq has constructed a term with some
    "holes" (indicated by <span class="inlinecode">?1</span>, <span class="inlinecode">?2</span>, and so on), and it knows what
    type of evidence is needed at each hole.  
<div class="paragraph"> </div>


<div class="paragraph"> </div>

    Each of the holes corresponds to a subgoal, and the proof is
    finished when there are no more subgoals.  At this point, the
    <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span> command gives a name to the evidence we've built and
    stores it in the global context. 
<div class="paragraph"> </div>

 Tactic proofs are useful and convenient, but they are not
    essential: in principle, we can always construct the required
    evidence by hand, as shown above. Then we can use <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> 
    (rather than <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span>) to give a global name directly to a 
    piece of evidence. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="eight_is_beautiful'''"><span class="id" type="definition">eight_is_beautiful'''</span></a> : <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> 8 :=<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#b_sum"><span class="id" type="constructor">b_sum</span></a> 3 5 <a class="idref" href="Prop.html#b_3"><span class="id" type="constructor">b_3</span></a> <a class="idref" href="Prop.html#b_5"><span class="id" type="constructor">b_5</span></a>.<br/>

<br/>
</div>

<div class="doc">
All these different ways of building the proof lead to exactly the
    same evidence being saved in the global environment. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">eight_is_beautiful</span>.<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">eight_is_beautiful'</span>.<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">eight_is_beautiful''</span>.<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">eight_is_beautiful'''</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab325"></a><h4 class="section">Exercise: 1 star (six_is_beautiful)</h4>
 Give a tactic proof and a proof object showing that <span class="inlinecode">6</span> is <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="six_is_beautiful"><span class="id" type="lemma">six_is_beautiful</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> 6.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="six_is_beautiful'"><span class="id" type="definition">six_is_beautiful'</span></a> : <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> 6 :=<br/>
&nbsp;&nbsp; <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab326"></a><h4 class="section">Exercise: 1 star (nine_is_beautiful)</h4>
 Give a tactic proof and a proof object showing that <span class="inlinecode">9</span> is <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="nine_is_beautiful"><span class="id" type="lemma">nine_is_beautiful</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> 9.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="nine_is_beautiful'"><span class="id" type="definition">nine_is_beautiful'</span></a> : <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> 9 :=<br/>
&nbsp;&nbsp; <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab327"></a><h1 class="section">Quantification, Implications and Functions</h1>

<div class="paragraph"> </div>

 In Coq's computational universe (where we've mostly been living
    until this chapter), there are two sorts of values with arrows in
    their types: <i>constructors</i> introduced by <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>-ly defined
    data types, and <i>functions</i>.

<div class="paragraph"> </div>

    Similarly, in Coq's logical universe, there are two ways of giving
    evidence for an implication: constructors introduced by
    <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>-ly defined propositions, and... functions!

<div class="paragraph"> </div>

    For example, consider this statement: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="b_plus3"><span class="id" type="lemma">b_plus3</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span>, <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> (3<a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a><a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#b_sum"><span class="id" type="constructor">b_sum</span></a>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#b_3"><span class="id" type="constructor">b_3</span></a>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
What is the proof object corresponding to <span class="inlinecode"><a class="idref" href="ProofObjects.html#b_plus3"><span class="id" type="lemma">b_plus3</span></a></span>? 

<div class="paragraph"> </div>

    We're looking for an expression whose <i>type</i> is <span class="inlinecode"><span class="id" type="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a>,</span>
    <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span> <span class="inlinecode">(3+<a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a>)</span> -- that is, a <i>function</i> that
    takes two arguments (one number and a piece of evidence) and
    returns a piece of evidence!  Here it is: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="b_plus3'"><span class="id" type="definition">b_plus3'</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span>, <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> (3<a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a><a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>) := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) ⇒ <span class="id" type="keyword">fun</span> (<span class="id" type="var">H</span> : <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Prop.html#b_sum"><span class="id" type="constructor">b_sum</span></a> 3 <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="Prop.html#b_3"><span class="id" type="constructor">b_3</span></a> <a class="idref" href="ProofObjects.html#H"><span class="id" type="variable">H</span></a>.<br/>

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="ProofObjects.html#b_plus3'"><span class="id" type="definition">b_plus3'</span></a>.<br/>

<br/>
</div>

<div class="doc">
Recall that <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="var">blah</span></span> means "the function that, given <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span>,
    yields <span class="inlinecode"><span class="id" type="var">blah</span></span>."  Another equivalent way to write this definition is: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="b_plus3''"><span class="id" type="definition">b_plus3''</span></a> (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">H</span> : <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>) : <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> (3<a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a><a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>) := <br/>
&nbsp;&nbsp;<a class="idref" href="Prop.html#b_sum"><span class="id" type="constructor">b_sum</span></a> 3 <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="Prop.html#b_3"><span class="id" type="constructor">b_3</span></a> <a class="idref" href="ProofObjects.html#H"><span class="id" type="variable">H</span></a>.<br/>

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="ProofObjects.html#b_plus3''"><span class="id" type="definition">b_plus3''</span></a>.<br/>

<br/>
</div>

<div class="doc">
When we view the proposition being proved by <span class="inlinecode"><a class="idref" href="ProofObjects.html#b_plus3"><span class="id" type="lemma">b_plus3</span></a></span> as a function type,
    one aspect of it may seem a little unusual. The second argument's
    type, <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span>, mentions the <i>value</i> of the first argument, <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span>.
    While such <i>dependent types</i> are not commonly found in programming
    languages, even functional ones like ML or Haskell, they can
    be useful there too.  

<div class="paragraph"> </div>

    Notice that both implication (<span class="inlinecode">→</span>) and quantification (<span class="inlinecode"><span class="id" type="keyword">∀</span></span>)
    correspond to functions on evidence.  In fact, they are really the
    same thing: <span class="inlinecode">→</span> is just a shorthand for a degenerate use of
    <span class="inlinecode"><span class="id" type="keyword">∀</span></span> where there is no dependency, i.e., no need to give a name
    to the type on the LHS of the arrow. 
<div class="paragraph"> </div>

 For example, consider this proposition: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="beautiful_plus3"><span class="id" type="definition">beautiful_plus3</span></a> : <span class="id" type="keyword">Prop</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> <span class="id" type="var">n</span>, <span class="id" type="keyword">∀</span> (<span class="id" type="var">E</span> : <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>), <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> (<a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a><a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a>3).<br/>

<br/>
</div>

<div class="doc">
A proof term inhabiting this proposition would be a function
    with two arguments: a number <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> and some evidence <span class="inlinecode"><span class="id" type="var">E</span></span> that <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> is
    beautiful.  But the name <span class="inlinecode"><span class="id" type="var">E</span></span> for this evidence is not used in the
    rest of the statement of <span class="inlinecode"><span class="id" type="var">funny_prop1</span></span>, so it's a bit silly to
    bother making up a name for it.  We could write it like this
    instead, using the dummy identifier <span class="inlinecode"><span class="id" type="var">_</span></span> in place of a real
    name: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="beautiful_plus3'"><span class="id" type="definition">beautiful_plus3'</span></a> : <span class="id" type="keyword">Prop</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> <span class="id" type="var">n</span>, <span class="id" type="keyword">∀</span> (<span class="id" type="var">_</span> : <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>), <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> (<a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a><a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a>3).<br/>

<br/>
</div>

<div class="doc">
Or, equivalently, we can write it in more familiar notation: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="beatiful_plus3''"><span class="id" type="definition">beatiful_plus3''</span></a> : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> <span class="id" type="var">n</span>, <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> (<a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a><a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a>3).<br/>

<br/>
</div>

<div class="doc">
In general, "<span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span>" is just syntactic sugar for
    "<span class="inlinecode"><span class="id" type="keyword">∀</span></span> <span class="inlinecode">(<span class="id" type="var">_</span>:<a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a>),</span> <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span>". 
<div class="paragraph"> </div>

<a name="lab328"></a><h4 class="section">Exercise: 2 stars b_times2</h4>

<div class="paragraph"> </div>

 Give a proof object corresponding to the theorem <span class="inlinecode"><a class="idref" href="Prop.html#b_times2"><span class="id" type="lemma">b_times2</span></a></span> from Prop.v 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="b_times2'"><span class="id" type="definition">b_times2'</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span>, <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> (2<a class="idref" href="Basics.html#:nat_scope:x_'*'_x"><span class="id" type="notation">×</span></a><a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>) :=<br/>
&nbsp;&nbsp; <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab329"></a><h4 class="section">Exercise: 2 stars, optional (gorgeous_plus13_po)</h4>
 Give a proof object corresponding to the theorem <span class="inlinecode"><a class="idref" href="Prop.html#gorgeous_plus13"><span class="id" type="lemma">gorgeous_plus13</span></a></span> from Prop.v 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="gorgeous_plus13_po"><span class="id" type="definition">gorgeous_plus13_po</span></a>: <span class="id" type="keyword">∀</span> <span class="id" type="var">n</span>, <a class="idref" href="Prop.html#gorgeous"><span class="id" type="inductive">gorgeous</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="Prop.html#gorgeous"><span class="id" type="inductive">gorgeous</span></a> (13<a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a><a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>):=<br/>
&nbsp;&nbsp;&nbsp; <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 It is particularly revealing to look at proof objects involving the 
logical connectives that we defined with inductive propositions in Logic.v. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="and_example"><span class="id" type="lemma">and_example</span></a> : <br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> 0<a class="idref" href="Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> 3<a class="idref" href="Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Logic.html#conj"><span class="id" type="constructor">conj</span></a>.<br/>
 <span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#b_0"><span class="id" type="constructor">b_0</span></a>.<br/>
 <span class="id" type="tactic">apply</span> <a class="idref" href="Prop.html#b_3"><span class="id" type="constructor">b_3</span></a>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Let's take a look at the proof object for the above theorem. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">and_example</span>.<br/>

<br/>
</div>

<div class="doc">
Note that the proof is of the form
    conj (beautiful 0) (beautiful 3) 
         (...pf of beautiful 3...) (...pf of beautiful 3...)
    as you'd expect, given the type of <span class="inlinecode"><a class="idref" href="Logic.html#conj"><span class="id" type="constructor">conj</span></a></span>. 
<div class="paragraph"> </div>

<a name="lab330"></a><h4 class="section">Exercise: 1 star, optional (case_proof_objects)</h4>
 The <span class="inlinecode"><span class="id" type="var">Case</span></span> tactics were commented out in the proof of
    <span class="inlinecode"><a class="idref" href="ProofObjects.html#and_example"><span class="id" type="lemma">and_example</span></a></span> to avoid cluttering the proof object.  What would
    you guess the proof object will look like if we uncomment them?
    Try it and see.  <font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="and_commut"><span class="id" type="lemma">and_commut</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, <br/>
&nbsp;&nbsp;<a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
 <span class="id" type="tactic">apply</span> <span class="id" type="var">HQ</span>.<br/>
 <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Once again, we have commented out the <span class="inlinecode"><span class="id" type="var">Case</span></span> tactics to make the
    proof object for this theorem easier to understand. It is still
    a little complicated, but after performing some simple reduction
    steps, we can see that all that is really happening is taking apart 
    a record containing evidence for <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> and <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> and rebuilding it in the
    opposite order: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">and_commut</span>.<br/>

<br/>
</div>

<div class="doc">
After simplifying some direct application of <span class="inlinecode"><span class="id" type="keyword">fun</span></span> expressions to arguments,
we get: 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab331"></a><h4 class="section">Exercise: 2 stars, optional (conj_fact)</h4>
 Construct a proof object demonstrating the following proposition. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="conj_fact"><span class="id" type="definition">conj_fact</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span>, <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="ProofObjects.html#R"><span class="id" type="variable">R</span></a> → <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="ProofObjects.html#R"><span class="id" type="variable">R</span></a> :=<br/>
&nbsp;&nbsp; <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab332"></a><h4 class="section">Exercise: 2 stars, advanced, optional (beautiful_iff_gorgeous)</h4>

<div class="paragraph"> </div>

 We have seen that the families of propositions <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span> and
    <span class="inlinecode"><a class="idref" href="Prop.html#gorgeous"><span class="id" type="inductive">gorgeous</span></a></span> actually characterize the same set of numbers.
    Prove that <span class="inlinecode"><a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a></span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> <span class="inlinecode">↔</span> <span class="inlinecode"><a class="idref" href="Prop.html#gorgeous"><span class="id" type="inductive">gorgeous</span></a></span> <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span> for all <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.n"><span class="id" type="abbreviation">n</span></a></span>.  Just for
    fun, write your proof as an explicit proof object, rather than
    using tactics. (<i>Hint</i>: if you make use of previously defined
    theorems, you should only need a single line!) 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="beautiful_iff_gorgeous"><span class="id" type="definition">beautiful_iff_gorgeous</span></a> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> <span class="id" type="var">n</span>, <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="Logic.html#:type_scope:x_'<->'_x"><span class="id" type="notation">↔</span></a> <a class="idref" href="Prop.html#gorgeous"><span class="id" type="inductive">gorgeous</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> :=<br/>
&nbsp;&nbsp; <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab333"></a><h4 class="section">Exercise: 2 stars, optional (or_commut'')</h4>
 Try to write down an explicit proof object for <span class="inlinecode"><a class="idref" href="Logic.html#or_commut"><span class="id" type="lemma">or_commut</span></a></span> (without
    using <span class="inlinecode"><span class="id" type="keyword">Print</span></span> to peek at the ones we already defined!). 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Recall that we model an existential for a property as a pair consisting of 
a witness value and a proof that the witness obeys that property. 
We can choose to construct the proof explicitly. 

<div class="paragraph"> </div>

For example, consider this existentially quantified proposition: 
</div>
<div class="code">
<span class="id" type="keyword">Check</span> <a class="idref" href="MoreLogic.html#ex"><span class="id" type="inductive">ex</span></a>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="some_nat_is_even"><span class="id" type="definition">some_nat_is_even</span></a> : <span class="id" type="keyword">Prop</span> := <br/>
&nbsp;&nbsp;<a class="idref" href="MoreLogic.html#ex"><span class="id" type="inductive">ex</span></a> <span class="id" type="var">_</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a>.<br/>

<br/>
</div>

<div class="doc">
To prove this proposition, we need to choose a particular number
    as witness -- say, 4 -- and give some evidence that that number is
    even. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="snie"><span class="id" type="definition">snie</span></a> : <a class="idref" href="ProofObjects.html#some_nat_is_even"><span class="id" type="definition">some_nat_is_even</span></a> := <br/>
&nbsp;&nbsp;<a class="idref" href="MoreLogic.html#ex_intro"><span class="id" type="constructor">ex_intro</span></a> <span class="id" type="var">_</span> <a class="idref" href="Prop.html#ev"><span class="id" type="inductive">ev</span></a> 4 (<a class="idref" href="Prop.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 2 (<a class="idref" href="Prop.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 0 <a class="idref" href="Prop.html#ev_0"><span class="id" type="constructor">ev_0</span></a>)).<br/>

<br/>
</div>

<div class="doc">
<a name="lab334"></a><h4 class="section">Exercise: 2 stars, optional (ex_beautiful_Sn)</h4>
 Complete the definition of the following proof object: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="p"><span class="id" type="definition">p</span></a> : <a class="idref" href="MoreLogic.html#ex"><span class="id" type="inductive">ex</span></a> <span class="id" type="var">_</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> ⇒ <a class="idref" href="Prop.html#beautiful"><span class="id" type="inductive">beautiful</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>)) :=<br/>
 <a class="idref" href="Basics.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab335"></a><h1 class="section">Giving Explicit Arguments to Lemmas and Hypotheses</h1>

<div class="paragraph"> </div>

 Even when we are using tactic-based proof, it can be very useful to
understand the underlying functional nature of implications and quantification. 

<div class="paragraph"> </div>

For example, it is often convenient to <span class="inlinecode"><span class="id" type="tactic">apply</span></span> or <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> 
using a lemma or hypothesis with one or more quantifiers or 
assumptions already instantiated in order to direct what
happens.  For example: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Check</span> <a class="idref" href="Induction.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="plus_comm_r"><span class="id" type="lemma">plus_comm_r</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>, <a class="idref" href="ProofObjects.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><a class="idref" href="ProofObjects.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="ProofObjects.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="ProofObjects.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><a class="idref" href="ProofObjects.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="ProofObjects.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Induction.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a> <span class="id" type="var">b</span> <span class="id" type="var">a</span>). &nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
In this case, giving just one argument would be sufficient. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="plus_comm_r'"><span class="id" type="lemma">plus_comm_r'</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>, <a class="idref" href="ProofObjects.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><a class="idref" href="ProofObjects.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="ProofObjects.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="ProofObjects.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><a class="idref" href="ProofObjects.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="ProofObjects.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Induction.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a> <span class="id" type="var">b</span>).<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Arguments must be given in order, but wildcards (_)
may be used to skip arguments that Coq can infer.  
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="plus_comm_r''"><span class="id" type="lemma">plus_comm_r''</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>, <a class="idref" href="ProofObjects.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><a class="idref" href="ProofObjects.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="ProofObjects.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="ProofObjects.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><a class="idref" href="ProofObjects.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="ProofObjects.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> (<a class="idref" href="Induction.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a> <span class="id" type="var">_</span> <span class="id" type="var">a</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The author of a lemma can choose to declare easily inferable arguments
to be implicit, just as with functions and constructors. 

<div class="paragraph"> </div>

  The <span class="inlinecode"><span class="id" type="keyword">with</span></span> clauses we've already seen is really just a way of
  specifying selected arguments by name rather than position:  
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="plus_comm_r'''"><span class="id" type="lemma">plus_comm_r'''</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>, <a class="idref" href="ProofObjects.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><a class="idref" href="ProofObjects.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="ProofObjects.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="ProofObjects.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">(</span></a><a class="idref" href="ProofObjects.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="ProofObjects.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="Basics.html#:nat_scope:x_'+'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <a class="idref" href="Induction.html#plus_comm"><span class="id" type="axiom">plus_comm</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">n</span> := <span class="id" type="var">b</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab336"></a><h4 class="section">Exercise: 2 stars (trans_eq_example_redux)</h4>
 Redo the proof of the following theorem (from MoreCoq.v) using
an <span class="inlinecode"><span class="id" type="tactic">apply</span></span> of <span class="inlinecode"><a class="idref" href="MoreCoq.html#trans_eq"><span class="id" type="lemma">trans_eq</span></a></span> but <i>not</i> using a <span class="inlinecode"><span class="id" type="keyword">with</span></span> clause. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="trans_eq_example'"><span class="id" type="definition">trans_eq_example'</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">a</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">d</span> <span class="id" type="var">e</span> <span class="id" type="var">f</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="ProofObjects.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">;</span></a><a class="idref" href="ProofObjects.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="ProofObjects.html#c"><span class="id" type="variable">c</span></a><a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">;</span></a><a class="idref" href="ProofObjects.html#d"><span class="id" type="variable">d</span></a><a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="ProofObjects.html#c"><span class="id" type="variable">c</span></a><a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">;</span></a><a class="idref" href="ProofObjects.html#d"><span class="id" type="variable">d</span></a><a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="ProofObjects.html#e"><span class="id" type="variable">e</span></a><a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">;</span></a><a class="idref" href="ProofObjects.html#f"><span class="id" type="variable">f</span></a><a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="ProofObjects.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">;</span></a><a class="idref" href="ProofObjects.html#b"><span class="id" type="variable">b</span></a><a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="ProofObjects.html#e"><span class="id" type="variable">e</span></a><a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">;</span></a><a class="idref" href="ProofObjects.html#f"><span class="id" type="variable">f</span></a><a class="idref" href="Poly.html#::'['_x_';'_'..'_';'_x_']'"><span class="id" type="notation">]</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab337"></a><h1 class="section">Programming with Tactics (Advanced)</h1>

<div class="paragraph"> </div>

 If we can build proofs with explicit terms rather than tactics,
    you may be wondering if we can build programs using tactics rather
    than explicit terms.  Sure! 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="add1"><span class="id" type="definition">add1</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Show</span> <span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a>.<br/>
<span class="id" type="keyword">Show</span> <span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">n</span>. <span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">add1</span>.<br/>

<br/>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">compute</span> <span class="id" type="keyword">in</span> <a class="idref" href="ProofObjects.html#add1"><span class="id" type="definition">add1</span></a> 2.<br/>

<br/>
</div>

<div class="doc">
Notice that we terminate the <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> with a <span class="inlinecode">.</span> rather than with
<span class="inlinecode">:=</span> followed by a term.  This tells Coq to enter proof scripting mode
to build an object of type <span class="inlinecode"><a class="idref" href="Poly.html#Church.nat"><span class="id" type="definition">nat</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="Poly.html#Church.nat"><span class="id" type="definition">nat</span></a></span>.  Also, we terminate the proof
with <span class="inlinecode"><span class="id" type="keyword">Defined</span></span> rather than <span class="inlinecode"><span class="id" type="keyword">Qed</span></span>; this makes the definition <i>transparent</i>
so that it can be used in computation like a normally-defined function.  

<div class="paragraph"> </div>

This feature is mainly useful for writing functions with dependent types,
which we won't explore much further in this book.
But it does illustrate the uniformity and orthogonality of the basic ideas in Coq. 
<div class="paragraph"> </div>

  
</div>
<div class="code">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>