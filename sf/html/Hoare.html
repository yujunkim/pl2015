<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Hoare</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Hoare</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab533"></a><h1 class="section">Hoare: Hoare Logic, Part I</h1>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="Imp.html#"><span class="id" type="library">Imp</span></a>.<br/>

<br/>
</div>

<div class="doc">
In the past couple of chapters, we've begun applying the
    mathematical tools developed in the first part of the course to
    studying the theory of a small programming language, Imp.

<div class="paragraph"> </div>

<ul class="doclist">
<li> We defined a type of <i>abstract syntax trees</i> for Imp, together
      with an <i>evaluation relation</i> (a partial function on states)
      that specifies the <i>operational semantics</i> of programs.

<div class="paragraph"> </div>

      The language we defined, though small, captures some of the key
      features of full-blown languages like C, C++, and Java,
      including the fundamental notion of mutable state and some
      common control structures.

<div class="paragraph"> </div>


</li>
<li> We proved a number of <i>metatheoretic properties</i> -- "meta" in
      the sense that they are properties of the language as a whole,
      rather than properties of particular programs in the language.
      These included:

<div class="paragraph"> </div>

<ul class="doclist">
<li> determinism of evaluation

<div class="paragraph"> </div>


</li>
<li> equivalence of some different ways of writing down the
          definitions (e.g. functional and relational definitions of
          arithmetic expression evaluation)

<div class="paragraph"> </div>


</li>
<li> guaranteed termination of certain classes of programs

<div class="paragraph"> </div>


</li>
<li> correctness (in the sense of preserving meaning) of a number
          of useful program transformations

<div class="paragraph"> </div>


</li>
<li> behavioral equivalence of programs (in the <span class="inlinecode"><span class="id" type="library">Equiv</span></span> chapter). 

</li>
</ul>

</li>
</ul>
    If we stopped here, we would already have something useful: a set
    of tools for defining and discussing programming languages and
    language features that are mathematically precise, flexible, and
    easy to work with, applied to a set of key properties.  All of
    these properties are things that language designers, compiler
    writers, and users might care about knowing.  Indeed, many of them
    are so fundamental to our understanding of the programming
    languages we deal with that we might not consciously recognize
    them as "theorems."  But properties that seem intuitively obvious
    can sometimes be quite subtle (in some cases, even subtly wrong!).

<div class="paragraph"> </div>

    We'll return to the theme of metatheoretic properties of whole
    languages later in the course when we discuss <i>types</i> and <i>type
    soundness</i>.  In this chapter, though, we'll turn to a different
    set of issues.

<div class="paragraph"> </div>

    Our goal is to see how to carry out some simple examples of
    <i>program verification</i> -- i.e., using the precise definition of
    Imp to prove formally that particular programs satisfy particular
    specifications of their behavior. We'll develop a reasoning system
    called <i>Floyd-Hoare Logic</i> -- often shortened to just <i>Hoare
    Logic</i> -- in which each of the syntactic constructs of Imp is
    equipped with a single, generic "proof rule" that can be used to
    reason compositionally about the correctness of programs involving
    this construct.

<div class="paragraph"> </div>

    Hoare Logic originates in the 1960s, and it continues to be the
    subject of intensive research right up to the present day.  It
    lies at the core of a multitude of tools that are being used in
    academia and industry to specify and verify real software
    systems. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab534"></a><h1 class="section">Hoare Logic</h1>

<div class="paragraph"> </div>

 Hoare Logic combines two beautiful ideas: a natural way of
    writing down <i>specifications</i> of programs, and a <i>compositional
    proof technique</i> for proving that programs are correct with
    respect to such specifications -- where by "compositional" we mean
    that the structure of proofs directly mirrors the structure of the
    programs that they are about. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab535"></a><h2 class="section">Assertions</h2>

<div class="paragraph"> </div>

 To talk about specifications of programs, the first thing we
    need is a way of making <i>assertions</i> about properties that hold at
    particular points during a program's execution -- i.e., claims
    about the current state of the memory when program execution
    reaches that point.  Formally, an assertion is just a family of
    propositions indexed by a <span class="inlinecode"><a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="Assertion"><span class="id" type="definition">Assertion</span></a> := <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> → <span class="id" type="keyword">Prop</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab536"></a><h4 class="section">Exercise: 1 star, optional (assertions)</h4>

</div>
<div class="code">
<span class="id" type="keyword">Module</span> <a name="ExAssertions"><span class="id" type="module">ExAssertions</span></a>.<br/>

<br/>
</div>

<div class="doc">
Paraphrase the following assertions in English. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="ExAssertions.as1"><span class="id" type="definition">as1</span></a> : <a class="idref" href="Hoare.html#ExAssertions.Assertion"><span class="id" type="definition">Assertion</span></a> := <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 3.<br/>
<span class="id" type="keyword">Definition</span> <a name="ExAssertions.as2"><span class="id" type="definition">as2</span></a> : <a class="idref" href="Hoare.html#ExAssertions.Assertion"><span class="id" type="definition">Assertion</span></a> := <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>.<br/>
<span class="id" type="keyword">Definition</span> <a name="ExAssertions.as3"><span class="id" type="definition">as3</span></a> : <a class="idref" href="Hoare.html#ExAssertions.Assertion"><span class="id" type="definition">Assertion</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 3 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'\/'_x"><span class="id" type="notation">∨</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>.<br/>
<span class="id" type="keyword">Definition</span> <a name="ExAssertions.as4"><span class="id" type="definition">as4</span></a> : <a class="idref" href="Hoare.html#ExAssertions.Assertion"><span class="id" type="definition">Assertion</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">×</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'*'_x"><span class="id" type="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Definition</span> <a name="ExAssertions.as5"><span class="id" type="definition">as5</span></a> : <a class="idref" href="Hoare.html#ExAssertions.Assertion"><span class="id" type="definition">Assertion</span></a> := <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>.<br/>
<span class="id" type="keyword">Definition</span> <a name="ExAssertions.as6"><span class="id" type="definition">as6</span></a> : <a class="idref" href="Hoare.html#ExAssertions.Assertion"><span class="id" type="definition">Assertion</span></a> := <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>

<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Hoare.html#ExAssertions"><span class="id" type="module">ExAssertions</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab537"></a><h2 class="section">Notation for Assertions</h2>

<div class="paragraph"> </div>

 This way of writing assertions can be a little bit heavy,
    for two reasons: (1) every single assertion that we ever write is
    going to begin with <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">⇒</span> <span class="inlinecode"></span>; and (2) this state <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> is the
    only one that we ever use to look up variables (we will never need
    to talk about two different memory states at the same time).  For
    discussing examples informally, we'll adopt some simplifying
    conventions: we'll drop the initial <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode">⇒</span>, and we'll write
    just <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> to mean <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span>.  Thus, instead of writing 
<div class="paragraph"> </div>

      fun st =&gt; (st Z) * (st Z) &lt;= m /\
                ~ ((S (st Z)) * (S (st Z)) &lt;= m)
    we'll write just
         Z * Z &lt;= m /\ ~((S Z) * (S Z) &lt;= m).

<div class="paragraph"> </div>

 Given two assertions <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> and <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span>, we say that <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <i>implies</i> <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span>,
    written <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <span class="inlinecode">-&gt;&gt;</span> <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> (in ASCII, <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <span class="inlinecode">-</span><span class="inlinecode">&gt;</span><span class="inlinecode">&gt;</span> <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span>), if, whenever <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span>
    holds in some state <span class="inlinecode"><a class="idref" href="Imp.html#st"><span class="id" type="variable">st</span></a></span>, <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> also holds. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="assert_implies"><span class="id" type="definition">assert_implies</span></a> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> <span class="id" type="var">st</span>, <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> → <a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name=":hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">"</span></a>P -&gt;&gt; Q" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#assert_implies"><span class="id" type="definition">assert_implies</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80) : <span class="id" type="var">hoare_spec_scope</span>.<br/>
<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">hoare_spec_scope</span>.<br/>

<br/>
</div>

<div class="doc">
We'll also have occasion to use the "iff" variant of implication
    between assertions: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Notation</span> <a name=":hoare_spec_scope:x_'<<->>'_x"><span class="id" type="notation">"</span></a>P &lt;&lt;-&gt;&gt; Q" :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">P</span> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">-&gt;&gt;</span></a> <span class="id" type="var">Q</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <span class="id" type="var">Q</span> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">-&gt;&gt;</span></a> <span class="id" type="var">P</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80) : <span class="id" type="var">hoare_spec_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab538"></a><h2 class="section">Hoare Triples</h2>

<div class="paragraph"> </div>

 Next, we need a way of making formal claims about the
    behavior of commands. 
<div class="paragraph"> </div>

 Since the behavior of a command is to transform one state to
    another, it is natural to express claims about commands in terms
    of assertions that are true before and after the command executes:

<div class="paragraph"> </div>

<ul class="doclist">
<li> "If command <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> is started in a state satisfying assertion
        <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span>, and if <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> eventually terminates in some final state,
        then this final state will satisfy the assertion <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span>."

</li>
</ul>

<div class="paragraph"> </div>

    Such a claim is called a <i>Hoare Triple</i>.  The property <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> is
    called the <i>precondition</i> of <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span>, while <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> is the
    <i>postcondition</i>.  Formally: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="hoare_triple"><span class="id" type="definition">hoare_triple</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">P</span>:<a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a>) (<span class="id" type="var">c</span>:<a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a>) (<span class="id" type="var">Q</span>:<a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a>  →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a>  →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a>.<br/>

<br/>
</div>

<div class="doc">
Since we'll be working a lot with Hoare triples, it's useful to
    have a compact notation:
       <a href="P">P</a> c <a href="Q">Q</a>.
 (The traditional notation is <span class="inlinecode">{<a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a>}</span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode">{<a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a>}</span>, but single braces
    are already used for other things in Coq.)  
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Notation</span> <a name=":hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">"</span></a>{{ P }}  c  {{ Q }}" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#hoare_triple"><span class="id" type="definition">hoare_triple</span></a> <span class="id" type="var">P</span> <span class="id" type="var">c</span> <span class="id" type="var">Q</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 90, <span class="id" type="var">c</span> <span class="id" type="tactic">at</span> <span class="id" type="var">next</span> <span class="id" type="keyword">level</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">hoare_spec_scope</span>.<br/>

<br/>
</div>

<div class="doc">
(The <span class="inlinecode"><span class="id" type="var">hoare_spec_scope</span></span> annotation here tells Coq that this
    notation is not global but is intended to be used in particular
    contexts.  The <span class="inlinecode"><span class="id" type="keyword">Open</span></span> <span class="inlinecode"><span class="id" type="keyword">Scope</span></span> tells Coq that this file is one such
    context.) 
<div class="paragraph"> </div>

<a name="lab539"></a><h4 class="section">Exercise: 1 star, optional (triples)</h4>
 Paraphrase the following Hoare triples in English.
   1) <a href="True">True</a> c <a href="X = 5">X = 5</a>

<div class="paragraph"> </div>

   2) <a href="X = m">X = m</a> c <a href="X = m + 5)">X = m + 5)</a>

<div class="paragraph"> </div>

   3) <a href="X <= Y">X <= Y</a> c <a href="Y <= X">Y <= X</a>

<div class="paragraph"> </div>

   4) <a href="True">True</a> c <a href="False">False</a>

<div class="paragraph"> </div>

   5) <a href="X = m">X = m</a> 
      c
      <a href="Y = real_fact m">Y = real_fact m</a>.

<div class="paragraph"> </div>

   6) <a href="True">True</a> 
      c 
      <a href="(Z * Z) <= m /\ ~ (((S Z) * (S Z)) <= m)">(Z * Z) <= m /\ ~ (((S Z) * (S Z)) <= m)</a>

<div class="paragraph"> </div>

 
<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab540"></a><h4 class="section">Exercise: 1 star, optional (valid_triples)</h4>
 Which of the following Hoare triples are <i>valid</i> -- i.e., the
    claimed relation between <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span>, <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span>, and <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> is true?
   1) <a href="True">True</a> X ::= 5 <a href="X = 5">X = 5</a>

<div class="paragraph"> </div>

   2) <a href="X = 2">X = 2</a> X ::= X + 1 <a href="X = 3">X = 3</a>

<div class="paragraph"> </div>

   3) <a href="True">True</a> X ::= 5; Y ::= 0 <a href="X = 5">X = 5</a>

<div class="paragraph"> </div>

   4) <a href="X = 2 /\ X = 3">X = 2 /\ X = 3</a> X ::= 5 <a href="X = 0">X = 0</a>

<div class="paragraph"> </div>

   5) <a href="True">True</a> SKIP <a href="False">False</a>

<div class="paragraph"> </div>

   6) <a href="False">False</a> SKIP <a href="True">True</a>

<div class="paragraph"> </div>

   7) <a href="True">True</a> WHILE True DO SKIP END <a href="False">False</a>

<div class="paragraph"> </div>

   8) <a href="X = 0">X = 0</a>
      WHILE X == 0 DO X ::= X + 1 END
      <a href="X = 1">X = 1</a>

<div class="paragraph"> </div>

   9) <a href="X = 1">X = 1</a>
      WHILE X &lt;&gt; 0 DO X ::= X + 1 END
      <a href="X = 100">X = 100</a>

<div class="paragraph"> </div>


</div>
<div class="code">
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 (Note that we're using informal mathematical notations for
   expressions inside of commands, for readability, rather than their
   formal <span class="inlinecode"><a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a></span> encodings.  We'll continue doing so
   throughout the chapter.) 
<div class="paragraph"> </div>

 To get us warmed up for what's coming, here are two simple
    facts about Hoare triples. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="hoare_post_true"><span class="id" type="lemma">hoare_post_true</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a>) <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">st</span>, <a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a>) →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">c</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#hoare_triple"><span class="id" type="definition">hoare_triple</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">Heval</span> <span class="id" type="var">HP</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="hoare_pre_false"><span class="id" type="lemma">hoare_pre_false</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a>) <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">st</span>, <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~(</span></a><a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>) →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">c</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#hoare_triple"><span class="id" type="definition">hoare_triple</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">Heval</span> <span class="id" type="var">HP</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> <span class="id" type="var">HP</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">HP</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab541"></a><h2 class="section">Proof Rules</h2>

<div class="paragraph"> </div>

 The goal of Hoare logic is to provide a <i>compositional</i>
    method for proving the validity of Hoare triples.  That is, the
    structure of a program's correctness proof should mirror the
    structure of the program itself.  To this end, in the sections
    below, we'll introduce one rule for reasoning about each of the
    different syntactic forms of commands in Imp -- one for
    assignment, one for sequencing, one for conditionals, etc. -- plus
    a couple of "structural" rules that are useful for gluing things
    together. We will prove programs correct using these proof rules,
    without ever unfolding the definition of <span class="inlinecode"><a class="idref" href="Hoare.html#Himp.hoare_triple"><span class="id" type="definition">hoare_triple</span></a></span>. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab542"></a><h3 class="section">Assignment</h3>

<div class="paragraph"> </div>

 The rule for assignment is the most fundamental of the Hoare logic
    proof rules.  Here's how it works.

<div class="paragraph"> </div>

    Consider this (valid) Hoare triple:
       <a href=" Y = 1 "> Y = 1 </a>  X ::= Y  <a href=" X = 1 "> X = 1 </a>
    In English: if we start out in a state where the value of <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span>
    is <span class="inlinecode">1</span> and we assign <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> to <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span>, then we'll finish in a
    state where <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> is <span class="inlinecode">1</span>.  That is, the property of being equal
    to <span class="inlinecode">1</span> gets transferred from <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> to <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span>.

<div class="paragraph"> </div>

    Similarly, in
       <a href=" Y + Z = 1 "> Y + Z = 1 </a>  X ::= Y + Z  <a href=" X = 1 "> X = 1 </a>
    the same property (being equal to one) gets transferred to
    <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> from the expression <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode"><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a></span> on the right-hand side of
    the assignment.

<div class="paragraph"> </div>

    More generally, if <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.a"><span class="id" type="abbreviation">a</span></a></span> is <i>any</i> arithmetic expression, then
       <a href=" a = 1 "> a = 1 </a>  X ::= a <a href=" X = 1 "> X = 1 </a>
    is a valid Hoare triple. 

<div class="paragraph"> </div>

    This can be made even more general. To conclude that an
    <i>arbitrary</i> property <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> holds after <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">::=</span> <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.a"><span class="id" type="abbreviation">a</span></a></span>, we need to assume
    that <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> holds before <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">::=</span> <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.a"><span class="id" type="abbreviation">a</span></a></span>, but <i>with all occurrences of</i> <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span>
    replaced by <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.a"><span class="id" type="abbreviation">a</span></a></span> in <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span>. This leads to the Hoare rule for
    assignment
      <a href=" Q [X |-> a] "> Q [X |-> a] </a> X ::= a <a href=" Q "> Q </a>
    where "<span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> <span class="inlinecode">[<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">|-&gt;</span> <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.a"><span class="id" type="abbreviation">a</span></a>]</span>" is pronounced "<span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> where <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.a"><span class="id" type="abbreviation">a</span></a></span> is substituted
    for <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span>".

<div class="paragraph"> </div>

    For example, these are valid applications of the assignment
    rule:
      <a href=" (X <= 5) [X |-> X + 1]
         i.e., X + 1 <= 5 "> (X <= 5) [X |-> X + 1]
         i.e., X + 1 <= 5 </a>  
      X ::= X + 1  
      <a href=" X <= 5 "> X <= 5 </a>

<div class="paragraph"> </div>

      <a href=" (X = 3) [X |-> 3]
         i.e., 3 = 3"> (X = 3) [X |-> 3]
         i.e., 3 = 3</a>  
      X ::= 3  
      <a href=" X = 3 "> X = 3 </a>

<div class="paragraph"> </div>

      <a href=" (0 <= X /\ X <= 5) [X |-> 3]
         i.e., (0 <= 3 /\ 3 <= 5)"> (0 <= X /\ X <= 5) [X |-> 3]
         i.e., (0 <= 3 /\ 3 <= 5)</a>  
      X ::= 3  
      <a href=" 0 <= X /\ X <= 5 "> 0 <= X /\ X <= 5 </a>

<div class="paragraph"> </div>

 To formalize the rule, we must first formalize the idea of
    "substituting an expression for an Imp variable in an assertion."
    That is, given a proposition <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span>, a variable <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span>, and an
    arithmetic expression <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.a"><span class="id" type="abbreviation">a</span></a></span>, we want to derive another proposition
    <span class="inlinecode"><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a></span> that is just the same as <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> except that, wherever <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span>
    mentions <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span>, <span class="inlinecode"><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a></span> should instead mention <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.a"><span class="id" type="abbreviation">a</span></a></span>.  

<div class="paragraph"> </div>

    Since <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> is an arbitrary Coq proposition, we can't directly
    "edit" its text.  Instead, we can achieve the effect we want by
    evaluating <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> in an updated state: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="assn_sub"><span class="id" type="definition">assn_sub</span></a> <span class="id" type="var">X</span> <span class="id" type="var">a</span> <span class="id" type="var">P</span> : <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a> (<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#a"><span class="id" type="variable">a</span></a>)).<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name="::x_'['_x_'|->'_x_']'"><span class="id" type="notation">"</span></a>P [ X |-&gt; a ]" := (<a class="idref" href="Hoare.html#assn_sub"><span class="id" type="definition">assn_sub</span></a> <span class="id" type="var">X</span> <span class="id" type="var">a</span> <span class="id" type="var">P</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 10).<br/>

<br/>
</div>

<div class="doc">
That is, <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <span class="inlinecode">[<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">|-&gt;</span> <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.a"><span class="id" type="abbreviation">a</span></a>]</span> is an assertion <span class="inlinecode"><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a></span> that is just like <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span>
    except that, wherever <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> looks up the variable <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> in the current
    state, <span class="inlinecode"><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a></span> instead uses the value of the expression <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.a"><span class="id" type="abbreviation">a</span></a></span>.

<div class="paragraph"> </div>

    To see how this works, let's calculate what happens with a couple
    of examples.  First, suppose <span class="inlinecode"><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a></span> is <span class="inlinecode">(<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode">5)</span> <span class="inlinecode">[<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">|-&gt;</span> <span class="inlinecode">3]</span> -- that
    is, more formally, <span class="inlinecode"><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a></span> is the Coq expression
    fun st =&gt; 
      (fun st' =&gt; st' X &lt;= 5) 
      (update st X (aeval st (ANum 3))),
    which simplifies to 
    fun st =&gt; 
      (fun st' =&gt; st' X &lt;= 5) 
      (update st X 3)
    and further simplifies to
    fun st =&gt; 
      ((update st X 3) X) &lt;= 5)
    and by further simplification to
    fun st =&gt; 
      (3 &lt;= 5).
    That is, <span class="inlinecode"><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a></span> is the assertion that <span class="inlinecode">3</span> is less than or equal to
    <span class="inlinecode">5</span> (as expected).

<div class="paragraph"> </div>

    For a more interesting example, suppose <span class="inlinecode"><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a></span> is <span class="inlinecode">(<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode">5)</span> <span class="inlinecode">[<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">|-&gt;</span>
    <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>+1]</span>.  Formally, <span class="inlinecode"><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a></span> is the Coq expression
    fun st =&gt; 
      (fun st' =&gt; st' X &lt;= 5) 
      (update st X (aeval st (APlus (AId X) (ANum 1)))),
    which simplifies to 
    fun st =&gt; 
      (((update st X (aeval st (APlus (AId X) (ANum 1))))) X) &lt;= 5
    and further simplifies to
    fun st =&gt; 
      (aeval st (APlus (AId X) (ANum 1))) &lt;= 5.
    That is, <span class="inlinecode"><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a></span> is the assertion that <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>+1</span> is at most <span class="inlinecode">5</span>.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 Now we can give the precise proof rule for assignment: 
<hr/>
 (hoare_asgn)
      <a href="Q [X |-> a]">Q [X |-> a]</a> X ::= a <a href="Q">Q</a>

<div class="paragraph"> </div>

 We can prove formally that this rule is indeed valid. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">Q</span> <span class="id" type="var">X</span> <span class="id" type="var">a</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">|-&gt;</span></a> <a class="idref" href="Hoare.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">]</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Hoare.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#hoare_triple"><span class="id" type="definition">hoare_triple</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">Q</span> <span class="id" type="var">X</span> <span class="id" type="var">a</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">HE</span> <span class="id" type="var">HQ</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">HE</span>. <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#assn_sub"><span class="id" type="definition">assn_sub</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">HQ</span>. <span class="id" type="tactic">assumption</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Here's a first formal proof using this rule. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="assn_sub_example"><span class="id" type="definition">assn_sub_example</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">(</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 3<a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">|-&gt;</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 3<a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">]</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 3<a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">)</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 3<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab543"></a><h4 class="section">Exercise: 2 stars (hoare_asgn_examples)</h4>
 Translate these informal Hoare triples...
    1) <a href=" (X <= 5) [X |-> X + 1] "> (X <= 5) [X |-> X + 1] </a>
       X ::= X + 1
       <a href=" X <= 5 "> X <= 5 </a>

<div class="paragraph"> </div>

    2) <a href=" (0 <= X /\ X <= 5) [X |-> 3] "> (0 <= X /\ X <= 5) [X |-> 3] </a>
       X ::= 3
       <a href=" 0 <= X /\ X <= 5 "> 0 <= X /\ X <= 5 </a>
   ...into formal statements <span class="inlinecode"><span class="id" type="var">assn_sub_ex1</span>,</span> <span class="inlinecode"><span class="id" type="var">assn_sub_ex2</span></span> 
   and use <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a></span> to prove them. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab544"></a><h4 class="section">Exercise: 2 stars (hoare_asgn_wrong)</h4>
 The assignment rule looks backward to almost everyone the first
    time they see it.  If it still seems backward to you, it may help
    to think a little about alternative "forward" rules.  Here is a
    seemingly natural one:
<hr/>
 (hoare_asgn_wrong)
      <a href=" True "> True </a> X ::= a <a href=" X = a "> X = a </a>
    Give a counterexample showing that this rule is incorrect
    (informally). Hint: The rule universally quantifies over the
    arithmetic expression <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.a"><span class="id" type="abbreviation">a</span></a></span>, and your counterexample needs to
    exhibit an <span class="inlinecode"><a class="idref" href="Records.html#STLCExtendedRecords.a"><span class="id" type="abbreviation">a</span></a></span> for which the rule doesn't work. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab545"></a><h4 class="section">Exercise: 3 stars, advanced (hoare_asgn_fwd)</h4>
 However, using an auxiliary variable <span class="inlinecode"><a class="idref" href="MoreStlc.html#STLCExtended.Examples.m"><span class="id" type="abbreviation">m</span></a></span> to remember the original
    value of <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> we can define a Hoare rule for assignment that does,
    intuitively, "work forwards" rather than backwards.
<hr/>
 (hoare_asgn_fwd)
  <a href="fun st => P st /\ st X = m">fun st => P st /\ st X = m</a>
    X ::= a
  <a href="fun st => P st' /\ st X = aeval st' a ">fun st => P st' /\ st X = aeval st' a </a>
  (where st' = update st X m)
    Note that we use the original value of <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> to reconstruct the
    state <span class="inlinecode"><a class="idref" href="Imp.html#st'"><span class="id" type="variable">st'</span></a></span> before the assignment took place. Prove that this rule
    is correct (the first hypothesis is the functional extensionality
    axiom, which you will need at some point). Also note that this
    rule is more complicated than <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a></span>.

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="hoare_asgn_fwd"><span class="id" type="lemma">hoare_asgn_fwd</span></a> :<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> {<span class="id" type="var">X</span> <span class="id" type="var">Y</span>: <span class="id" type="keyword">Type</span>} {<span class="id" type="var">f</span> <span class="id" type="var">g</span> : <a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a> → <a class="idref" href="Hoare.html#Y"><span class="id" type="variable">Y</span></a>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> (<span class="id" type="var">x</span>: <a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a>), <a class="idref" href="Hoare.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="Hoare.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="Hoare.html#x"><span class="id" type="variable">x</span></a>) →  <a class="idref" href="Hoare.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare.html#g"><span class="id" type="variable">g</span></a>) →<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> <span class="id" type="var">m</span> <span class="id" type="var">a</span> <span class="id" type="var">P</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare.html#m"><span class="id" type="variable">m</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Hoare.html#a"><span class="id" type="variable">a</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Hoare.html#m"><span class="id" type="variable">m</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Hoare.html#m"><span class="id" type="variable">m</span></a>) <a class="idref" href="Hoare.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">functional_extensionality</span> <span class="id" type="var">m</span> <span class="id" type="var">a</span> <span class="id" type="var">P</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab546"></a><h4 class="section">Exercise: 2 stars, advanced (hoare_asgn_fwd_exists)</h4>
 Another way to define a forward rule for assignment is to
    existentially quantify over the previous value of the assigned
    variable.
<hr/>
 (hoare_asgn_fwd_exists)
  <a href="fun st => P st">fun st => P st</a>
    X ::= a
  <a href="fun st => exists m, P (update st X m) /\
                 st X = aeval (update st X m) a ">fun st => exists m, P (update st X m) /\
                 st X = aeval (update st X m) a </a>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="hoare_asgn_fwd_exists"><span class="id" type="lemma">hoare_asgn_fwd_exists</span></a> :<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> {<span class="id" type="var">X</span> <span class="id" type="var">Y</span>: <span class="id" type="keyword">Type</span>} {<span class="id" type="var">f</span> <span class="id" type="var">g</span> : <a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a> → <a class="idref" href="Hoare.html#Y"><span class="id" type="variable">Y</span></a>},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> (<span class="id" type="var">x</span>: <a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a>), <a class="idref" href="Hoare.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="Hoare.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare.html#g"><span class="id" type="variable">g</span></a> <a class="idref" href="Hoare.html#x"><span class="id" type="variable">x</span></a>) →  <a class="idref" href="Hoare.html#f"><span class="id" type="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare.html#g"><span class="id" type="variable">g</span></a>) →<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> <span class="id" type="var">P</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Hoare.html#a"><span class="id" type="variable">a</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <span class="id" type="var">m</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Hoare.html#m"><span class="id" type="variable">m</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Hoare.html#m"><span class="id" type="variable">m</span></a>) <a class="idref" href="Hoare.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">functional_extensionality</span> <span class="id" type="var">a</span> <span class="id" type="var">P</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab547"></a><h3 class="section">Consequence</h3>

<div class="paragraph"> </div>

 Sometimes the preconditions and postconditions we get from the
    Hoare rules won't quite be the ones we want in the particular
    situation at hand -- they may be logically equivalent but have a
    different syntactic form that fails to unify with the goal we are
    trying to prove, or they actually may be logically weaker (for
    preconditions) or stronger (for postconditions) than what we need.

<div class="paragraph"> </div>

    For instance, while
      <a href="(X = 3) [X |-> 3]">(X = 3) [X |-> 3]</a> X ::= 3 <a href="X = 3">X = 3</a>,
    follows directly from the assignment rule, 
      <a href="True">True</a> X ::= 3 <a href="X = 3">X = 3</a>.
    does not.  This triple is valid, but it is not an instance of
    <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a></span> because <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a></span> and <span class="inlinecode">(<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">3)</span> <span class="inlinecode">[<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">|-&gt;</span> <span class="inlinecode">3]</span> are not
    syntactically equal assertions.  However, they are logically
    equivalent, so if one triple is valid, then the other must
    certainly be as well.  We might capture this observation with the
    following rule:
                <a href="P'">P'</a> c <a href="Q">Q</a>
                  P <tt>-</tt> P'
<hr/>
   (hoare_consequence_pre_equiv)
                <a href="P">P</a> c <a href="Q">Q</a>
    Taking this line of thought a bit further, we can see that
    strengthening the precondition or weakening the postcondition of a
    valid triple always produces another valid triple. This
    observation is captured by two <i>Rules of Consequence</i>.
                <a href="P'">P'</a> c <a href="Q">Q</a>
                   P -&gt;&gt; P'
<hr/>
   (hoare_consequence_pre)
                <a href="P">P</a> c <a href="Q">Q</a>

<div class="paragraph"> </div>

                <a href="P">P</a> c <a href="Q'">Q'</a>
                  Q' -&gt;&gt; Q 
<hr/>
    (hoare_consequence_post)
                <a href="P">P</a> c <a href="Q">Q</a>

<div class="paragraph"> </div>

 Here are the formal versions: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">P</span> <span class="id" type="var">P'</span> <span class="id" type="var">Q</span> : <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a>) <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">-&gt;&gt;</span></a> <a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">P'</span> <span class="id" type="var">Q</span> <span class="id" type="var">c</span> <span class="id" type="var">Hhoare</span> <span class="id" type="var">Himp</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">Hc</span> <span class="id" type="var">HP</span>. <span class="id" type="tactic">apply</span> (<span class="id" type="var">Hhoare</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">Himp</span>. <span class="id" type="tactic">assumption</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="hoare_consequence_post"><span class="id" type="lemma">hoare_consequence_post</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">Q'</span> : <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a>) <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q'"><span class="id" type="variable">Q'</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#Q'"><span class="id" type="variable">Q'</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">-&gt;&gt;</span></a> <a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">Q'</span> <span class="id" type="var">c</span> <span class="id" type="var">Hhoare</span> <span class="id" type="var">Himp</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">Hc</span> <span class="id" type="var">HP</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">Himp</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">Hhoare</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">assumption</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
For example, we might use the first consequence rule like this:
                <a href=" True "> True </a> -&gt;&gt;
                <a href=" 1 = 1 "> 1 = 1 </a> 
    X ::= 1
                <a href=" X = 1 "> X = 1 </a>
    Or, formally... 

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="hoare_asgn_example1"><span class="id" type="definition">hoare_asgn_example1</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1<a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">)</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 1<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">with</span> (<span class="id" type="var">P'</span> := <a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">(</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 1<a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">[</span></a><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">|-&gt;</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1<a class="idref" href="Hoare.html#::x_'['_x_'|->'_x_']'"><span class="id" type="notation">]</span></a>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#assn_sub"><span class="id" type="definition">assn_sub</span></a>, <a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Finally, for convenience in some proofs, we can state a "combined"
    rule of consequence that allows us to vary both the precondition
    and the postcondition. 
                <a href="P'">P'</a> c <a href="Q'">Q'</a>
                   P -&gt;&gt; P'
                   Q' -&gt;&gt; Q
<hr/>
   (hoare_consequence)
                <a href="P">P</a> c <a href="Q">Q</a>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="hoare_consequence"><span class="id" type="lemma">hoare_consequence</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">P</span> <span class="id" type="var">P'</span> <span class="id" type="var">Q</span> <span class="id" type="var">Q'</span> : <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a>) <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q'"><span class="id" type="variable">Q'</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">-&gt;&gt;</span></a> <a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#Q'"><span class="id" type="variable">Q'</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:x_'->>'_x"><span class="id" type="notation">-&gt;&gt;</span></a> <a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">P'</span> <span class="id" type="var">Q</span> <span class="id" type="var">Q'</span> <span class="id" type="var">c</span> <span class="id" type="var">Hht</span> <span class="id" type="var">HPP'</span> <span class="id" type="var">HQ'Q</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">P'</span> := <span class="id" type="var">P'</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_consequence_post"><span class="id" type="lemma">hoare_consequence_post</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">Q'</span> := <span class="id" type="var">Q'</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">assumption</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab548"></a><h3 class="section">Digression: The <span class="inlinecode"><span class="id" type="tactic">eapply</span></span> Tactic</h3>

<div class="paragraph"> </div>

 This is a good moment to introduce another convenient feature of
    Coq.  We had to write "<span class="inlinecode"><span class="id" type="keyword">with</span></span> <span class="inlinecode">(<a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a></span> <span class="inlinecode">:=</span> <span class="inlinecode">...)</span>" explicitly in the proof
    of <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_asgn_example1"><span class="id" type="definition">hoare_asgn_example1</span></a></span> and <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_consequence"><span class="id" type="lemma">hoare_consequence</span></a></span> above, to make
    sure that all of the metavariables in the premises to the
    <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a></span> rule would be set to specific
    values.  (Since <span class="inlinecode"><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a></span> doesn't appear in the conclusion of
    <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a></span>, the process of unifying the conclusion
    with the current goal doesn't constrain <span class="inlinecode"><a class="idref" href="Hoare.html#P'"><span class="id" type="variable">P'</span></a></span> to a specific
    assertion.)

<div class="paragraph"> </div>

    This is a little annoying, both because the assertion is a bit
    long and also because for <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_asgn_example1"><span class="id" type="definition">hoare_asgn_example1</span></a></span> the very next
    thing we are going to do -- applying the <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a></span> rule -- will
    tell us exactly what it should be!  We can use <span class="inlinecode"><span class="id" type="tactic">eapply</span></span> instead of
    <span class="inlinecode"><span class="id" type="tactic">apply</span></span> to tell Coq, essentially, "Be patient: The missing part is
    going to be filled in soon." 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="hoare_asgn_example1'"><span class="id" type="definition">hoare_asgn_example1'</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1<a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">)</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">)</span></a> <br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 1<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
In general, <span class="inlinecode"><span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><a class="idref" href="ProofObjects.html#H"><span class="id" type="variable">H</span></a></span> tactic works just like <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><a class="idref" href="ProofObjects.html#H"><span class="id" type="variable">H</span></a></span> except
    that, instead of failing if unifying the goal with the conclusion
    of <span class="inlinecode"><a class="idref" href="ProofObjects.html#H"><span class="id" type="variable">H</span></a></span> does not determine how to instantiate all of the variables
    appearing in the premises of <span class="inlinecode"><a class="idref" href="ProofObjects.html#H"><span class="id" type="variable">H</span></a></span>, <span class="inlinecode"><span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><a class="idref" href="ProofObjects.html#H"><span class="id" type="variable">H</span></a></span> will replace these
    variables with so-called <i>existential variables</i> (written <span class="inlinecode">?<span class="id" type="var">nnn</span></span>)
    as placeholders for expressions that will be determined (by
    further unification) later in the proof. 
<div class="paragraph"> </div>

 In order for <span class="inlinecode"><span class="id" type="keyword">Qed</span></span> to succeed, all existential variables need to
    be determined by the end of the proof. Otherwise Coq
    will (rightly) refuse to accept the proof. Remember that the Coq
    tactics build proof objects, and proof objects containing
    existential variables are not complete. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="silly1"><span class="id" type="lemma">silly1</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">Q</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Hoare.html#y"><span class="id" type="variable">y</span></a>) →<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Hoare.html#y"><span class="id" type="variable">y</span></a> → <a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Hoare.html#x"><span class="id" type="variable">x</span></a>) →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> 42.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>. <span class="id" type="tactic">eapply</span> <span class="id" type="var">HQ</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>.<br/>

<br/>
</div>

<div class="doc">
Coq gives a warning after <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">HP</span></span>:
     No more subgoals but non-instantiated existential variables:
     Existential 1 =
     ?171 : <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Poly.html#Church.nat"><span class="id" type="definition">nat</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="Poly.html#Church.nat"><span class="id" type="definition">nat</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>
             <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Poly.html#Church.nat"><span class="id" type="definition">nat</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>
             <span class="inlinecode"><span class="id" type="var">HP</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="RecordSub.html#Examples.x"><span class="id" type="abbreviation">x</span></a></span> <span class="inlinecode"><a class="idref" href="RecordSub.html#Examples.y"><span class="id" type="abbreviation">y</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Poly.html#Church.nat"><span class="id" type="definition">nat</span></a>,</span> <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <span class="inlinecode"><a class="idref" href="RecordSub.html#Examples.x"><span class="id" type="abbreviation">x</span></a></span> <span class="inlinecode"><a class="idref" href="RecordSub.html#Examples.y"><span class="id" type="abbreviation">y</span></a></span>
             <span class="inlinecode"><span class="id" type="var">HQ</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="RecordSub.html#Examples.x"><span class="id" type="abbreviation">x</span></a></span> <span class="inlinecode"><a class="idref" href="RecordSub.html#Examples.y"><span class="id" type="abbreviation">y</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Poly.html#Church.nat"><span class="id" type="definition">nat</span></a>,</span> <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <span class="inlinecode"><a class="idref" href="RecordSub.html#Examples.x"><span class="id" type="abbreviation">x</span></a></span> <span class="inlinecode"><a class="idref" href="RecordSub.html#Examples.y"><span class="id" type="abbreviation">y</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> <span class="inlinecode"><a class="idref" href="RecordSub.html#Examples.x"><span class="id" type="abbreviation">x</span></a></span> <span class="inlinecode">|-</span> <span class="inlinecode"><a class="idref" href="Poly.html#Church.nat"><span class="id" type="definition">nat</span></a></span> 

<div class="paragraph"> </div>

     (dependent evars: ?171 open,)

<div class="paragraph"> </div>

     You can use Grab Existential Variables.
   Trying to finish the proof with <span class="inlinecode"><span class="id" type="keyword">Qed</span></span> gives an error:
<pre>
    Error: Attempt to save a proof with existential variables still
    non-instantiated
</pre>
 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
An additional constraint is that existential variables cannot be
    instantiated with terms containing (ordinary) variables that did
    not exist at the time the existential variable was created. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="silly2"><span class="id" type="lemma">silly2</span></a> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">Q</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <span class="id" type="var">y</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> 42 <a class="idref" href="Hoare.html#y"><span class="id" type="variable">y</span></a>) →<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Hoare.html#y"><span class="id" type="variable">y</span></a> → <a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Hoare.html#x"><span class="id" type="variable">x</span></a>) →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> 42.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>. <span class="id" type="tactic">eapply</span> <span class="id" type="var">HQ</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">HP</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">y</span> <span class="id" type="var">HP'</span>].<br/>
</div>

<div class="doc">
Doing <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">HP'</span></span> above fails with the following error:
     Error: Impossible to unify "?175" with "y".
    In this case there is an easy fix:
    doing <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> <span class="inlinecode"><span class="id" type="var">HP</span></span> <i>before</i> doing <span class="inlinecode"><span class="id" type="tactic">eapply</span></span> <span class="inlinecode"><span class="id" type="var">HQ</span></span>.

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Abort</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="silly2_fixed"><span class="id" type="lemma">silly2_fixed</span></a> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> (<span class="id" type="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">Q</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <span class="id" type="var">y</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> 42 <a class="idref" href="Hoare.html#y"><span class="id" type="variable">y</span></a>) →<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Hoare.html#y"><span class="id" type="variable">y</span></a> → <a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Hoare.html#x"><span class="id" type="variable">x</span></a>) →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> 42.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">HP</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">y</span> <span class="id" type="var">HP'</span>].<br/>
&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <span class="id" type="var">HQ</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HP'</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
In the last step we did <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">HP'</span></span> which unifies the existential
    variable in the goal with the variable <span class="inlinecode"><a class="idref" href="RecordSub.html#Examples.y"><span class="id" type="abbreviation">y</span></a></span>. The <span class="inlinecode"><span class="id" type="tactic">assumption</span></span>
    tactic doesn't work in this case, since it cannot handle
    existential variables. However, Coq also provides an <span class="inlinecode"><span class="id" type="var">eassumption</span></span>
    tactic that solves the goal if one of the premises matches the
    goal up to instantiations of existential variables. We can use
    it instead of <span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">HP'</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="silly2_eassumption"><span class="id" type="lemma">silly2_eassumption</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">P</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span>) (<span class="id" type="var">Q</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span>),<br/>
&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">∃</span></a> <span class="id" type="var">y</span><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'exists'_x_'..'_x_','_x"><span class="id" type="notation">,</span></a> <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> 42 <a class="idref" href="Hoare.html#y"><span class="id" type="variable">y</span></a>) →<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">∀</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="Hoare.html#y"><span class="id" type="variable">y</span></a> → <a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Hoare.html#x"><span class="id" type="variable">x</span></a>) →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> 42.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">HP</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">y</span> <span class="id" type="var">HP'</span>]. <span class="id" type="tactic">eapply</span> <span class="id" type="var">HQ</span>. <span class="id" type="var">eassumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
<a name="lab549"></a><h4 class="section">Exercise: 2 stars (hoare_asgn_examples_2)</h4>
 Translate these informal Hoare triples...
       <a href=" X + 1 <= 5 "> X + 1 <= 5 </a>  X ::= X + 1  <a href=" X <= 5 "> X <= 5 </a>
       <a href=" 0 <= 3 /\ 3 <= 5 "> 0 <= 3 /\ 3 <= 5 </a>  X ::= 3  <a href=" 0 <= X /\ X <= 5 "> 0 <= X /\ X <= 5 </a>
   ...into formal statements <span class="inlinecode"><span class="id" type="var">assn_sub_ex1'</span>,</span> <span class="inlinecode"><span class="id" type="var">assn_sub_ex2'</span></span> and 
   use <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a></span> and <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a></span> to prove them. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab550"></a><h3 class="section">Skip</h3>

<div class="paragraph"> </div>

 Since <span class="inlinecode"><span class="id" type="var">SKIP</span></span> doesn't change the state, it preserves any
    property P:
<hr/>
  (hoare_skip)
      <a href=" P "> P </a> SKIP <a href=" P "> P </a>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="hoare_skip"><span class="id" type="lemma">hoare_skip</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">H</span> <span class="id" type="var">HP</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab551"></a><h3 class="section">Sequencing</h3>

<div class="paragraph"> </div>

 More interestingly, if the command <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> takes any state where
    <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> holds to a state where <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> holds, and if <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> takes any
    state where <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> holds to one where <span class="inlinecode"><a class="idref" href="Norm.html#R"><span class="id" type="definition">R</span></a></span> holds, then doing <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span>
    followed by <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> will take any state where <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> holds to one
    where <span class="inlinecode"><a class="idref" href="Norm.html#R"><span class="id" type="definition">R</span></a></span> holds:
        <a href=" P "> P </a> c1 <a href=" Q "> Q </a> 
        <a href=" Q "> Q </a> c2 <a href=" R "> R </a>
<hr/>
  (hoare_seq)
       <a href=" P "> P </a> c1;;c2 <a href=" R "> R </a>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="hoare_seq"><span class="id" type="lemma">hoare_seq</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#R"><span class="id" type="variable">R</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a><a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#R"><span class="id" type="variable">R</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span> <span class="id" type="var">H1</span> <span class="id" type="var">H2</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">H12</span> <span class="id" type="var">Pre</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H12</span>; <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">H1</span> <span class="id" type="var">st'0</span> <span class="id" type="var">st'</span>); <span class="id" type="tactic">try</span> <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">H2</span> <span class="id" type="var">st</span> <span class="id" type="var">st'0</span>); <span class="id" type="tactic">assumption</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Note that, in the formal rule <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_seq"><span class="id" type="lemma">hoare_seq</span></a></span>, the premises are
    given in "backwards" order (<span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> before <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span>).  This matches the
    natural flow of information in many of the situations where we'll
    use the rule: the natural way to construct a Hoare-logic proof is
    to begin at the end of the program (with the final postcondition)
    and push postconditions backwards through commands until we reach
    the beginning. 
<div class="paragraph"> </div>

 Informally, a nice way of recording a proof using the sequencing
    rule is as a "decorated program" where the intermediate assertion
    <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> is written between <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> and <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span>:
      <a href=" a = n "> a = n </a>
    X ::= a;;
      <a href=" X = n "> X = n </a>      &lt;---- decoration for Q
    SKIP
      <a href=" X = n "> X = n </a>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="hoare_asgn_example3"><span class="id" type="definition">hoare_asgn_example3</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">a</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare.html#n"><span class="id" type="variable">n</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Hoare.html#a"><span class="id" type="variable">a</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">)</span></a> <br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare.html#n"><span class="id" type="variable">n</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">a</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_seq"><span class="id" type="lemma">hoare_seq</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "right part of seq".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_skip"><span class="id" type="lemma">hoare_skip</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "left part of seq".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">subst</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
You will most often use <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_seq"><span class="id" type="lemma">hoare_seq</span></a></span> and
    <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a></span> in conjunction with the <span class="inlinecode"><span class="id" type="tactic">eapply</span></span> tactic,
    as done above. 
<div class="paragraph"> </div>

<a name="lab552"></a><h4 class="section">Exercise: 2 stars (hoare_asgn_example4)</h4>
 Translate this "decorated program" into a formal proof:
                   <a href=" True "> True </a> -&gt;&gt;
                   <a href=" 1 = 1 "> 1 = 1 </a>
    X ::= 1;;
                   <a href=" X = 1 "> X = 1 </a> -&gt;&gt;
                   <a href=" X = 1 /\ 2 = 2 "> X = 1 /\ 2 = 2 </a>
    Y ::= 2
                   <a href=" X = 1 /\ Y = 2 "> X = 1 /\ Y = 2 </a>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="hoare_asgn_example4"><span class="id" type="definition">hoare_asgn_example4</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1<a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">)</span></a><a class="idref" href="Imp.html#::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 2<a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">)</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">)</span></a> <br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 2<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab553"></a><h4 class="section">Exercise: 3 stars (swap_exercise)</h4>
 Write an Imp program <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> that swaps the values of <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> and <span class="inlinecode"><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a></span>
    and show (in Coq) that it satisfies the following
    specification:
      <a href="X <= Y">X <= Y</a> c <a href="Y <= X">Y <= X</a>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="swap_program"><span class="id" type="definition">swap_program</span></a> : <a class="idref" href="Imp.html#com"><span class="id" type="inductive">com</span></a> :=<br/>
&nbsp;&nbsp; <a class="idref" href="SfLib.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="swap_exercise"><span class="id" type="lemma">swap_exercise</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#swap_program"><span class="id" type="definition">swap_program</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab554"></a><h4 class="section">Exercise: 3 stars (hoarestate1)</h4>
 Explain why the following proposition can't be proven:
      forall (a : aexp) (n : nat),
         <a href="fun st => aeval st a = n">fun st => aeval st a = n</a>
         (X ::= (ANum 3);; Y ::= a)
         <a href="fun st => st Y = n">fun st => st Y = n</a>.

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab555"></a><h3 class="section">Conditionals</h3>

<div class="paragraph"> </div>

 What sort of rule do we want for reasoning about conditional
    commands?  Certainly, if the same assertion <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> holds after
    executing either branch, then it holds after the whole
    conditional.  So we might be tempted to write:
              <a href="P">P</a> c1 <a href="Q">Q</a>
              <a href="P">P</a> c2 <a href="Q">Q</a>
<hr/>

      <a href="P">P</a> IFB b THEN c1 ELSE c2 <a href="Q">Q</a>
   However, this is rather weak. For example, using this rule,
   we cannot show that:
     <a href=" True "> True </a> 
     IFB X == 0
     THEN Y ::= 2
     ELSE Y ::= X + 1 
     FI
     <a href=" X <= Y "> X <= Y </a>
   since the rule tells us nothing about the state in which the
   assignments take place in the "then" and "else" branches. 
<div class="paragraph"> </div>

 But we can actually say something more precise.  In the
   "then" branch, we know that the boolean expression <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> evaluates to
   <span class="inlinecode"><a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a></span>, and in the "else" branch, we know it evaluates to <span class="inlinecode"><a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a></span>.
   Making this information available in the premises of the rule gives
   us more information to work with when reasoning about the behavior
   of <span class="inlinecode"><a class="idref" href="Prop.html#R.c1"><span class="id" type="constructor">c1</span></a></span> and <span class="inlinecode"><a class="idref" href="Prop.html#R.c2"><span class="id" type="constructor">c2</span></a></span> (i.e., the reasons why they establish the
   postcondition <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span>). 
<div class="paragraph"> </div>

              <a href="P /\  b">P /\  b</a> c1 <a href="Q">Q</a>
              <a href="P /\ ~b">P /\ ~b</a> c2 <a href="Q">Q</a>
<hr/>
  (hoare_if)
      <a href="P">P</a> IFB b THEN c1 ELSE c2 FI <a href="Q">Q</a> 

<div class="paragraph"> </div>

 To interpret this rule formally, we need to do a little work.
    Strictly speaking, the assertion we've written, <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span>, is the
    conjunction of an assertion and a boolean expression -- i.e., it
    doesn't typecheck.  To fix this, we need a way of formally
    "lifting" any bexp <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> to an assertion.  We'll write <span class="inlinecode"><a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> for
    the assertion "the boolean expression <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> evaluates to <span class="inlinecode"><a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a></span> (in
    the given state)." 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="bassn"><span class="id" type="definition">bassn</span></a> <span class="id" type="var">b</span> : <a class="idref" href="Hoare.html#Assertion"><span class="id" type="definition">Assertion</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ (<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a>).<br/>

<br/>
</div>

<div class="doc">
A couple of useful facts about <span class="inlinecode"><a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a></span>: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="bexp_eval_true"><span class="id" type="lemma">bexp_eval_true</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> <span class="id" type="var">st</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a> → (<a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a> <a class="idref" href="Hoare.html#b"><span class="id" type="variable">b</span></a>) <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">st</span> <span class="id" type="var">Hbe</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a>. <span class="id" type="tactic">assumption</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <a name="bexp_eval_false"><span class="id" type="lemma">bexp_eval_false</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b</span> <span class="id" type="var">st</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a>(<a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a> <a class="idref" href="Hoare.html#b"><span class="id" type="variable">b</span></a>) <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">st</span> <span class="id" type="var">Hbe</span> <span class="id" type="var">contra</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">contra</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> → <span class="id" type="var">contra</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hbe</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">Hbe</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Now we can formalize the Hoare proof rule for conditionals
    and prove it correct. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="hoare_if"><span class="id" type="lemma">hoare_if</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">b</span> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a> <a class="idref" href="Hoare.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">~(</span></a><a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a> <a class="idref" href="Hoare.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Hoare.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">b</span> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span> <span class="id" type="var">HTrue</span> <span class="id" type="var">HFalse</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">HE</span> <span class="id" type="var">HP</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">HE</span>; <span class="id" type="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "b is true".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">HTrue</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">split</span>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#bexp_eval_true"><span class="id" type="lemma">bexp_eval_true</span></a>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "b is false".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">HFalse</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">split</span>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#bexp_eval_false"><span class="id" type="lemma">bexp_eval_false</span></a>. <span class="id" type="tactic">assumption</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
<a name="lab556"></a><h1 class="section">Hoare Logic: So Far</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Idea: create a <i>domain specific logic</i> for reasoning about properties of Imp programs.

<div class="paragraph"> </div>

<ul class="doclist">
<li> This hides the low-level details of the semantics of the program

</li>
<li> Leads to a compositional reasoning process

</li>
</ul>

<div class="paragraph"> </div>

The basic structure is given by <i>Hoare triples</i> of the form:
  <a href="P">P</a> c <a href="Q">Q</a>
]] 

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> and <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> are predicates about the state of the Imp program

</li>
<li> "If command <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> is started in a state satisfying assertion
        <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span>, and if <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> eventually terminates in some final state,
        then this final state will satisfy the assertion <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span>."

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab557"></a><h2 class="section">Hoare Logic Rules (so far)</h2>

<div class="paragraph"> </div>

<hr/>
 (hoare_asgn)
             <a href="Q [X |-> a]">Q [X |-> a]</a> X::=a <a href="Q">Q</a>
<hr/>
  (hoare_skip)
             <a href=" P "> P </a> SKIP <a href=" P "> P </a>

<div class="paragraph"> </div>

               <a href=" P "> P </a> c1 <a href=" Q "> Q </a> 
               <a href=" Q "> Q </a> c2 <a href=" R "> R </a>
<hr/>
  (hoare_seq)
              <a href=" P "> P </a> c1;;c2 <a href=" R "> R </a>

<div class="paragraph"> </div>

              <a href="P /\  b">P /\  b</a> c1 <a href="Q">Q</a>
              <a href="P /\ ~b">P /\ ~b</a> c2 <a href="Q">Q</a>
<hr/>
  (hoare_if)
      <a href="P">P</a> IFB b THEN c1 ELSE c2 FI <a href="Q">Q</a> 

<div class="paragraph"> </div>

                <a href="P'">P'</a> c <a href="Q'">Q'</a>
                   P -&gt;&gt; P'
                   Q' -&gt;&gt; Q
<hr/>
   (hoare_consequence)
                <a href="P">P</a> c <a href="Q">Q</a>

<div class="paragraph"> </div>

<a name="lab558"></a><h3 class="section">Example</h3>
 Here is a formal proof that the program we used to motivate the
    rule satisfies the specification we gave. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="if_example"><span class="id" type="definition">if_example</span></a> : <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0)<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">)</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 2<a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">)</span></a><a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">)</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">)</span></a> <br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_if"><span class="id" type="lemma">hoare_if</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "Then".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a>, <a class="idref" href="Hoare.html#assn_sub"><span class="id" type="definition">assn_sub</span></a>, <a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a>, <a class="idref" href="Hoare.html#assert_implies"><span class="id" type="definition">assert_implies</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> [<span class="id" type="var">_</span> <span class="id" type="var">H</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Arith.EqNat.html#beq_nat_true"><span class="id" type="lemma">beq_nat_true</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "Else".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#assn_sub"><span class="id" type="definition">assn_sub</span></a>, <a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a>, <a class="idref" href="Hoare.html#assert_implies"><span class="id" type="definition">assert_implies</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> <span class="id" type="var">_</span>. <span class="id" type="tactic">omega</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab559"></a><h4 class="section">Exercise: 2 stars (if_minus_plus)</h4>
 Prove the following hoare triple using <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_if"><span class="id" type="lemma">hoare_if</span></a></span>: 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="if_minus_plus"><span class="id" type="lemma">if_minus_plus</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BLe"><span class="id" type="constructor">BLe</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>)<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#AMinus"><span class="id" type="constructor">AMinus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>)<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a>)<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab560"></a><h3 class="section">Exercise: One-sided conditionals</h3>

<div class="paragraph"> </div>

<a name="lab561"></a><h4 class="section">Exercise: 4 stars (if1_hoare)</h4>

<div class="paragraph"> </div>

 In this exercise we consider extending Imp with "one-sided
    conditionals" of the form <span class="inlinecode"><span class="id" type="var">IF1</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">THEN</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode"><span class="id" type="var">FI</span></span>. Here <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> is a
    boolean expression, and <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> is a command. If <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> evaluates to
    <span class="inlinecode"><a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a></span>, then command <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> is evaluated. If <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> evaluates to
    <span class="inlinecode"><a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a></span>, then <span class="inlinecode"><span class="id" type="var">IF1</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> <span class="inlinecode"><span class="id" type="var">THEN</span></span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode"><span class="id" type="var">FI</span></span> does nothing.

<div class="paragraph"> </div>

    We recommend that you do this exercise before the ones that
    follow, as it should help solidify your understanding of the
    material. 
<div class="paragraph"> </div>

 The first step is to extend the syntax of commands and introduce
    the usual notations.  (We've done this for you.  We use a separate
    module to prevent polluting the global name space.) 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Module</span> <a name="If1"><span class="id" type="module">If1</span></a>.<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <a name="If1.com"><span class="id" type="inductive">com</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="If1.CSkip"><span class="id" type="constructor">CSkip</span></a> : <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="If1.CAss"><span class="id" type="constructor">CAss</span></a> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="If1.CSeq"><span class="id" type="constructor">CSeq</span></a> : <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="If1.CIf"><span class="id" type="constructor">CIf</span></a> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="If1.CWhile"><span class="id" type="constructor">CWhile</span></a> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="If1.CIf1"><span class="id" type="constructor">CIf1</span></a> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "com_cases" <span class="id" type="var">tactic</span>(<span class="id" type="tactic">first</span>) <span class="id" type="var">ident</span>(<span class="id" type="var">c</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span>;<br/>
&nbsp;&nbsp;[ <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "SKIP" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "::=" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> ";"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "IFB" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "WHILE" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "CIF1" ].<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name="If1.::'SKIP'"><span class="id" type="notation">"</span></a>'SKIP'" := <br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#If1.CSkip"><span class="id" type="constructor">CSkip</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="If1.::x_';;'_x"><span class="id" type="notation">"</span></a>c1 ;; c2" := <br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#If1.CSeq"><span class="id" type="constructor">CSeq</span></a> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="If1.::x_'::='_x"><span class="id" type="notation">"</span></a>X '::=' a" := <br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#If1.CAss"><span class="id" type="constructor">CAss</span></a> <span class="id" type="var">X</span> <span class="id" type="var">a</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 60).<br/>
<span class="id" type="keyword">Notation</span> <a name="If1.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">"</span></a>'WHILE' b 'DO' c 'END'" := <br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#If1.CWhile"><span class="id" type="constructor">CWhile</span></a> <span class="id" type="var">b</span> <span class="id" type="var">c</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="If1.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">"</span></a>'IFB' e1 'THEN' e2 'ELSE' e3 'FI'" := <br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#If1.CIf"><span class="id" type="constructor">CIf</span></a> <span class="id" type="var">e1</span> <span class="id" type="var">e2</span> <span class="id" type="var">e3</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="If1.::'IF1'_x_'THEN'_x_'FI'"><span class="id" type="notation">"</span></a>'IF1' b 'THEN' c 'FI'" := <br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#If1.CIf1"><span class="id" type="constructor">CIf1</span></a> <span class="id" type="var">b</span> <span class="id" type="var">c</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>

<br/>
</div>

<div class="doc">
Next we need to extend the evaluation relation to accommodate
    <span class="inlinecode"><span class="id" type="var">IF1</span></span> branches.  This is for you to do... What rule(s) need to be
    added to <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.ceval"><span class="id" type="inductive">ceval</span></a></span> to evaluate one-sided conditionals? 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Reserved Notation</span> "c1 '/' st '||' st'" (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 40, <span class="id" type="var">st</span> <span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 39).<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <a name="If1.ceval"><span class="id" type="inductive">ceval</span></a> : <a class="idref" href="Hoare.html#If1.com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> → <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="If1.E_Skip"><span class="id" type="constructor">E_Skip</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>, <a class="idref" href="Hoare.html#If1.::'SKIP'"><span class="id" type="notation">SKIP</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a><br/>
&nbsp;&nbsp;| <a name="If1.E_Ass"><span class="id" type="constructor">E_Ass</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">a1</span> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>) (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">X</span> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Hoare.html#If1.::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Hoare.html#a1"><span class="id" type="variable">a1</span></a><a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Hoare.html#n"><span class="id" type="variable">n</span></a><br/>
&nbsp;&nbsp;| <a name="If1.E_Seq"><span class="id" type="constructor">E_Seq</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">c1</span> <span class="id" type="var">c2</span> : <a class="idref" href="Hoare.html#If1.com"><span class="id" type="inductive">com</span></a>) (<span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">st''</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> → <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st''"><span class="id" type="variable">st''</span></a> → <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#If1.::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a><a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st''"><span class="id" type="variable">st''</span></a><br/>
&nbsp;&nbsp;| <a name="If1.E_IfTrue"><span class="id" type="constructor">E_IfTrue</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> <span class="id" type="var">st'</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">b1</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) (<span class="id" type="var">c1</span> <span class="id" type="var">c2</span> : <a class="idref" href="Hoare.html#If1.com"><span class="id" type="inductive">com</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> → <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#If1.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Hoare.html#If1.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#If1.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Hoare.html#If1.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a><a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a><br/>
&nbsp;&nbsp;| <a name="If1.E_IfFalse"><span class="id" type="constructor">E_IfFalse</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> <span class="id" type="var">st'</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">b1</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) (<span class="id" type="var">c1</span> <span class="id" type="var">c2</span> : <a class="idref" href="Hoare.html#If1.com"><span class="id" type="inductive">com</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> → <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#If1.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Hoare.html#If1.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#If1.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Hoare.html#If1.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a><a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a><br/>
&nbsp;&nbsp;| <a name="If1.E_WhileEnd"><span class="id" type="constructor">E_WhileEnd</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">b1</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">c1</span> : <a class="idref" href="Hoare.html#If1.com"><span class="id" type="inductive">com</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> → <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#If1.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Hoare.html#If1.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#If1.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a><br/>
&nbsp;&nbsp;| <a name="If1.E_WhileLoop"><span class="id" type="constructor">E_WhileLoop</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">st''</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">b1</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) (<span class="id" type="var">c1</span> : <a class="idref" href="Hoare.html#If1.com"><span class="id" type="inductive">com</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#If1.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Hoare.html#If1.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#If1.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st''"><span class="id" type="variable">st''</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#If1.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Hoare.html#If1.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#If1.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st''"><span class="id" type="variable">st''</span></a><br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="id" type="keyword">where</span> <a name="If1.::x_'/'_x_'||'_x"><span class="id" type="notation">"</span></a>c1 '/' st '||' st'" := (<a class="idref" href="Hoare.html#ceval"><span class="id" type="inductive">ceval</span></a> <span class="id" type="var">c1</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>).<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "ceval_cases" <span class="id" type="var">tactic</span>(<span class="id" type="tactic">first</span>) <span class="id" type="var">ident</span>(<span class="id" type="var">c</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span>;<br/>
&nbsp;&nbsp;[ <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_Skip" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_Ass" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_Seq"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_IfTrue" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_IfFalse"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_WhileEnd" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_WhileLoop"<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;].<br/>

<br/>
</div>

<div class="doc">
Now we repeat (verbatim) the definition and notation of Hoare triples. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="If1.hoare_triple"><span class="id" type="definition">hoare_triple</span></a> (<span class="id" type="var">P</span>:<a class="idref" href="Hoare.html#If1.Assertion"><span class="id" type="definition">Assertion</span></a>) (<span class="id" type="var">c</span>:<a class="idref" href="Hoare.html#If1.com"><span class="id" type="inductive">com</span></a>) (<span class="id" type="var">Q</span>:<a class="idref" href="Hoare.html#If1.Assertion"><span class="id" type="definition">Assertion</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#If1.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a>  →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a>  →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name="If1.:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">"</span></a>{{ P }}  c  {{ Q }}" := (<a class="idref" href="Hoare.html#If1.hoare_triple"><span class="id" type="definition">hoare_triple</span></a> <span class="id" type="var">P</span> <span class="id" type="var">c</span> <span class="id" type="var">Q</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 90, <span class="id" type="var">c</span> <span class="id" type="tactic">at</span> <span class="id" type="var">next</span> <span class="id" type="keyword">level</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">hoare_spec_scope</span>.<br/>

<br/>
</div>

<div class="doc">
Finally, we (i.e., you) need to state and prove a theorem,
    <span class="inlinecode"><span class="id" type="var">hoare_if1</span></span>, that expresses an appropriate Hoare logic proof rule
    for one-sided conditionals. Try to come up with a rule that is
    both sound and as precise as possible. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
For full credit, prove formally <span class="inlinecode"><a class="idref" href="Hoare.html#If1.hoare_if1_good"><span class="id" type="lemma">hoare_if1_good</span></a></span> that your rule is 
    precise enough to show the following valid Hoare triple:
  <a href=" X + Y = Z "> X + Y = Z </a>
  IF1 Y &lt;&gt; 0 THEN
    X ::= X + Y
  FI
  <a href=" X = Z "> X = Z </a>

<div class="paragraph"> </div>

 Hint: Your proof of this triple may need to use the other proof
    rules also. Because we're working in a separate module, you'll
    need to copy here the rules you find necessary. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="If1.hoare_if1_good"><span class="id" type="lemma">hoare_if1_good</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#If1.:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'+'_x"><span class="id" type="notation">+</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="Hoare.html#If1.:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#If1.::'IF1'_x_'THEN'_x_'FI'"><span class="id" type="notation">IF1</span></a> <a class="idref" href="Imp.html#BNot"><span class="id" type="constructor">BNot</span></a> (<a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 0)) <a class="idref" href="Hoare.html#If1.::'IF1'_x_'THEN'_x_'FI'"><span class="id" type="notation">THEN</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Hoare.html#If1.::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>)<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#If1.::'IF1'_x_'THEN'_x_'FI'"><span class="id" type="notation">FI</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#If1.:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#Z"><span class="id" type="definition">Z</span></a> <a class="idref" href="Hoare.html#If1.:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.  <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Hoare.html#If1"><span class="id" type="module">If1</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab562"></a><h3 class="section">Loops</h3>

<div class="paragraph"> </div>

 Finally, we need a rule for reasoning about while loops. 
<div class="paragraph"> </div>

 Suppose we have a loop
      WHILE b DO c END
    and we want to find a pre-condition <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> and a post-condition
    <span class="inlinecode"><a class="idref" href="Logic.html#Q"><span class="id" type="variable">Q</span></a></span> such that
      <a href="P">P</a> WHILE b DO c END <a href="Q">Q</a> 
    is a valid triple. 
<div class="paragraph"> </div>

<a name="lab563"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 First of all, let's think about the case where <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> is false at the
    beginning -- i.e., let's assume that the loop body never executes
    at all.  In this case, the loop behaves like <span class="inlinecode"><span class="id" type="var">SKIP</span></span>, so we might
    be tempted to write: 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

      <a href="P">P</a> WHILE b DO c END <a href="P">P</a>.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

    But, as we remarked above for the conditional, we know a
    little more at the end -- not just <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span>, but also the fact
    that <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> is false in the current state.  So we can enrich the
    postcondition a little:

<div class="paragraph"> </div>

      <a href="P">P</a> WHILE b DO c END <a href="P /\ ~b">P /\ ~b</a>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

    What about the case where the loop body <i>does</i> get executed?
    In order to ensure that <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> holds when the loop finally
    exits, we certainly need to make sure that the command <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span>
    guarantees that <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> holds whenever <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> is finished.
    Moreover, since <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> holds at the beginning of the first
    execution of <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span>, and since each execution of <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span>
    re-establishes <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> when it finishes, we can always assume
    that <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> holds at the beginning of <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span>.  This leads us to the
    following rule:

<div class="paragraph"> </div>

                   <a href="P">P</a> c <a href="P">P</a>
<hr/>
  
        <a href="P">P</a> WHILE b DO c END <a href="P /\ ~b">P /\ ~b</a>

<div class="paragraph"> </div>

    This is almost the rule we want, but again it can be improved a
    little: at the beginning of the loop body, we know not only that
    <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> holds, but also that the guard <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.b"><span class="id" type="constructor">b</span></a></span> is true in the current
    state.  This gives us a little more information to use in
    reasoning about <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> (showing that it establishes the invariant by
    the time it finishes).  This gives us the final version of the rule:

<div class="paragraph"> </div>

               <a href="P /\ b">P /\ b</a> c <a href="P">P</a>
<hr/>
  (hoare_while)
        <a href="P">P</a> WHILE b DO c END <a href="P /\ ~b">P /\ ~b</a>
    The proposition <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> is called an <i>invariant</i> of the loop.

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <a name="hoare_while"><span class="id" type="lemma">hoare_while</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a> <a class="idref" href="Hoare.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Hoare.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Hoare.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'/\'_x"><span class="id" type="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a> <a class="idref" href="Hoare.html#b"><span class="id" type="variable">b</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:'~'_x"><span class="id" type="notation">)</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">Hhoare</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">He</span> <span class="id" type="var">HP</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <span class="id" type="var">b</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <span class="id" type="var">c</span> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>) <span class="id" type="keyword">as</span> <span class="id" type="var">wcom</span> <span class="id" type="var">eqn</span>:<span class="id" type="var">Heqwcom</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">ceval_cases</span> (<span class="id" type="tactic">induction</span> <span class="id" type="var">He</span>) <span class="id" type="var">Case</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> (<span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqwcom</span>); <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">Heqwcom</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "E_WhileEnd".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">split</span>. <span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#bexp_eval_false"><span class="id" type="lemma">bexp_eval_false</span></a>. <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "E_WhileLoop".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHHe2</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">Hhoare</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>). <span class="id" type="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">split</span>. <span class="id" type="tactic">assumption</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#bexp_eval_true"><span class="id" type="lemma">bexp_eval_true</span></a>. <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
    One subtlety in the terminology is that calling some assertion <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span>
    a "loop invariant" doesn't just mean that it is preserved by the
    body of the loop in question (i.e., <span class="inlinecode">{{<a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a>}}</span> <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> <span class="inlinecode">{{<a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a>}}</span>, where <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> is
    the loop body), but rather that <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <i>together with the fact that
    the loop's guard is true</i> is a sufficient precondition for <span class="inlinecode"><a class="idref" href="Poly.html#MumbleBaz.c"><span class="id" type="constructor">c</span></a></span> to
    ensure <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> as a postcondition.

<div class="paragraph"> </div>

    This is a slightly (but significantly) weaker requirement.  For
    example, if <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> is the assertion <span class="inlinecode"><a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>, then <span class="inlinecode"><a class="idref" href="UseAuto.html#P"><span class="id" type="axiom">P</span></a></span> <i>is</i> an
    invariant of the loop
    WHILE X = 2 DO X := 1 END
    although it is clearly <i>not</i> preserved by the body of the
    loop.

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Example</span> <a name="while_example"><span class="id" type="definition">while_example</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Peano.html#:nat_scope:x_'<='_x"><span class="id" type="notation">≤</span></a> 3<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BLe"><span class="id" type="constructor">BLe</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 2)<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">)</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Imp.html#::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1) <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒ <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> 3<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_post"><span class="id" type="lemma">hoare_consequence_post</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_while"><span class="id" type="lemma">hoare_while</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_asgn"><span class="id" type="lemma">hoare_asgn</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a>, <a class="idref" href="Hoare.html#assn_sub"><span class="id" type="definition">assn_sub</span></a>, <a class="idref" href="Hoare.html#assert_implies"><span class="id" type="definition">assert_implies</span></a>, <a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a>. <span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> [<span class="id" type="var">H1</span> <span class="id" type="var">H2</span>]. <span class="id" type="tactic">apply</span> <a class="idref" href="SfLib.html#ble_nat_true"><span class="id" type="axiom">ble_nat_true</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H2</span>. <span class="id" type="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="Hoare.html#bassn"><span class="id" type="definition">bassn</span></a>, <a class="idref" href="Hoare.html#assert_implies"><span class="id" type="definition">assert_implies</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> [<span class="id" type="var">Hle</span> <span class="id" type="var">Hb</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hb</span>. <span class="id" type="tactic">destruct</span> (<a class="idref" href="SfLib.html#ble_nat"><span class="id" type="definition">ble_nat</span></a> (<span class="id" type="var">st</span> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) 2) <span class="id" type="var">eqn</span> : <span class="id" type="var">Heqle</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="SfLib.html#ex_falso_quodlibet"><span class="id" type="lemma">ex_falso_quodlibet</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">Hb</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="SfLib.html#ble_nat_false"><span class="id" type="axiom">ble_nat_false</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">Heqle</span>. <span class="id" type="tactic">omega</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab564"></a><h3 class="section"> </h3>
 We can use the while rule to prove the following Hoare triple,
    which may seem surprising at first... 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Theorem</span> <a name="always_loop_hoare"><span class="id" type="lemma">always_loop_hoare</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Imp.html#BTrue"><span class="id" type="constructor">BTrue</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Imp.html#::'SKIP'"><span class="id" type="notation">SKIP</span></a> <a class="idref" href="Imp.html#::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a> <a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a><a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a><a class="idref" href="Hoare.html#:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_consequence_pre"><span class="id" type="lemma">hoare_consequence_pre</span></a> <span class="id" type="keyword">with</span> (<span class="id" type="var">P'</span> := <span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <a class="idref" href="Hoare.html#hoare_consequence_post"><span class="id" type="lemma">hoare_consequence_post</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_while"><span class="id" type="lemma">hoare_while</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "Loop body preserves invariant".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="Hoare.html#hoare_post_true"><span class="id" type="lemma">hoare_post_true</span></a>. <span class="id" type="tactic">intros</span> <span class="id" type="var">st</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#I"><span class="id" type="constructor">I</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "Loop invariant and negated guard imply postcondition".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> [<span class="id" type="var">Hinv</span> <span class="id" type="var">Hguard</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="SfLib.html#ex_falso_quodlibet"><span class="id" type="lemma">ex_falso_quodlibet</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">Hguard</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">Case</span> "Precondition implies invariant".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">st</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">constructor</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Of course, this result is not surprising if we remember that
    the definition of <span class="inlinecode"><a class="idref" href="Hoare.html#Himp.hoare_triple"><span class="id" type="definition">hoare_triple</span></a></span> asserts that the postcondition
    must hold <i>only</i> when the command terminates.  If the command
    doesn't terminate, we can prove anything we like about the
    post-condition. 
<div class="paragraph"> </div>

 Hoare rules that only talk about terminating commands are
    often said to describe a logic of "partial" correctness.  It is
    also possible to give Hoare rules for "total" correctness, which
    build in the fact that the commands terminate. However, in this
    course we will only talk about partial correctness. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab565"></a><h3 class="section">Exercise: <span class="inlinecode"><span class="id" type="var">REPEAT</span></span></h3>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Module</span> <a name="RepeatExercise"><span class="id" type="module">RepeatExercise</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab566"></a><h4 class="section">Exercise: 4 stars, advanced (hoare_repeat)</h4>
 In this exercise, we'll add a new command to our language of
    commands: <span class="inlinecode"><span class="id" type="var">REPEAT</span></span> c <span class="inlinecode"><span class="id" type="var">UNTIL</span></span> a <span class="inlinecode"><span class="id" type="var">END</span></span>. You will write the
    evaluation rule for <span class="inlinecode"><span class="id" type="tactic">repeat</span></span> and add a new Hoare rule to
    the language for programs involving it. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="RepeatExercise.com"><span class="id" type="inductive">com</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="RepeatExercise.CSkip"><span class="id" type="constructor">CSkip</span></a> : <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="RepeatExercise.CAsgn"><span class="id" type="constructor">CAsgn</span></a> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="RepeatExercise.CSeq"><span class="id" type="constructor">CSeq</span></a> : <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="RepeatExercise.CIf"><span class="id" type="constructor">CIf</span></a> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="RepeatExercise.CWhile"><span class="id" type="constructor">CWhile</span></a> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="RepeatExercise.CRepeat"><span class="id" type="constructor">CRepeat</span></a> : <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">REPEAT</span></span> behaves like <span class="inlinecode"><span class="id" type="var">WHILE</span></span>, except that the loop guard is
    checked <i>after</i> each execution of the body, with the loop
    repeating as long as the guard stays <i>false</i>.  Because of this,
    the body will always execute at least once. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Tactic Notation</span> "com_cases" <span class="id" type="var">tactic</span>(<span class="id" type="tactic">first</span>) <span class="id" type="var">ident</span>(<span class="id" type="var">c</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span>;<br/>
&nbsp;&nbsp;[ <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "SKIP" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "::=" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> ";"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "IFB" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "WHILE"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "CRepeat" ].<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name="RepeatExercise.::'SKIP'"><span class="id" type="notation">"</span></a>'SKIP'" := <br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#RepeatExercise.CSkip"><span class="id" type="constructor">CSkip</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="RepeatExercise.::x_';;'_x"><span class="id" type="notation">"</span></a>c1 ;; c2" := <br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#RepeatExercise.CSeq"><span class="id" type="constructor">CSeq</span></a> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="RepeatExercise.::x_'::='_x"><span class="id" type="notation">"</span></a>X '::=' a" := <br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#RepeatExercise.CAsgn"><span class="id" type="constructor">CAsgn</span></a> <span class="id" type="var">X</span> <span class="id" type="var">a</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 60).<br/>
<span class="id" type="keyword">Notation</span> <a name="RepeatExercise.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">"</span></a>'WHILE' b 'DO' c 'END'" := <br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#RepeatExercise.CWhile"><span class="id" type="constructor">CWhile</span></a> <span class="id" type="var">b</span> <span class="id" type="var">c</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="RepeatExercise.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">"</span></a>'IFB' e1 'THEN' e2 'ELSE' e3 'FI'" := <br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#RepeatExercise.CIf"><span class="id" type="constructor">CIf</span></a> <span class="id" type="var">e1</span> <span class="id" type="var">e2</span> <span class="id" type="var">e3</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="RepeatExercise.::'REPEAT'_x_'UNTIL'_x_'END'"><span class="id" type="notation">"</span></a>'REPEAT' e1 'UNTIL' b2 'END'" := <br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#RepeatExercise.CRepeat"><span class="id" type="constructor">CRepeat</span></a> <span class="id" type="var">e1</span> <span class="id" type="var">b2</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>

<br/>
</div>

<div class="doc">
Add new rules for <span class="inlinecode"><span class="id" type="var">REPEAT</span></span> to <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.ceval"><span class="id" type="inductive">ceval</span></a></span> below.  You can use the rules
    for <span class="inlinecode"><span class="id" type="var">WHILE</span></span> as a guide, but remember that the body of a <span class="inlinecode"><span class="id" type="var">REPEAT</span></span>
    should always execute at least once, and that the loop ends when
    the guard becomes true.  Then update the <span class="inlinecode"><span class="id" type="var">ceval_cases</span></span> tactic to
    handle these added cases.  
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <a name="RepeatExercise.ceval"><span class="id" type="inductive">ceval</span></a> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> → <a class="idref" href="Hoare.html#RepeatExercise.com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="RepeatExercise.E_Skip"><span class="id" type="constructor">E_Skip</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">st</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#ceval"><span class="id" type="inductive">ceval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::'SKIP'"><span class="id" type="notation">SKIP</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a><br/>
&nbsp;&nbsp;| <a name="RepeatExercise.E_Ass"><span class="id" type="constructor">E_Ass</span></a>  : <span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> <span class="id" type="var">a1</span> <span class="id" type="var">n</span> <span class="id" type="var">X</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare.html#n"><span class="id" type="variable">n</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#ceval"><span class="id" type="inductive">ceval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> (<a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Hoare.html#a1"><span class="id" type="variable">a1</span></a>) (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Hoare.html#n"><span class="id" type="variable">n</span></a>)<br/>
&nbsp;&nbsp;| <a name="RepeatExercise.E_Seq"><span class="id" type="constructor">E_Seq</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">st''</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#ceval"><span class="id" type="inductive">ceval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#ceval"><span class="id" type="inductive">ceval</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Hoare.html#st''"><span class="id" type="variable">st''</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#ceval"><span class="id" type="inductive">ceval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> (<a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a>) <a class="idref" href="Hoare.html#st''"><span class="id" type="variable">st''</span></a><br/>
&nbsp;&nbsp;| <a name="RepeatExercise.E_IfTrue"><span class="id" type="constructor">E_IfTrue</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">b1</span> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#ceval"><span class="id" type="inductive">ceval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#ceval"><span class="id" type="inductive">ceval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> (<a class="idref" href="Hoare.html#RepeatExercise.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a>) <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a><br/>
&nbsp;&nbsp;| <a name="RepeatExercise.E_IfFalse"><span class="id" type="constructor">E_IfFalse</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">b1</span> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#ceval"><span class="id" type="inductive">ceval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#ceval"><span class="id" type="inductive">ceval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> (<a class="idref" href="Hoare.html#RepeatExercise.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a>) <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a><br/>
&nbsp;&nbsp;| <a name="RepeatExercise.E_WhileEnd"><span class="id" type="constructor">E_WhileEnd</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">b1</span> <span class="id" type="var">st</span> <span class="id" type="var">c1</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#ceval"><span class="id" type="inductive">ceval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> (<a class="idref" href="Hoare.html#RepeatExercise.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>) <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a><br/>
&nbsp;&nbsp;| <a name="RepeatExercise.E_WhileLoop"><span class="id" type="constructor">E_WhileLoop</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">st''</span> <span class="id" type="var">b1</span> <span class="id" type="var">c1</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#ceval"><span class="id" type="inductive">ceval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#ceval"><span class="id" type="inductive">ceval</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> (<a class="idref" href="Hoare.html#RepeatExercise.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>) <a class="idref" href="Hoare.html#st''"><span class="id" type="variable">st''</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#ceval"><span class="id" type="inductive">ceval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> (<a class="idref" href="Hoare.html#RepeatExercise.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a>) <a class="idref" href="Hoare.html#st''"><span class="id" type="variable">st''</span></a><br/>
<br/>
.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "ceval_cases" <span class="id" type="var">tactic</span>(<span class="id" type="tactic">first</span>) <span class="id" type="var">ident</span>(<span class="id" type="var">c</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span>;<br/>
&nbsp;&nbsp;[ <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_Skip" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_Ass"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_Seq"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_IfTrue" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_IfFalse"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_WhileEnd" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_WhileLoop" <br/>
<br/>
].<br/>

<br/>
</div>

<div class="doc">
A couple of definitions from above, copied here so they use the
    new <span class="inlinecode"><a class="idref" href="Auto.html#Repeat.ceval"><span class="id" type="inductive">ceval</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Notation</span> <a name="RepeatExercise.::x_'/'_x_'||'_x"><span class="id" type="notation">"</span></a>c1 '/' st '||' st'" := (<a class="idref" href="Hoare.html#RepeatExercise.ceval"><span class="id" type="inductive">ceval</span></a> <span class="id" type="var">st</span> <span class="id" type="var">c1</span> <span class="id" type="var">st'</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 40, <span class="id" type="var">st</span> <span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 39).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <a name="RepeatExercise.hoare_triple"><span class="id" type="definition">hoare_triple</span></a> (<span class="id" type="var">P</span>:<a class="idref" href="Hoare.html#RepeatExercise.Assertion"><span class="id" type="definition">Assertion</span></a>) (<span class="id" type="var">c</span>:<a class="idref" href="Hoare.html#RepeatExercise.com"><span class="id" type="inductive">com</span></a>) (<span class="id" type="var">Q</span>:<a class="idref" href="Hoare.html#RepeatExercise.Assertion"><span class="id" type="definition">Assertion</span></a>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>, (<a class="idref" href="Hoare.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a>) → <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> → <a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name="RepeatExercise.::'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">"</span></a>{{ P }}  c  {{ Q }}" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#RepeatExercise.hoare_triple"><span class="id" type="definition">hoare_triple</span></a> <span class="id" type="var">P</span> <span class="id" type="var">c</span> <span class="id" type="var">Q</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 90, <span class="id" type="var">c</span> <span class="id" type="tactic">at</span> <span class="id" type="var">next</span> <span class="id" type="keyword">level</span>).<br/>

<br/>
</div>

<div class="doc">
To make sure you've got the evaluation rules for <span class="inlinecode"><span class="id" type="var">REPEAT</span></span> right,
    prove that <span class="inlinecode"><a class="idref" href="Hoare.html#RepeatExercise.ex1_repeat"><span class="id" type="definition">ex1_repeat</span></a></span> <span class="inlinecode"><span class="id" type="var">evaluates</span></span> <span class="inlinecode"><span class="id" type="var">correctly</span>.</span> <span class="inlinecode"></span>
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="RepeatExercise.ex1_repeat"><span class="id" type="definition">ex1_repeat</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#RepeatExercise.::'REPEAT'_x_'UNTIL'_x_'END'"><span class="id" type="notation">REPEAT</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1<a class="idref" href="Hoare.html#RepeatExercise.::x_';;'_x"><span class="id" type="notation">;;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Imp.html#APlus"><span class="id" type="constructor">APlus</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#RepeatExercise.::'REPEAT'_x_'UNTIL'_x_'END'"><span class="id" type="notation">UNTIL</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::'REPEAT'_x_'UNTIL'_x_'END'"><span class="id" type="notation">(</span></a><a class="idref" href="Imp.html#BEq"><span class="id" type="constructor">BEq</span></a> (<a class="idref" href="Imp.html#AId"><span class="id" type="constructor">AId</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a>) (<a class="idref" href="Imp.html#ANum"><span class="id" type="constructor">ANum</span></a> 1)<a class="idref" href="Hoare.html#RepeatExercise.::'REPEAT'_x_'UNTIL'_x_'END'"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::'REPEAT'_x_'UNTIL'_x_'END'"><span class="id" type="notation">END</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="RepeatExercise.ex1_repeat_works"><span class="id" type="lemma">ex1_repeat_works</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#RepeatExercise.ex1_repeat"><span class="id" type="definition">ex1_repeat</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> <a class="idref" href="Hoare.html#RepeatExercise.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> (<a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Imp.html#empty_state"><span class="id" type="definition">empty_state</span></a> <a class="idref" href="Imp.html#X"><span class="id" type="definition">X</span></a> 1) <a class="idref" href="Imp.html#Y"><span class="id" type="definition">Y</span></a> 1.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Now state and prove a theorem, <span class="inlinecode"><span class="id" type="var">hoare_repeat</span></span>, that expresses an
    appropriate proof rule for <span class="inlinecode"><span class="id" type="tactic">repeat</span></span> commands.  Use <span class="inlinecode"><a class="idref" href="Hoare.html#hoare_while"><span class="id" type="lemma">hoare_while</span></a></span>
    as a model, and try to make your rule as precise as possible. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
For full credit, make sure (informally) that your rule can be used
    to prove the following valid Hoare triple:
  <a href=" X > 0 "> X > 0 </a>
  REPEAT
    Y ::= X;;
    X ::= X - 1
  UNTIL X = 0 END
  <a href=" X = 0 /\ Y > 0 "> X = 0 /\ Y > 0 </a>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Hoare.html#RepeatExercise"><span class="id" type="module">RepeatExercise</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab567"></a><h2 class="section">Exercise: <span class="inlinecode"><span class="id" type="var">HAVOC</span></span></h2>

<div class="paragraph"> </div>

<a name="lab568"></a><h4 class="section">Exercise: 3 stars (himp_hoare)</h4>

<div class="paragraph"> </div>

 In this exercise, we will derive proof rules for the <span class="inlinecode"><span class="id" type="var">HAVOC</span></span> command
    which we studied in the last chapter. First, we enclose this work
    in a separate module, and recall the syntax and big-step semantics
    of Himp commands. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Module</span> <a name="Himp"><span class="id" type="module">Himp</span></a>.<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <a name="Himp.com"><span class="id" type="inductive">com</span></a> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a name="Himp.CSkip"><span class="id" type="constructor">CSkip</span></a> : <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.CAsgn"><span class="id" type="constructor">CAsgn</span></a> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a> → <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.CSeq"><span class="id" type="constructor">CSeq</span></a> : <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.CIf"><span class="id" type="constructor">CIf</span></a> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.CWhile"><span class="id" type="constructor">CWhile</span></a> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.CHavoc"><span class="id" type="constructor">CHavoc</span></a> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a> → <a class="idref" href="Hoare.html#com"><span class="id" type="inductive">com</span></a>.<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "com_cases" <span class="id" type="var">tactic</span>(<span class="id" type="tactic">first</span>) <span class="id" type="var">ident</span>(<span class="id" type="var">c</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span>;<br/>
&nbsp;&nbsp;[ <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "SKIP" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "::=" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> ";"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "IFB" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "WHILE" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "HAVOC" ].<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name="Himp.::'SKIP'"><span class="id" type="notation">"</span></a>'SKIP'" :=<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#Himp.CSkip"><span class="id" type="constructor">CSkip</span></a>.<br/>
<span class="id" type="keyword">Notation</span> <a name="Himp.::x_'::='_x"><span class="id" type="notation">"</span></a>X '::=' a" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#Himp.CAsgn"><span class="id" type="constructor">CAsgn</span></a> <span class="id" type="var">X</span> <span class="id" type="var">a</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 60).<br/>
<span class="id" type="keyword">Notation</span> <a name="Himp.::x_';;'_x"><span class="id" type="notation">"</span></a>c1 ;; c2" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#Himp.CSeq"><span class="id" type="constructor">CSeq</span></a> <span class="id" type="var">c1</span> <span class="id" type="var">c2</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">"</span></a>'WHILE' b 'DO' c 'END'" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#Himp.CWhile"><span class="id" type="constructor">CWhile</span></a> <span class="id" type="var">b</span> <span class="id" type="var">c</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">"</span></a>'IFB' e1 'THEN' e2 'ELSE' e3 'FI'" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Hoare.html#Himp.CIf"><span class="id" type="constructor">CIf</span></a> <span class="id" type="var">e1</span> <span class="id" type="var">e2</span> <span class="id" type="var">e3</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 80, <span class="id" type="tactic">right</span> <span class="id" type="keyword">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> <a name="Himp.::'HAVOC'_x"><span class="id" type="notation">"</span></a>'HAVOC' X" := (<a class="idref" href="Hoare.html#Himp.CHavoc"><span class="id" type="constructor">CHavoc</span></a> <span class="id" type="var">X</span>) (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 60).<br/>

<br/>
<span class="id" type="keyword">Reserved Notation</span> "c1 '/' st '||' st'" (<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 40, <span class="id" type="var">st</span> <span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 39).<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <a name="Himp.ceval"><span class="id" type="inductive">ceval</span></a> : <a class="idref" href="Hoare.html#Himp.com"><span class="id" type="inductive">com</span></a> → <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> → <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="Himp.E_Skip"><span class="id" type="constructor">E_Skip</span></a> : <span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>, <a class="idref" href="Hoare.html#Himp.::'SKIP'"><span class="id" type="notation">SKIP</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.E_Ass"><span class="id" type="constructor">E_Ass</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">a1</span> : <a class="idref" href="Imp.html#aexp"><span class="id" type="inductive">aexp</span></a>) (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">X</span> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#aeval"><span class="id" type="definition">aeval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#a1"><span class="id" type="variable">a1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="Hoare.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Hoare.html#Himp.::x_'::='_x"><span class="id" type="notation">::=</span></a> <a class="idref" href="Hoare.html#a1"><span class="id" type="variable">a1</span></a><a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Hoare.html#n"><span class="id" type="variable">n</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.E_Seq"><span class="id" type="constructor">E_Seq</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">c1</span> <span class="id" type="var">c2</span> : <a class="idref" href="Hoare.html#Himp.com"><span class="id" type="inductive">com</span></a>) (<span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">st''</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> → <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st''"><span class="id" type="variable">st''</span></a> → <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#Himp.::x_';;'_x"><span class="id" type="notation">;;</span></a> <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a><a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st''"><span class="id" type="variable">st''</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.E_IfTrue"><span class="id" type="constructor">E_IfTrue</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> <span class="id" type="var">st'</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">b1</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) (<span class="id" type="var">c1</span> <span class="id" type="var">c2</span> : <a class="idref" href="Hoare.html#Himp.com"><span class="id" type="inductive">com</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> → <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Hoare.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Hoare.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a><a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.E_IfFalse"><span class="id" type="constructor">E_IfFalse</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> <span class="id" type="var">st'</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">b1</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) (<span class="id" type="var">c1</span> <span class="id" type="var">c2</span> : <a class="idref" href="Hoare.html#Himp.com"><span class="id" type="inductive">com</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> → <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">IFB</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Hoare.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">THEN</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">ELSE</span></a> <a class="idref" href="Hoare.html#c2"><span class="id" type="variable">c2</span></a> <a class="idref" href="Hoare.html#Himp.::'IFB'_x_'THEN'_x_'ELSE'_x_'FI'"><span class="id" type="notation">FI</span></a><a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.E_WhileEnd"><span class="id" type="constructor">E_WhileEnd</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">b1</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">c1</span> : <a class="idref" href="Hoare.html#Himp.com"><span class="id" type="inductive">com</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#false"><span class="id" type="constructor">false</span></a> → <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Hoare.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.E_WhileLoop"><span class="id" type="constructor">E_WhileLoop</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">st''</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">b1</span> : <a class="idref" href="Imp.html#bexp"><span class="id" type="inductive">bexp</span></a>) (<span class="id" type="var">c1</span> : <a class="idref" href="Hoare.html#Himp.com"><span class="id" type="inductive">com</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Imp.html#beval"><span class="id" type="definition">beval</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Logic.html#:type_scope:x_'='_x"><span class="id" type="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#true"><span class="id" type="constructor">true</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Hoare.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st''"><span class="id" type="variable">st''</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">WHILE</span></a> <a class="idref" href="Hoare.html#b1"><span class="id" type="variable">b1</span></a> <a class="idref" href="Hoare.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">DO</span></a> <a class="idref" href="Hoare.html#c1"><span class="id" type="variable">c1</span></a> <a class="idref" href="Hoare.html#Himp.::'WHILE'_x_'DO'_x_'END'"><span class="id" type="notation">END</span></a><a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st''"><span class="id" type="variable">st''</span></a><br/>
&nbsp;&nbsp;| <a name="Himp.E_Havoc"><span class="id" type="constructor">E_Havoc</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">st</span> : <a class="idref" href="Imp.html#state"><span class="id" type="definition">state</span></a>) (<span class="id" type="var">X</span> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a>) (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.4pl5/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">(</span></a><a class="idref" href="Hoare.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a><a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">)</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Imp.html#update"><span class="id" type="definition">update</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Hoare.html#n"><span class="id" type="variable">n</span></a><br/>
<br/>
&nbsp;&nbsp;<span class="id" type="keyword">where</span> <a name="Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">"</span></a>c1 '/' st '||' st'" := (<a class="idref" href="Hoare.html#ceval"><span class="id" type="inductive">ceval</span></a> <span class="id" type="var">c1</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>).<br/>

<br/>
<span class="id" type="keyword">Tactic Notation</span> "ceval_cases" <span class="id" type="var">tactic</span>(<span class="id" type="tactic">first</span>) <span class="id" type="var">ident</span>(<span class="id" type="var">c</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">first</span>;<br/>
&nbsp;&nbsp;[ <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_Skip" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_Ass" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_Seq"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_IfTrue" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_IfFalse"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_WhileEnd" | <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_WhileLoop"<br/>
&nbsp;&nbsp;| <span class="id" type="var">Case_aux</span> <span class="id" type="var">c</span> "E_Havoc" ].<br/>

<br/>
</div>

<div class="doc">
The definition of Hoare triples is exactly as before. Unlike our
    notion of program equivalence, which had subtle consequences with
    occassionally nonterminating commands (exercise <span class="inlinecode"><span class="id" type="var">havoc_diverge</span></span>),
    this definition is still fully satisfactory. Convince yourself of
    this before proceeding. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="Himp.hoare_triple"><span class="id" type="definition">hoare_triple</span></a> (<span class="id" type="var">P</span>:<a class="idref" href="Hoare.html#Himp.Assertion"><span class="id" type="definition">Assertion</span></a>) (<span class="id" type="var">c</span>:<a class="idref" href="Hoare.html#Himp.com"><span class="id" type="inductive">com</span></a>) (<span class="id" type="var">Q</span>:<a class="idref" href="Hoare.html#Himp.Assertion"><span class="id" type="definition">Assertion</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">∀</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span>, <a class="idref" href="Hoare.html#c"><span class="id" type="variable">c</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">/</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> <a class="idref" href="Hoare.html#Himp.::x_'/'_x_'||'_x"><span class="id" type="notation">||</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a> → <a class="idref" href="Hoare.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Hoare.html#st"><span class="id" type="variable">st</span></a> → <a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Hoare.html#st'"><span class="id" type="variable">st'</span></a>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> <a name="Himp.:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">"</span></a>{{ P }}  c  {{ Q }}" := (<a class="idref" href="Hoare.html#Himp.hoare_triple"><span class="id" type="definition">hoare_triple</span></a> <span class="id" type="var">P</span> <span class="id" type="var">c</span> <span class="id" type="var">Q</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="keyword">level</span> 90, <span class="id" type="var">c</span> <span class="id" type="tactic">at</span> <span class="id" type="var">next</span> <span class="id" type="keyword">level</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">hoare_spec_scope</span>.<br/>

<br/>
</div>

<div class="doc">
Complete the Hoare rule for <span class="inlinecode"><span class="id" type="var">HAVOC</span></span> commands below by defining
    <span class="inlinecode"><a class="idref" href="Hoare.html#Himp.havoc_pre"><span class="id" type="definition">havoc_pre</span></a></span> and prove that the resulting rule is correct. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <a name="Himp.havoc_pre"><span class="id" type="definition">havoc_pre</span></a> (<span class="id" type="var">X</span> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a>) (<span class="id" type="var">Q</span> : <a class="idref" href="Hoare.html#Himp.Assertion"><span class="id" type="definition">Assertion</span></a>) : <a class="idref" href="Hoare.html#Himp.Assertion"><span class="id" type="definition">Assertion</span></a> :=<br/>
 <a class="idref" href="SfLib.html#admit"><span class="id" type="axiom">admit</span></a>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <a name="Himp.hoare_havoc"><span class="id" type="lemma">hoare_havoc</span></a> : <span class="id" type="keyword">∀</span> (<span class="id" type="var">Q</span> : <a class="idref" href="Hoare.html#Himp.Assertion"><span class="id" type="definition">Assertion</span></a>) (<span class="id" type="var">X</span> : <a class="idref" href="SfLib.html#id"><span class="id" type="inductive">id</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Hoare.html#Himp.:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <a class="idref" href="Hoare.html#Himp.havoc_pre"><span class="id" type="definition">havoc_pre</span></a> <a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Hoare.html#Himp.:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a> <a class="idref" href="Hoare.html#Himp.::'HAVOC'_x"><span class="id" type="notation">HAVOC</span></a> <a class="idref" href="Hoare.html#X"><span class="id" type="variable">X</span></a> <a class="idref" href="Hoare.html#Himp.:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">{{</span></a> <a class="idref" href="Hoare.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="Hoare.html#Himp.:hoare_spec_scope:'{{'_x_'}}'_x_'{{'_x_'}}'"><span class="id" type="notation">}}</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
 <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <a class="idref" href="Hoare.html#Himp"><span class="id" type="module">Himp</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab569"></a><h2 class="section">Complete List of Hoare Logic Rules</h2>

<div class="paragraph"> </div>

 Above, we've introduced Hoare Logic as a tool to reasoning
    about Imp programs. In the reminder of this chapter we will
    explore a systematic way to use Hoare Logic to prove properties
    about programs. The rules of Hoare Logic are the following: 
<div class="paragraph"> </div>

<hr/>
 (hoare_asgn)
             <a href="Q [X |-> a]">Q [X |-> a]</a> X::=a <a href="Q">Q</a>
<hr/>
  (hoare_skip)
             <a href=" P "> P </a> SKIP <a href=" P "> P </a>

<div class="paragraph"> </div>

               <a href=" P "> P </a> c1 <a href=" Q "> Q </a> 
               <a href=" Q "> Q </a> c2 <a href=" R "> R </a>
<hr/>
  (hoare_seq)
              <a href=" P "> P </a> c1;;c2 <a href=" R "> R </a>

<div class="paragraph"> </div>

              <a href="P /\  b">P /\  b</a> c1 <a href="Q">Q</a>
              <a href="P /\ ~b">P /\ ~b</a> c2 <a href="Q">Q</a>
<hr/>
  (hoare_if)
      <a href="P">P</a> IFB b THEN c1 ELSE c2 FI <a href="Q">Q</a> 

<div class="paragraph"> </div>

               <a href="P /\ b">P /\ b</a> c <a href="P">P</a>
<hr/>
  (hoare_while)
        <a href="P">P</a> WHILE b DO c END <a href="P /\ ~b">P /\ ~b</a>

<div class="paragraph"> </div>

                <a href="P'">P'</a> c <a href="Q'">Q'</a>
                   P -&gt;&gt; P'
                   Q' -&gt;&gt; Q
<hr/>
   (hoare_consequence)
                <a href="P">P</a> c <a href="Q">Q</a>
    In the next chapter, we'll see how these rules are used to prove
    that programs satisfy specifications of their behavior.

<div class="paragraph"> </div>

  
</div>
<div class="code">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>